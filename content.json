{"meta":{"title":"杨柳潇的博客","subtitle":null,"description":"杨柳潇个人主页","author":"Mute","url":"http://yangliuxiao.top"},"pages":[],"posts":[{"title":"萧瑟秋风今又是换了人间","slug":"萧瑟秋风今又是换了人间","date":"2019-06-01T01:53:25.000Z","updated":"2019-06-01T08:08:14.290Z","comments":false,"path":"2019/06/01/萧瑟秋风今又是换了人间/","link":"","permalink":"http://yangliuxiao.top/2019/06/01/萧瑟秋风今又是换了人间/","excerpt":"","text":"胡言古人云 “民可使由之不可使知之” ——孔子 “是以圣人之治，虚其心，实其腹；弱其志，强其骨。常使民无知无欲，使夫智者不敢为也。为无为，则无不治。” ——老子 我云有感于近日某事，思考良久，仍然没有一个合适的普世答案。但问题不大，能说服自己就好。王阳明心学虽然不合唯物主义，但不要把它用在科学原理上，只用在为人处世、认识自身方面，又能起到佛教心无挂碍的作用，又能起到道家宠辱不惊的作用，还能起到儒家良能良知的作用，实在是解疑释难的不二良方啊。 乱语从大禹说起大禹那个时代实在是离现在太遥远了，遥远到一些历史已经模糊不清，难以确认。究竟是不是大禹破坏了禅让制？有的说是因为禹的儿子启贤明，以至于那些臣子不服从禹名正言顺禅让王位的益，转而从启；也有说是启使用武力杀了益，然后得到了王位；还有的说是大禹在死前有意培养自己的儿子启，架空了益，导致禅让给益之后，大家都不听益的，转而拥戴启……真相消失在大禹治好的滚滚流水中。唯一可以确定的是：自禹起，和平的政权更替制度禅让制已经发展到了尽头，从此以后的皇朝更替都伴随着战争和腥风血雨…… 得国正者，唯汉与明先捋一捋这两千来年，中华大地上都发生了什么？ 之前的事太遥远了，从始皇帝说起。 秦：从养马的到始皇灭六国，秦二世而亡； 西汉：刘邦斩白蛇建汉朝，是为西汉； 新：王莽篡汉，建新朝； 东汉：穿越者王莽改革步子迈太大，刘秀建东汉； 三国：东汉末年分三国；烽火连天不休，儿女情长被乱石左右，谁来煮酒 西晋：曹魏为司马所趁，建晋朝，是为西晋，为魏晋南北朝短暂统一的一段时期； 东晋：西晋八王之乱后，五胡乱华，衣冠南渡，建东晋； 南北朝：东晋十六国，南北朝，中华大地进入动荡分裂时期； 隋：杨坚得北周，统一中国，结束了自西晋末年以来长达近300年的分裂，建隋朝； 唐：杨广倒行逆施，李渊建唐朝； 五代十国：唐末，群雄割据，进入五代十国时期； 北宋：赵匡胤陈桥兵变，黄袍加身，建宋朝，统一全国大部分，是为北宋； 南宋：靖康之耻后，宋高宗逃往南方，建南宋； 元：崖山一战，南宋灭亡，蒙元最终统一整个中国。 明：朱元璋起义，建明朝； 清：清军入关，崇祯帝自缢，明朝灭亡； “得国正者，唯汉与明”这话是我国近代史学家孟森在其《明史讲义》中说的。意思是刘邦和朱元璋都是布衣起义，反抗暴政，而非单纯为了自己的权力野心。秦末和元末之时一个是苛政猛如虎导致民不聊生，一个是重税加上民族矛盾，于是刘邦斩白蛇，朱元璋高喊“驱除胡虏，恢复中华”，都是所谓顺应民心，顺应天道的起义，而非争权夺利的谋反或者屠刀铁蹄的侵略。所谓“为民除暴，无预窥神器之意”，这两位起义的本意和初衷都是替天行道，不是为了自己当皇帝，与之相对的就是西晋司马氏篡曹魏，儿皇帝石敬瑭割地求荣等行为，已经被批判千百年了，这里懒得再聊了。 文章开头就引用了孔子和老子的两句话，已经被各种学者争议许久了。究竟是不是愚民？应不应该愚民？愚民会怎么样，不愚民又会怎么样？ “群体的叠加只是愚蠢的叠加，而真正的智慧却被愚蠢的洪流淹没了。” ——《乌合之众》 民心难以控制，可以被正着用，也可以被反着用。要聊愚民，就要先聊民心，要聊民心，就要先聊思想，要聊思想，问题就向着哲学方向越走越远了……所以不该聊思想，聊物质。 民心应该依赖于物质。吃得好穿的暖，才应该是检验社会的唯一标准。从我出生到现在，既然还没有负过我，所以网上的一些史实，大可不必理会。往事俱已，即使知道了又如何，不知道又如何？我这个小农思想下的政治历史是非观就是：不管过往，只看眼前，不论根本，只问己心。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yangliuxiao.top/categories/随笔/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://yangliuxiao.top/tags/阅读/"},{"name":"随笔","slug":"随笔","permalink":"http://yangliuxiao.top/tags/随笔/"},{"name":"思考","slug":"思考","permalink":"http://yangliuxiao.top/tags/思考/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yangliuxiao.top/categories/随笔/"}]},{"title":"Http与Https","slug":"Http与Https","date":"2019-05-28T01:05:23.000Z","updated":"2019-05-28T07:58:25.073Z","comments":false,"path":"2019/05/28/Http与Https/","link":"","permalink":"http://yangliuxiao.top/2019/05/28/Http与Https/","excerpt":"","text":"参考文章： 为什么HTTPS比HTTP更安全? ——浪里行舟 关于Http协议，你必须要知道的——ljianshu 一、HTTPHTTP与HTTPS都是应用层协议。HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP 基于 TCP/IP 协议通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 1.1 Http的特点1.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、PUT、DELETE、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2.灵活：HTTP允许传输任意类型的数据对象。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（随着时代发展，文档中包含大量图片的情况多了起来，Http1.1以及部分1.0开始使用持久连接） 4.无状态：HTTP协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。协议本身并不保留之前一切的请求或 响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。 1.2 Http报文☆Http报文包括请求报文和响应报文两大部分，其中请求报文由请求行（request line）、请求头（header）、空行和请求体四个部分组成（请求头与请求体之间一定存在空行）。而响应报文由状态行（状态码+解释状态码的短语）、响应头部、空行和响应体四个部分组成。接下来我们详细介绍下请求报文的各个部分及其作用。 1.3 Http请求方法 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 1.4 GET方法与POST方法的区别☆ GET在浏览器回退时是无害的，而POST会再次提交请求 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST没有限制 GET参数通过URL传递，POST放在Request body中 1.5 Http状态码☆状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息—表示请求已接收，继续处理 2xx：成功—表示请求已被成功接收、理解、接受 3xx：重定向—要完成请求必须进行更进一步的操作 4xx：客户端错误—请求有语法错误或请求无法实现 5xx：服务器端错误—服务器未能实现合法的请求 1.6 持久连接HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请 求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成多余的 TCP 连接建立和断开，增加通信量的开销。 为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。 在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。 1.7 管线化（管道化）持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。 这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。通俗地讲，请求打包一次传输过去，响应打包一次传递回来。管线化的前提是在持久连接下。（消息队列） 假如当请求一个包含 10 张图片的 HTML Web 页面，与无连接相比，用持久连接可以让请求更快结束。 而管道化技术则比持久连接还要快。请求数越多，时间差就越明显。客户端需要请求这十个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求，以此类推，而管道机制则是允许浏览器同时发出这十个请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 于是在使用持久连接的情况下，某个连接上消息的传递类似于 请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3 管线化方式发送变成了类似这样： 请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3 二、HTTPSHTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTPS主要作用是： （1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全; （2）对网站服务器进行真实身份认证。 我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用http://，而是改用https://。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变。 2.1 为什么需要Https（Http的缺陷）Http存在以下缺陷： ① 通信使用明文（不加密），内容可能被窃听； 会导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题，通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。 ② 无法证明报文的完整性，所以可能遭篡改； 所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。也就是说在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。 换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。 ③ 不验证通信方的身份，因此有可能遭遇伪装； HTTP协议中的请求和响应不会对通信方进行确认。服务器只要接收到请求，不管对方是谁都会返回一个响应（在发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下），这样就会存在伪造请求欺骗服务器的情况；也存在伪造虚假服务器欺骗用户的情况，实现“钓鱼欺诈”，用户无法察觉。 Https的优势： 数据加密：内容经过对称加密，每个连接生成一个唯一的加密密钥 数据完整性：内容传输经过完整性校验 身份认证：第三方无法伪造服务端（客户端）身份 2.2 Https的优势HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。 通常，HTTP直接和TCP通信。当使用Https时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。 在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，使用非对称加密实现身份认证和密钥协商，使用对称加密算法，采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 2.2.1 解决信息窃听风险——加密方法1.对称加密 这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。 方法2.非对称加密 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。 这种方式有以下缺点： 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容； 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改； 使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率； 方法3.对称加密+非对称加密(HTTPS采用这种方式) 使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。 具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。 （即使用非对称加密，将对称加密的秘钥发送给对方，接收到对称加密的秘钥之后，就可以使用对称加密进行通信） 2.2.2 解决信息篡改（数据完整性校验）及身份验证风险——数字签名 2.3 Https工作流程 1.Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。 3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 6.Server使用对称密钥加密“明文内容A”，发送给Client。 7.Client使用对称密钥解密响应的密文，得到“明文内容A”。 8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。","categories":[{"name":"网络","slug":"网络","permalink":"http://yangliuxiao.top/categories/网络/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"网络","slug":"网络","permalink":"http://yangliuxiao.top/tags/网络/"}],"keywords":[{"name":"网络","slug":"网络","permalink":"http://yangliuxiao.top/categories/网络/"}]},{"title":"SpringBoot简述","slug":"SpringBoot简述","date":"2019-05-27T09:08:48.000Z","updated":"2019-05-30T06:38:42.371Z","comments":false,"path":"2019/05/27/SpringBoot简述/","link":"","permalink":"http://yangliuxiao.top/2019/05/27/SpringBoot简述/","excerpt":"","text":"参考文章： 构建微服务：Spring boot 入门篇 Spring Boot 2.x 系列教程 SpringMVC和Springboot的区别（网摘） Spring-Spring、SpringMVC与SpringBoot三者的关系 Spring、SpringMVC、SpringBoot的区别1. Spring 总的来说Spring是使用基本的JavaBean代替EJB，通过容器管理JavaBean的配置和声明周期，在此基础上实现了Spring的核心功能：AOP、IOC，其他web框架组件在AOP、IOC的基础上工作，将JavaBean交给Spring来管理。简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 2. SpringMVC ① Spring MVC就是一个类似于Strust2的一个MVC开发框架，是Spring开源项目的其中一个，Spring MVC需要有Spring的架包作为支撑才能跑起来。Spring MVC annotation式的开发比Struts2方便，可以直接代替SSH中的Struts（当然Struts的做为一个非常成熟的MVC，功能上感觉还是比Spring MVC强一点，不过Spring MVC已经足够用了）。SpringMVC的执行效率比Struts高，因为Struts的值栈影响效率。 ② Spring可以说是一个管理bean的容器，也可以说是包括很多开源项目的总称，Spring MVC是其中一个开源项目，③ SpringMVC的处理流程：接收到http请求后，由容器（如：tomact）解析http封装成一个request，通过映射关系（路径，方法，参数……），由Spring MVC的一个分发器在tomcat里的由Spring管理的bean的一个池子（bean容器）里面找到可以处理这个请求的bean，处理完了就返回响应。 3. Spring BootSpring Boot不是一门新技术。从本质上来说，Spring Boot就是Spring，它只是做了一些对Spring Bean的默认配置。 核心理念：开箱即用，快速启动 它使用“约定优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar,内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。 约定优于配置（convention over configuration）: 也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。如果所用工具的约定与你的期待相符，便可省去配置；反之，你可以配置来达到你所期待的方式。 Spring Boot概述Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要编写样板化的配置。 Spring 家族发展到今天，已经很庞大了，作为一个开发者，如果想要使用 Spring 家族一系列的技术，需要一个一个地配置，还需要关心版本兼容性问题，繁琐且影响开发进度， Spring Boot 就是来解决这个问题，可以先不关心如何配置，快速地启动开发，进行业务逻辑编写，其他各种需要的技术，加入对应的 starter 就配置好了，直接使用。 Spring Boot 一些常用的基础框架组合起来，提供默认的配置，提供可插拔的设计（starter）来方便开发者使用这一系列的技术。 Spring Boot的优点Spring Boot最重要的是以下四个核心： ① 自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置 ② 起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。 ③ 命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。 ④ Actuator：让你能够深入运行中的Spring Boot应用程序，一套究竟。 ① 自动配置在任何Spring应用程序的源代码里，你都会找到Java配置或XML配置（抑或两者皆有），它们为应用程序开启了特定的特性和功能。举个例子，如果你写过用JDBC访问关系型数据库的应用程序，那你一定在Spring应用程序上下文里配置过JdbcTemplate这个Bean。那段配置看起来会是这样的： 12345@Bean public JdbcTemplate jdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; 这段非常简单的Bean声明创建了一个JdbcTemplate的实例，注入了一个DataSource依赖。当然，这意味着你还需要配置一个DataSource的Bean，这样才能满足依赖。假设你将配置一个嵌入式H2数据库作为DataSource Bean，完成这个配置场景的代码大概是这样的： 12345678@Bean public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScripts('schema.sql', 'data.sql') .build(); &#125; 这个Bean配置方法创建了一个嵌入式数据库，并指定在该数据库上执行两段SQL脚本。build()方法返回了一个指向该数据库的引用。 这两个Bean配置方法都不复杂，也不是很长，但它们只是典型Spring应用程序配置的一小部分。除此之外，还有无数Spring应用程序有着完全相同的方法。所有需要用到嵌入式数据库和JdbcTemplate的应用程序都会用到那些方法。简而言之，这就是一个样板配置。既然它如此常见，那为什么还要你去写呢？ Spring Boot会为这些常见配置场景进行自动配置。如果Spring Boot在应用程序的Classpath里发现H2数据库的库，那么它就自动配置一个嵌入式H2数据库。如果在Classpath里发现JdbcTemplate，那么它还会为你配置一个JdbcTemplate的Bean。你无需操心那些Bean的配置，Spring Boot会做好准备，随时都能将其注入到你的Bean里。Spring Boot的自动配置远不止嵌入式数据库和JdbcTemplate，它有大把的办法帮你减轻配置负担，这些自动配置涉及Java持久化API（Java Persistence API，JPA）、Thymeleaf模板、安全和Spring MVC。 ② 起步依赖向项目中添加依赖是件富有挑战的事。你需要什么库？它的Group和Artifact是什么？你需要哪个版本？哪个版本不会和项目中的其他依赖发生冲突？Spring Boot通过起步依赖为项目的依赖管理提供帮助。起步依赖其实就是特殊的Maven依赖和Gradle依赖，利用了传递依赖解析，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。 举个例子，假设你正在用Spring MVC构造一个REST API，并将JSON（JavaScript ObjectNotation）作为资源表述。此外，你还想运用遵循JSR-303规范的声明式校验，并使用嵌入式的Tomcat服务器来提供服务。要实现以上目标，你在Maven或Gradle里至少需要以下8个依赖：  org.springframework:spring-core  org.springframework:spring-web  org.springframework:spring-webmvc  com.fasterxml.jackson.core:jackson-databind  org.hibernate:hibernate-validator  org.apache.tomcat.embed:tomcat-embed-core  org.apache.tomcat.embed:tomcat-embed-el  org.apache.tomcat.embed:tomcat-embed-logging-juli 不过，如果打算利用Spring Boot的起步依赖，你只需添加Spring Boot的Web起步依赖（即不同的starter） （org.springframework.boot:spring-boot-starter-web），仅此一个。它会根据依赖传递把其他所需依赖引入项目里，你都不用考虑它们。比起减少依赖数量，起步依赖还引入了一些微妙的变化。向项目中添加了Web起步依赖，实际上指定了应用程序所需的一类功能。因为应用是个Web应用程序，所以加入了Web起步依赖。与之类似，如果应用程序要用到JPA持久化，那么就可以加入jpa起步依赖。如果需要安全功能，那就加入security起步依赖。简而言之，你不再需要考虑支持某种功能要用什么库了，引入相关起步依赖就行。 此外，Spring Boot的起步依赖还把你从“需要这些库的哪些版本”这个问题里解放了出来。起步依赖引入的库的版本都是经过测试的，因此你可以完全放心，它们之间不会出现不兼容的情况。 ③ 命令行界面除了自动配置和起步依赖，Spring Boot还提供了一种很有意思的新方法，可以快速开发Spring应用程序。正如之前在1.1节里看到的那样，Spring Boot CLI让只写命令行代码即可实现应用程序成为可能。 Spring Boot CLI利用了起步依赖和自动配置，让你专注于代码本身。不仅如此，你是否注意到代码清单1-1里没有import？CLI如何知道RequestMapping和RestController来自哪个包呢？说到这个问题，那些类最终又是怎么跑到Classpath里的呢？ 说得简单一点，CLI能检测到你使用了哪些类，它知道要向Classpath中添加哪些起步依赖才能让它运转起来。一旦那些依赖出现在Classpath中，一系列自动配置就会接踵而来，确保启用DispatcherServlet和Spring MVC，这样控制器就能响应HTTP请求了。 Spring Boot CLI是Spring Boot的非必要组成部分。虽然它为Spring带来了惊人的力量，大大简化了开发，但也引入了一套不太常规的开发模型。要是这种开发模型与你的口味相去甚远，那也没关系，抛开CLI，你还是可以利用Spring Boot提供的其他东西。 ④ ActuatorSpring Boot的最后一块“拼图”是Actuator，其他几个部分旨在简化Spring开发，而Actuator则要提供在运行时检视应用程序内部情况的能力。安装了Actuator就能窥探应用程序的内部情况了，包括如下细节：  Spring应用程序上下文里配置的Bean  Spring Boot的自动配置做的决策  应用程序取到的环境变量、系统属性、配置属性和命令行参数  应用程序里线程的当前状态  应用程序最近处理过的HTTP请求的追踪情况  各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标 Actuator通过Web端点和shell界面向外界提供信息。如果要借助shell界面，你可以打开SSH（Secure Shell），登入运行中的应用程序，发送指令查看它的情况。 总结Spring Boot没有引入任何形式的代码生成，而是利用了Spring 4的条件化配置特性，以及Maven和Gradle提供的传递依赖解析，以此实现Spring应用程序上下文里的自动配置。 简而言之，从本质上来说，Spring Boot就是Spring，它只是做了那些没有它你自己也会去做的SpringBean配置，有了Spring，你就不用再写这些样板配置了，可以专注于应用程序的逻辑。 所以，Spring Boot的项目其实只是普通的Spring项目，只是它们正好用到了Spring Boot的起步依赖和自动配置而已。因此，那些你早已熟悉的从头创建Spring项目的技术或工具，都能用于Spring Boot项目。 自动配置消除了传统Spring应用程序里的很多样板配置；Spring Boot起步依赖让你能通过库所提供的功能而非名称与版本号来指定构建依赖；Spring Boot CLI将Spring Boot的无阻碍开发模型提升到了一个崭新的高度，在命令行里就能简单快速地用Groovy进行开发；Actuator让你能深入运行中的应用程序，了解Spring Boot做了什么，是怎么做的。","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"Java注解","slug":"Java注解","date":"2019-05-05T01:54:19.000Z","updated":"2019-05-05T02:58:38.480Z","comments":false,"path":"2019/05/05/Java注解/","link":"","permalink":"http://yangliuxiao.top/2019/05/05/Java注解/","excerpt":"","text":"整理自 《秒懂，Java 注解 （Annotation）你可以这样学》 — frank909 注解的定义 Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。 注解实际上如同标签，是对事物行为的某些角度的评价与解释。 一般不影响代码执行，但也有一些注解可以做到影响代码执行。 注解语法1. 注解定义注解通过@interface关键字进行定义。 1public @interface TestAnnotation &#123;&#125; 它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。 2. 注解的属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125; 上面代码定义了 TestAnnotation 这个注解中拥有 id和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。 赋值的方式是在注解的括号内以value=&quot;&quot;形式，多个属性之前用 ，隔开。 1234@TestAnnotation(id=3,msg=\"hello annotation\")public class Test &#123;&#125; 需要注意的是，在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组。 注解中属性可以有默认值，默认值需要用 default关键值指定。比如： 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; public int id() default -1; public String msg() default \"Hi\";&#125; 如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接接属性值填写到括号内。还需要注意的一种情况是一个注解没有任何属性,那么在应用这个注解的时候，括号都可以省略。 3. 注解的使用123@TestAnnotationpublic class Test &#123;&#125; 创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就表示用 TestAnnotation 注解这个类了。 要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，能够应用到其它的注解上面。 如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。 元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 @RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 @Documented顾名思义，这个元注解和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。 @Target@Target 指定了注解运用的地方。 你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。 类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。 @Target 有下面的取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解ElementType.CONSTRUCTOR 可以给构造方法进行注解ElementType.FIELD 可以给属性进行注解ElementType.LOCAL_VARIABLE 可以给局部变量进行注解ElementType.METHOD 可以给方法进行注解ElementType.PACKAGE 可以给一个包进行注解ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。(父类存在某个注解，该注解被@Inherited注解，那么子类没有注解的话，该子类继承父类的注解) 12345678910@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。 @Repeatable@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。 什么样的注解会多次应用呢？通常是注解的值可以同时取多个。 举个例子，一个人他的标签既是程序员又是产品经理,同时还是个画家。 12345678910111213141516171819/* 容器注解 */@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default \"\";&#125;@Person(role=\"artist\")@Person(role=\"coder\")@Person(role=\"PM\")public class SuperMan&#123;&#125; @Repeatable 注解了 Person。而 @Repeatable后面括号中的类相当于一个容器注解。 什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。 Java预置的注解@Deprecated 用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。 @Override提示子类要复写父类中被 @Override 修饰的方法 @SuppressWarnings 阻止警告的意思。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。 @SafeVarargs 参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。 注解的提取要想正确检阅注解，离不开一个手段，那就是反射。 注解与反射注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent()方法判断它是否应用了某个注解 1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125; 然后通过 getAnnotation()方法来获取 Annotation 对象。 1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 或者是getAnnotations()方法。 1public Annotation[] getAnnotations() &#123;&#125; 前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。 如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如 1234567891011121314151617@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println(\"id:\"+testAnnotation.id()); System.out.println(\"msg:\"+testAnnotation.msg()); &#125; &#125;&#125; 上面的例子中，只是检阅出了注解在类上的注解，其实属性、方法上的注解照样是可以的。同样还是要假手于反射。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@TestAnnotation(msg=\"hello\")public class Test &#123; @Check(value=\"hi\") int a; @Perform public void testMethod()&#123;&#125; @SuppressWarnings(\"deprecation\") public void test1()&#123; Hero hero = new Hero(); hero.say(); hero.speak(); &#125; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); //获取类的注解 System.out.println(\"id:\"+testAnnotation.id()); System.out.println(\"msg:\"+testAnnotation.msg()); &#125; try &#123; Field a = Test.class.getDeclaredField(\"a\"); a.setAccessible(true); //获取一个成员变量上的注解 Check check = a.getAnnotation(Check.class); if ( check != null ) &#123; System.out.println(\"check value:\"+check.value()); &#125; Method testMethod = Test.class.getDeclaredMethod(\"testMethod\"); if ( testMethod != null ) &#123; // 获取方法中的注解 Annotation[] ans = testMethod.getAnnotations(); for( int i = 0;i &lt; ans.length;i++) &#123; System.out.println(\"method testMethod annotation:\"+ans[i].annotationType().getSimpleName()); &#125; &#125; &#125; catch (NoSuchFieldException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; &#125;&#125; 需要注意的是，如果一个注解要在运行时被成功提取，那么 @Retention(RetentionPolicy.RUNTIME)是必须的。 注解的使用场景 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取 注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。","categories":[{"name":"Java技术","slug":"Java技术","permalink":"http://yangliuxiao.top/categories/Java技术/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"}],"keywords":[{"name":"Java技术","slug":"Java技术","permalink":"http://yangliuxiao.top/categories/Java技术/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2019-04-26T05:15:38.000Z","updated":"2019-05-05T00:50:15.322Z","comments":false,"path":"2019/04/26/SpringMVC/","link":"","permalink":"http://yangliuxiao.top/2019/04/26/SpringMVC/","excerpt":"","text":"转载自：《SpringMVC框架理解》 by 椰子Tyshawn JavaEE体系结构包括四层，从上到下分别是应用层、Web层、业务层、持久层。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。 为什么要使用SpringMVC？很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。 SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。 MVC设计模式MVC设计模式的任务是将包含业务数据的模块与显示模块的视图解耦。通过在模型和视图之间引入重定向层，这个重定向层就是控制器（control），控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。 SpringMVC架构SpringMVC是Spring框架的一部分，分属Web层，如下图。 SpringMVC的核心架构图如下。 具体流程说明： （1）首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制； （2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象； （3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理，即适配器设计模式的应用； （4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（一个键值对对象，包含模型数据、逻辑视图名）； （5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver，视图解析器将把逻辑视图名解析为具体的View； （6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构； （7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。 SpringMVC入门程序① web.xml 123456789101112131415161718192021222324&lt;web-app&gt; &lt;servlet&gt; &lt;!-- 加载前端控制器 --&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载配置文件 默认加载规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 修改加载路径： --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ② springmvc.xml springMVC配置文件 123456789101112131415161718192021222324&lt;beans&gt; &lt;!-- 配置映射处理器：根据bean(自定义Controller)的name属性的url去寻找handler；springmvc默认的映射处理器是 BeanNameUrlHandlerMapping --&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"&gt;&lt;/bean&gt; &lt;!-- 配置处理器适配器来执行Controlelr ,springmvc默认的是 SimpleControllerHandlerAdapter --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"&gt;&lt;/bean&gt; &lt;!-- 配置自定义Controller --&gt; &lt;bean id=\"myController\" name=\"/hello.do\" class=\"org.controller.MyController\"&gt;&lt;/bean&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑试图； 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsps/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ③ 自定义Controller 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(\"/mvc\")public class mvcController &#123; @Test @RequestMapping(\"/hello\") public String hello()&#123; System.out.println(\"111\"); return \"hello\"; &#125; @RequestMapping(\"/test1\") public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; ModelAndView mv = new ModelAndView(); /*设置页面回显数据*/ mv.addObject(\"hello\", \"欢迎学习springmvc\"); /*返回物理视图*/ /*mv.setViewName(\"/WEB-INF/jsps/index.jsp\");*/ /*返回逻辑视图*/ mv.setViewName(\"index\"); return mv; &#125;&#125; ④ index页面 12345&lt;html&gt;&lt;body&gt;&lt;h1&gt;$&#123;hello&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试地址：http://localhost:8080/springmvc/mvc/test1","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"数据结构进阶（一）","slug":"数据结构进阶（一）","date":"2019-04-23T02:43:37.000Z","updated":"2019-05-17T06:37:08.661Z","comments":false,"path":"2019/04/23/数据结构进阶（一）/","link":"","permalink":"http://yangliuxiao.top/2019/04/23/数据结构进阶（一）/","excerpt":"","text":"1. 二叉查找树参考：深入学习理解二叉搜索树（附详细讲解与实例分析） 1.1 基本概念二叉查找树，也称二叉搜索树，或二叉排序树。其要么是一颗空树，要么就是具有如下性质的二叉树： （1）若任意节点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值； （2）若任意节点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值； （3）任意节点的左、右子树也分别为二叉查找树； 1.2 基本操作对于一棵二叉搜索树来说，它支持许多动态集合操作，包括WALK（遍历）、SEARCH（查找）、MINIMUM（最小关键字）、MAXIMUM（最大关键字）、SUCCESSOR（后继）、PREDECESSOR（前驱）、INSERT（插入）、DELETE（删除）等。下面将依次讲解这些操作。 1.2.1 Walk（遍历）得益于二叉搜索树的性质，当使用中序遍历来访问一棵二叉搜索树上的所有结点时，最后得到的访问序列恰好是所有结点关键字的升序序列。 12345678910/* 中序遍历 */void inOrder_Tree_Walk(BSTNode x)&#123; if (x != NULL) &#123; inOrder_Tree_Walk(x.lchild); System.out.println(x.getKey()) inOrder_Tree_Walk(x.rchild); &#125;&#125; 树的先序遍历和后序遍历也类似。 1.2.2 Search（查找） 在二叉搜索树中查找一个具有给定关键字key的结点，需要输入一个指向树根的指针x和一个关键字k，如果这个结点存在，则TREE-SEARCH返回一个指向关键字为k的结点的指针；否则返回NULL。 具体查找过程为： ① 从树根开始查找，并沿着这棵树中的一条简单路径向下进行； ② 若树为空树，则查找失败，返回NULL； ③ 对于遇到的每个结点x，若关键字k等于结点x的关键字，查找终止，返回指向结点x的指针； ④ 若关键字k小于结点x的关键字，则查找在x的左子树中继续（根据二叉搜索树的性质，k此时不可能在右子树中）； ⑤ 对称地，若关键字k大于结点x的关键字，则查找在x的右子树中继续（k此时不可能在左子树中）； ⑥ 若查找至叶子结点后仍未匹配到相等的关键字，则关键字为k的结点不存在，返回NULL。 1234567891011121314/** * 查找（递归实现） * 输入：一个指向根节点的指针x，和待查找的关键字k * 输出：指向关键字为k的节点的指针（若存在，否则输出NULL） */BSTNode tree_Search(BSTNode x, double k)&#123; if (x == NULL || k == x.getKey()) /* 如果找不着就返回NULL，找到了则返回对应节点的指针 */ return x; if (k &lt; x.getKey()) /* 关键字小于当前节点的关键字，查找就在左子树中继续 */ return tree_Search(x.lchild, k); else /* 关键字大于当前节点的关键字，查找就在右子树中继续 */ return tree_Search(x.rchild, k);&#125; 或者不使用递归，采用迭代实现 12345678910111213141516/** * 查找（迭代实现） * 输入：一个指向根节点的指针x，和待查找的关键字k * 输出：指向关键字为k的节点的指针（若存在，否则输出NIL） */BSTNode iterative_Tree_Search(BSTNode x, double k)&#123; while (x != NULL &amp;&amp; k != x.getKey()) &#123; if (k &lt; x.getKey()) /* 关键字小于当前节点的关键字，查找就在左子树中继续 */ x = x.lchild; else /* 关键字大于当前节点的关键字，查找就在右子树中继续 */ x = x.rchild; &#125; return x; /* 如果找不着就返回NULL，找到了则返回对应节点的指针 */&#125; 二叉搜索树的查找的时间复杂度为O(h)，其中h为二叉搜索树的高度。 1.2.3 Minimum（最小关键字）根据二叉搜索树的性质，对于非叶子结点来说，其左子树的关键字总是不大于该结点的关键字。从一棵子树的树根开始，沿着lchild指针直到遇到一个NULL，我们总能在一棵二叉搜索树中找到一个指针，这个指针指向该子树中的最小元素。 查询二叉搜索树的最小关键字的时间复杂度为O(h)，其中h为二叉搜索树的高度。 1.2.4 Maximum（最大关键字）最大关键字的查询过程与最小关键字的十分类似。根据二叉搜索树的性质，对于非叶子结点来说，其右子树的关键字总是不小于该结点的关键字。从一棵子树的树根开始，沿着rchild指针直到遇到一个NULL，我们总能在一棵二叉搜索树中找到一个指针，这个指针指向该子树中的最大元素。 查询二叉搜索树的最大关键字的时间复杂度为O(h)，其中h为二叉搜索树的高度。 1.2.5 Successor（后继）给定一棵二叉搜索树中的一个结点，有时候需要按中序遍历的次序查找它的后继，即中序遍历顺序下的后面一位。一棵二叉搜索树的结构允许我们通过没有任何关键字的比较来确定一个结点的后继。如果后继存在，则返回指向结点x的后继的指针。倘若结点x的关键字是这棵树的最大关键字，则说明它没有后继了，返回NULL。 求后继的过程可以分以下两种情况讨论： ① 如果结点x的右子树非空，那么x的后继恰是x右子树中的最左结点（右子树中的最小关键字）； ② 如果结点x的右子树为空，则有以下两种可能： a. 结点x是其父结点的左孩子，则结点x的后继结点为它的父结点； b. 结点x是其父结点的右孩子，则结点x的后继结点为x的最底层祖先，同时满足“这个最底层祖先的左孩子也是结点x的祖先”的条件。 举个例子： 对于情况①，假设我们要求结点5的后继。因为结点5的右子树非空，所以5的后继就是它的右子树中的最小关键字，即为6。 对于情况②a，假设我们要求结点2的后继。因为结点2的右子树为空，且结点2是其父结点3的左孩子，所以2的后继就是它的父结点，即为3。 对于情况②b，假设我们要求结点4的后继。因为结点4的右子树为空，且结点4是其父结点3的右孩子。此时我们要找的后继是4的最底层祖先，而且这个最底层祖先的左孩子也是结点4的祖先之一。我们可以这样看，首先结点4的祖先有3、5；按理说最底层结点应该是3。但是我们需要注意，这个最底层是有前提条件的。前提条件就是这个祖先要有左孩子，并且这个左孩子也是结点4的祖先之一。在祖先3、5中，有左孩子的有3和5，但是结点3左孩子2并不是结点4的祖先之一；结点5的左孩子3正是结点4的另一个祖先。因此，符合前提条件的最底层祖先为5。所以4的后继就是5。 1.2.6 Predecessor（前驱）给定一棵二叉搜索树中的一个结点查找它的前驱的情况跟求后继的情况是对称的。一棵二叉搜索树的结构也允许我们通过没有任何关键字的比较来确定一个结点的前驱。如果前驱存在，则返回指向结点x的前驱的指针。倘若结点x的关键字是这棵树的最小关键字，则说明它没有前驱了，返回NULL。 求前驱的过程同样可以分以下两种情况讨论： ① 如果结点x的左子树非空，那么x的前驱恰是x左子树中的最右结点（左子树中的最大关键字）； ② 如果结点x的左子树为空，则有以下两种可能： a. 结点x是其父结点的右孩子，则结点x的前驱结点为它的父结点；b. 结点x是其父结点的左孩子，则结点x的前驱结点为x的最底层祖先，同时满足“这个最底层祖先的右孩子也是结点x的祖先”的条件。 举个例子： 对于情况①，假设我们要求结点5的前驱。因为结点5的左子树非空，所以5的前驱就是它的左子树中的最大关键字，即为4。 对于情况②a，假设我们要求结点7的前驱。因为结点7的左子树为空，且结点4是其父结点3的右孩子，所以4的前驱就是它的父结点，即为3。 对于情况②b，假设我们要求结点6的前驱。因为结点6的左子树为空，且结点6是其父结点7的左孩子。此时我们要找的前驱是6的最底层祖先，而且这个最底层祖先的右孩子也是结点6的祖先之一。 我们可以这样看，首先结点6的祖先有7、5,；按理说最底层结点应该是7。但是我们需要注意，这个最底层是有前提条件的。前提条件就是这个祖先要有右孩子，并且这个右孩子也是结点17的祖先之一。在祖先7、5中，结点5的右孩子7正是结点6的另一个祖先。因此，符合前提条件的最底层祖先为5。所以6的前驱就是5。 1.2.7 Insert（插入）插入操作会引起由二叉搜索树表示的动态集合的变化。我们需要修改数据结构来反映这个变化，但要保证修改后二叉搜索树的性质不被破坏。插入的过程首先从树根开始遍历，沿树向下移动。指针x记录了一条向下的简单路径，并查找要替换的输入项z的NIL。同时，保持遍历指针y指向x的双亲。两个指针沿树向下移动时，通过比较当前结点x的关键字与待插入结点z的关键字大小，来决定向左或向右移动。直到x指向NIL时，这个NIL占据的位置就是输入项z要放置的位置。前面我们提到在x移动过程中还需要保持y指向x的父结点，原因是当我们找到可插入的NIL位置时，我们需要知道z属于哪个结点。 1.2.8 Delete（删除）相对于插入操作，删除操作会更加复杂一些。从一棵二叉搜索树中删除某个特定结点z可以分为以下三种情况，其中前两种情况较为简单，最后一种情况则复杂一点。 ① 如果z没有孩子结点，那么只是简单地将它删除，并修改它的父结点，用NIL作为孩子来替换z； ② 如果z只有一个孩子，那么将这个孩子提升到树中z的位置上，并修改z的父结点，用z的孩子来替换z； ③ 如果z有两个孩子，那么找z的后继y，并让y占据树中z的位置。z的原来右子树部分成为y的新的右子树，z的原来左子树部分成为y新的左子树。这里要注意，z的后继y一定在z的右子树中，并且没有左孩子（详情见上文2.7前的证明）。利用z的后继y替换z，又细分为以下两种情况： a. 如果y是z的右孩子，那么直接用y替换z，并保留y的右子树（y没有左子树）； b. 如果y不是z的右孩子，那么先用y的右孩子替换y（y没有左孩子），然后再用y替换z。 2. AVL树（二叉平衡树）2.1 AVL树概述参考：AVL树(一)之 图文解析 和 C语言的实现 AVL树是根据它的发明者G.M.Adelson-Velsky和E.M.Landis命名的。 上面介绍的二叉查找树在不断插入的情况下，有可能出现一侧不断生长，最后退化成线性结构的情形，查找插入等操作的效率就会退化为线性查找的效率。 而AVL树是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于”二叉查找树”，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。 如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的旋转算法。 树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)。 2.2 AVL树失去平衡的四种情况如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种失去平衡的可以概括为4种姿态：LL(左左)，LR(左右)，RR(右右)和RL(右左)。 ① LL：LeftLeft，也称为”左左”。插入或删除一个节点后，根节点的左子树的左子树还有非空子节点，导致”根的左子树的高度”比”根的右子树的高度”大2，导致AVL树失去了平衡。 例如，在上面LL情况中，由于”根节点(8)的左子树(4)的左子树(2)还有非空子节点”，而”根节点(8)的右子树(12)没有子节点”；导致”根节点(8)的左子树(4)高度”比”根节点(8)的右子树(12)”高2。 ② LR：LeftRight，也称为”左右”。插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致”根的左子树的高度”比”根的右子树的高度”大2，导致AVL树失去了平衡。 例如，在上面LR情况中，由于”根节点(8)的左子树(4)的左子树(6)还有非空子节点”，而”根节点(8)的右子树(12)没有子节点”；导致”根节点(8)的左子树(4)高度”比”根节点(8)的右子树(12)”高2。 ③ RL：RightLeft，称为”右左”。插入或删除一个节点后，根节点的右子树的左子树还有非空子节点，导致”根的右子树的高度”比”根的左子树的高度”大2，导致AVL树失去了平衡。 例如，在上面RL情况中，由于”根节点(8)的右子树(12)的左子树(10)还有非空子节点”，而”根节点(8)的左子树(4)没有子节点”；导致”根节点(8)的右子树(12)高度”比”根节点(8)的左子树(4)”高2。 (4)RR：RightRight，称为”右右”。插入或删除一个节点后，根节点的右子树的右子树还有非空子节点，导致”根的右子树的高度”比”根的左子树的高度”大2，导致AVL树失去了平衡。 例如，在上面RR情况中，由于”根节点(8)的右子树(12)的右子树(14)还有非空子节点”，而”根节点(8)的左子树(4)没有子节点”；导致”根节点(8)的右子树(12)高度”比”根节点(8)的左子树(4)”高2。 2.3 AVL树的旋转2.3.1 LL的旋转 图中左边是旋转之前的树，右边是旋转之后的树。从中可以发现，旋转之后的树又变成了AVL树，而且该旋转只需要一次即可完成。 k2结点不一定是整棵AVL树的根结点，而是开始失去平衡的那个根结点，至于k1则是高度过高的那棵子树的根结点。将k1变成根节点，k2变成k1的右子树，”k1的右子树”变成”k2的左子树”。 2.3.2 RR的旋转 图中左边是旋转之前的树，右边是旋转之后的树。RR旋转也只需要一次即可完成。 RR旋转操作即LL旋转的镜像操作。 2.3.3 LR的旋转 LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡。第一次旋转是围绕”k1”进行的”RR旋转”，第二次是围绕”k3”进行的”LL旋转”。 2.3.4 RL的旋转 RL是LR的镜像操作。第一次旋转是围绕”k3”进行的”LL旋转”，第二次是围绕”k1”进行的”RR旋转”。 3. B树、B+树和B*树3.1 B树3.1.1 概述在现代计算机中通常采用分级存储系统,以最简单的二级分级存储策略为例,就是由内存储器与外存储器(磁盘)组成二级存储系统.这一策略的思想是：将最常用的数据副本存放于内存中,而大量的数据存放于外存中,借助有效的算法可以将外存的大存储量与内存高速度的优点结合起来。 一般的,在分级存储系统中,各级存储器的速度有着巨大的差异,仍然以磁盘和内存为 例,前者的平均访问速度为 10ms左右,而内存储器的平均访问时间为ns级,通常在 10~100ns 左右,二者之间差异大约为 10的6次方.因此,为了节省一次外存储器的访问,我们宁愿多访问内存储器一百次,一千次甚至一万次. 当问题规模太大时,以至于内存储器无法容纳时,即使是前面介绍的 AVL 树,在时间上也会大打折扣。 B树是对二叉查找树的改进。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树为系统最优化大块数据的读和写操作。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。 假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘，相对于平衡二叉树，查询比较的次数可能没有减少，但是磁盘IO次数会大大减少。 3.1.2 B树的结构所谓 m 阶B-树或为空树，或为满足下列特性的 m叉树： ① 树中每个结点至多有 m 棵子树； ② 若根结点不是叶子结点,则至少有两棵子树； ③ 除根结点之外的所有非终端结点至少有 ⎡m/2⎤ 棵子树； ④ 所有的非终端结点的结构为：(n , A0 , K1 , A1 , K2 , … , Kn , An) 其中： Ki(i=1,2,…,n)为关键字,且Ki&lt;Ki+1,Ai为指向子树根结点的指针(i=0,1,…,n), 且指针A(i-1)所指子树中所有结点的关键字均小于Ki (i=1,2,…,n),An所指子树中所有结点的关键字均大于Kn，n为关键码的个数，⎡m/2⎤ −1≤ n ≤ m −1； ⑤ 所有的叶子结点都出现在同一层次上,并且不带信息(可以看作是外部结点或查找 失败的结点,实际上这些结点不存在,指向这些结点的指针为空)； 3.1.3 B树的查找操作B-树的查找类似二叉排序树的查找,所不同的是B-树每个结点上是多关键码的有序表, 在到达某个结点时,先在有序表中查找,若找到,则查找成功；否则,到按照对应的指针信 息指向的子树中去查找,当到达叶子结点时,则说明树中没有对应的关键码,查找失败.即在 B-树上的查找过程是一个顺指针查找结点和在结点中查找关键码交叉进行的过程. 正如前面所指出的,B-树的查找适合于大规模的数据.实际的做法是将大量数据组织为一棵 B-树,并存于外存储器,B-树的根结点常驻内存.一旦需要查找,则按照上述过程, 首先将根结点作为当前结点,在当前结点中顺序查找；如果当前结点不存在需要查找的关键 字,则根据相应的引用,找到外存中的某一个下层结点,将其读入内存,作为新的当前结点继续查找.如此进行下去,直到找到相应关键字或查找失败. 由此可见,在B-树中进行查找所需的时间,无外乎两类操作的时间消耗：一种是在 B-树上找结点,即将外存中的结点读入内存；另一种是,在结点中找关键字.在前面曾经提 到,内外存储器的平均访问时间存在巨大的差异,所以在这两部分时间中,前者必然是主要部分,后一部分时间则可以忽略.因此,B-树的查找效率取决于外存的访问次数. 由推导可知，对于具有N个关键字的m阶B-树的每次查找操作,都可以在Ο(logm N)时间内完成. 3.1.4 B树的插入操作为了在 m 阶B-树中插入一个新关键字 key,首先要找到该关键字应该插入的位置,该过程实际是在B-树中查找关键字的过程.倘若查找成功,则不再插入重复的关键字,若查找不成功,则在此查找过程中遇到的最后一个非叶子结点p,即为关键字 key 的插入位置.然后,在结点 p 中,按照关键字有序的顺序将 key 插入.若插入后结点 p 上关键字个数不超过 m−1个,则可直接插入到该结点上；否则,要进行调整,即结点的“分裂”. 分裂操作按如下规则进行： ① 假设结点 p 中已有 m-1 个关键字,当插入一个关键字之后,结点中包含的信息为：(m , A0 , K1 , A1 , K2 , … , Km , Am) ② 此时,可以将结点 p 分裂为两个结点 u和v,其中结点 u 包含的信息为 (⎡m/2⎤ −1 , A0 , K1 , A1 , … , K⎡m/2⎤ −1 , A⎡m/2⎤ −1)结点 v 中包含的信息为(m− ⎡m/2⎤ , A⎡m/2⎤ , K⎡m/2⎤+1 , A⎡m/2⎤+1 , … , Km , Am) ③ 而关键字K⎡m/2⎤则插入到p的父结点中去.如果p的父结点不存在（已经到根结点）,则新建一个只包含关键字 K⎡m/2⎤的结点； ④ 如果p的父结点关键字个数由于关键字K⎡m/2⎤的插入而超过m−1,则分裂过程继续下去,直到p的某个祖先结点g,在插入关键字后g的关键字个数不超过m−1. ◆ 举例如下所示5阶B-树： ① 插入7 ② 插入 3 ③ 插入 38 3.1.5 B树的删除操作与插入关键字相反,若在 B-树上删除一个关键字,则首先应该找到该关键字所在的结点u,并从中删除。B-树的删除操作可以分为以下三种情况： 一、若待删关键字所在结点并非最下层的非终端结点 假设待删关键字为Ki,此时,可以用Ai所指子树中的最小关键字X替代,然后问题转换成了删除关键字X，若关键字X仍不是最下层的非终端结点，则继续向下，直到问题转换为删除最下层结点。 二、 若该结点 u 为最下层的非终端结点,且其中关键字的数目不少于 ⎡m/2⎤ 直接删除即可。 三、 若该结点 u 为最下层的非终端结点,且其中关键字的数目少于 ⎡m/2⎤（即关键字数目为⎡m/2⎤-1） 在u中删除关键字后需要进行“合并”结点的操作。 “合并”操作可以分成以下三种情况分别进行处理： ① 结点 u 的左兄弟 v 包含至少 ⎡m/2⎤ 个关键字 如下图所示,可以从结点v中取出最大的关键字kmax,将u的父结点p中介于v 和u之间的关键字kmid替换为kmax,然后将kmid插至u的最左侧.（即从结点u中删除一个关键字之后，从左兄弟取出最右关键字放入父节点，将父节点关键字放入结点u） ② 结点 u 的右兄弟 v 包含至少 ⎡m/2⎤ 个关键字 与第一种情况类似，如下图所示,可以从结点v中取出最小的关键字kmin,将u的父结点p中介于v 和u之间的关键字kmid替换为kmin,然后将kmid插至u的最右侧. ③ 结点 u 没有一个兄弟包含至少 ⎡m/2⎤ 个关键字 此时,结点u和其相邻的兄弟结点中的关键字数目均等于 ⎡m/2⎤ −1,但是结点u至少会有一个兄弟结点.如下图所示,设u有右兄弟v,这时可以取出父结点p中介于u,v之间 的关键字kmid,然后将kmid与u,v中关键字合并为一个结点. 综合以上三种情况,在“合并”结点之后,结点 u 的父结点中关键字有可能会减少,若“合并”操作之后，父结点关键字数目小于 ⎡m/2⎤ −1,则需要对父结点进行修复（即对父节点进行以上的合并操作）,该过程一直进行下去,直到 u 的某个祖先结点 g,g 的关键字数目不少于 ⎡m/2⎤ −1,或直到根结点为止. 3.2 B+树B+树是B-树的变体，也是一种多路搜索树，其定义基本与B树相同，除了： ① 非叶子结点的子树指针与关键字个数相同； ② 非叶子结点的子树指针P[i]，指向关键字值属于(K[i], K[i+1])的子树（B-树是开区间）； ③ 为所有叶子结点增加一个链指针； ④ 所有关键字都在叶子结点出现；","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yangliuxiao.top/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yangliuxiao.top/categories/数据结构/"}]},{"title":"数据结构整理","slug":"数据结构整理","date":"2019-04-20T01:23:43.000Z","updated":"2019-05-16T07:23:02.251Z","comments":false,"path":"2019/04/20/数据结构整理/","link":"","permalink":"http://yangliuxiao.top/2019/04/20/数据结构整理/","excerpt":"","text":"1.线性表线性结构是最简单，也是最常用的数据结构之一。特点是：在数据元素的有限集中，除第一个元素无直接前驱，最后一个元素无直接后续以外，每个数据元素有且仅有一个直接前驱元素和一个直接后续元素。 线性表的抽象数据类型基本操作： getSize() isEmpty() insert(i,e) contains(e) get(i) remove(e) 获取大小 是否为空 插入 是否包含元素e 获取序号为i的元素 删除e 1.1 线性表的顺序存储与实现线性表的顺序存储是用一组地址连续的存储单元依次存储线性表的数据元素。以数据元素在机内存储地址相邻来表示线性表中数据元素之间的逻辑关系。 优点是只要确定了线性表的起始地址，线性表中任意元素都可以做到随机存取。缺点是插入或删除元素时，需要移动后续元素，增加了开销。 在抽象数据类型的实现中都是使用数组来描述数据结构的顺序存储结构。 1.2 线性表的链式存储与实现实现线性表的另一方法是链式存储，即用指针将存储线性表中数据元素的那些单元依次串联在一起。 这种方法弥补了数组中连续存储的缺点，在插入或删除元素时，不再需要移动元素。但需要在每个单元设置指针，增加了额外的存储开销，并且在查找元素时需要从头指针开始查询，无法做到随机存取。 链表又可以分为单链表与双向链表： ①单链表：有一个存储数据元素的数据域，一个指向下一个元素地址的指针域（Java中没有显式的指针类型，是使用对象引用来实现的）。 1234567&gt; public class SLNode&#123;&gt; /*数据域*/&gt; private Object e;&gt; /*下一个元素的引用*/&gt; private SLNode next;&gt; &#125;&gt; 优点：结构简单。 缺点：只能通过引用访问后续节点，而无法直接访问其前驱节点。 ②双向链表：扩展单链表，增加一个指针域存放其前驱节点的地址。 123456&gt; public class DLNode &#123;&gt; private Object e;&gt; private DLNode pre;&gt; private DLNode next;&gt; &#125;&gt; 优点：可以直接找点节点的前驱。 缺点：增加了一个指针域，增加了存储开销。并且插入、删除元素时更加繁琐。 1.3 两种实现方式的比较从时间上进行比较 在查找操作上，若基于序号，顺序存储有随机存取的特性，而链式存储需要从头结点遍历；若基于内容，则两者都需要从头遍历 而在插入和删除操作上，顺序存储需要移动大量数据元素；而链表只需修改几个指针。 从空间上进行比较 顺序存储的存储空间是预先静态分配的，虽然在实现过程中可以动态扩展，但若长度变化较大，会存在较大的空闲空间，空间利用率低；而链式存储空间是动态分配的。 当线性表的数据元素简单，并且线性表的长度变化不大时，链式存储需要额外的指针域空间，所以可以选择顺序存储。 2.栈与队列2.1 栈栈（stack）又称堆栈，是一种运算受限的线性表，其限制是仅表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除等操作。表中进行插入删除操作的一端称为栈顶（top），栈顶保存的元素称为栈顶元素。相对地另一端称为栈底（bottom）。又把堆栈称为后进先出表（LIFO）。 和线性表类似，堆栈也有两种基本的存储结构：顺序存储结构和链式存储结构。 递归（recursion）是指在定义自身的同时又出现了对自己的引用。如果一个算法直接或间接地调用自己，则称这个算法是一个递归算法，由两部分组成：递归终止条件和递归调用。 函数调用期间的相关信息的保存需要使用一个堆栈来实现。系统将整个程序运行时需要的数据空间安排在一个堆栈中，每当调用一个函数时就为它在栈顶分配一个存储区，每当一个函数返回时就释放它的存储区。一个递归算法的实现实际上就是多个相同函数的嵌套调用。 2.2 队列队列（queue）简称队，他同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。插入数据的一端称为队尾（rear），删除数据元素的一端称为队首（front）。队列又称为先进先出表（FIFO）。 和线性表类似，队列也有两种基本的存储结构：顺序存储结构和链式存储结构。 单元围成一个圆环的队列即为循环队列。 3. 树树是一种非线性结构，数据元素之间的逻辑关系是前驱唯一而后续不唯一的，即数据元素之间是一对多的关系。 3.0 树的性质◆ 结点的层次和树的深度树的结点包含一个数据元素及若干指向其子树的若干分支。 结点的层次从根结点开始定义，层次数为0的结点是根结点。根节点的子树的根的层次数为1。 结点的最大层次数称为树的深度或高度。树中结点也有高度，其高度是以该结点为根的树的高度。 ◆ 结点的度与树的度结点拥有的子树的数目称为称为结点的度（Degree），度为0的结点称为叶子（Leaf）。 ◆ 树的边数树中的结点数等于树的边数加1，也等于所有结点的度数之和加1。因为除了根结点以外每个结点都与指向它的一条边对应。在对涉及树结构的算法复杂性进行分析时，可以用结点的数目作为规模的度量。 ◆ 有序树、m叉树、森林有序树：将树中结点的各子树看成是从左至右有次序的，则称该树为有序树；若不考虑子树的顺序则成为无序树。对于有序树，我们可以明确地定义每个结点的第一个孩子、第二个孩子等。 m叉树：树中所有结点最大度数为m的有序树。 森林（forest）：是m(m&gt;=0)棵互不相交的树的集合。 3.1 二叉树◆ 性质① 在二叉树的第i层上最多有2^i个结点。 ② 高度为h的二叉树至多有2^{h+1}-1个结点。 ③ 对任何一棵二叉树T，如果其叶子结点数为n0，度为2的结点数为n2，则n0 =n2 + 1。 ◆ 满二叉树高度为K并且有2^{k+1}-1个结点的二叉树。在满二叉树中，每层结点都达到最大数，即每层结点都是满的，因此称为满二叉树。 ◆ 完全二叉树若在一棵满二叉树中，在最下层从最右侧起去掉相邻的若干叶子结点，得到的二叉树即为完全二叉树。 可见，满二叉树必为完全二叉树，但完全二叉树不一定为满二叉树。 由完全二叉树的定义可以得到： ① 有n个结点的完全二叉树的高度为（log n的向下取整） ② 含有n &gt;= 1个结点的二叉树的高度至多为n - 1；高度至少为（log n的向下取整） ③ 如果对一棵有n个结点的完全二叉树的结点进行编号，则对任一结点i（ 1 &lt;= i &lt;= n），有 (1) 如果 i = 1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲结点Pi是（ i / 2 向下取整） 。 (2) 如果2i &gt; n，则结点i无左孩子；否则其左孩子是结点2i。 (3) 如果2i + 1 &gt; n，则结点i无右孩子；否则其右孩子是结点2i + 1。 3.2 二叉树的存储结构◆ 顺序存储结构对于满二叉树和完全二叉树来说，可以将其数据元素逐层存放到一组连续的存储单元中。 这种方式对于满二叉树和完全二叉树是非常合适也是高效方便的。因为满二叉树和完全二叉树采用顺序存储结构既不浪费空间，也可以根据公式很快地确定节点之间的关系。但对于一般的二叉树而言，必须用“虚节点”将一棵二叉树补成完全二叉树来存储，会造成空间浪费。 ◆ 链式存储结构设计不同的结点结构可构成不同的链式存储结构。至少应包含三个域：数据域、左孩子域、右孩子域，为了方便找到父节点，可以增加一个指向父节点的指针域。 3.3 树的存储结构◆ 双亲表示法每个结点中有一个指向其父亲结点的数组下标的域。 找一个结点的父亲结点只需O(1)，但找儿子结点或者兄弟结点可能要遍历整个数组。 ◆ 孩子链表表示法用一个线性表来存储树的所有结点信息，称为结点表。对每个结点建立一个孩子表。孩子表中只存储孩子结点的地址信息，可以是指针，数组下标甚至内存地址。由于每个结点的孩子数目不定，因此孩子表常用单链表来实现。 在孩子链表表示法中，通过某个结点找到其孩子较为容易，遍历其孩子链表即可，但找其父节点麻烦。因此可以结合孩子链表表示法和双亲表示法，在每个结点再设置一个指示双亲结点的域。 ◆ 孩子兄弟表示法树的孩子兄弟表示法又称为二叉树表示法。每个结点除了data域外，还含有两个指针域，分别指向该结点的第一个孩子和右邻兄弟。 3.4 Huffman树在计算机系统中，符号需要进行二进制编码。而为了缩短数据编码长度，可以采用不定长编码。其基本思想是：给使用频度较高的字符编较短的编码，这是数据压缩的最基本思想。 前缀码：在一个编码系统中，任何一个编码都不是其他编码的前缀，则称该编码系统的编码是前缀码。当一个编码系统中采用定长编码时，可以不用分隔符；如果采用不定长编码，必须使用前缀码或分隔符，否则会在解码时产生歧义。而使用分隔符就又增加了编码长度，所以一般采用前缀编码。 Huffman树：它是由n个带权叶子结点构成的所有二叉树中带权路径长度最小的二叉树，Huffman树又称最优二叉树。 构造Huffman树的算法步骤如下： ① 根据给定的n个权值，构造n棵只有一个根节点的二叉树，n个权值分别是这些二叉树根节点的权，F是由这n棵二叉树构成的集合。 ② 在F中选取两棵根节点树值最小的树作为左、右子树，构造一棵新的二叉树，置新二叉树根的权值 = 左右子树根节点权值之和。 ③ 从F中删除这两棵树，并将新树加入F。 ④ 重复②、③，直到F中只含一棵树为止。 4. 图图（graph）是一种网状数据结构，是由非空的顶点集合和一个描述顶点之间关系的集合组成。 4.1 图及基本术语简单图： 对简单图而言，图中中所有的边自然构成一个集合,并且每条边的两个顶点均不相同. 顶点的度、入度、出度： 顶点的度(degree)是指依附于某顶点 v 的边数,通常记为 TD (v).顶点 v 的入度(in degree)是指以顶点 为终点的边的数目,记为 ID (v)；顶点 v 出度(out degree)是指以顶点 v 为起始点的边的 数目,记为 OD (v). 完全图、稠密图、稀疏图 假设在图 G = ( V , E )中有 n 个顶点和 m 条边. 1) 若 G 是无向图,则有 0 ≤ m ≤ n(n-1)/2. 2) 若 G 是有向图,则有 0 ≤ m ≤ n(n-1). 由此,在具有n个顶点的图中,边的数目为Ο(n2).有n(n-1)/2 条边的无向图称为无向完全图；有 n(n-1)条边的有向图称为有向完全图.有 很少边(如 m &lt; n log n)的图称为稀疏图,反之边较多的图称为稠密图. 路径、环路及可达分量 所谓图中的一条通路或路径(path),就是由m+1 个顶点与m条边交替构成的一个序列ρ = { v0, e1 , v1 , e2 , v2 , … , em , vm},m ≥ 0,且ei = (vi-1 , vi),1 ≤ i ≤ m.路径上边的数目称为路径长度,计作|ρ|. 长度|ρ| ≥ 1 的路径,若路径的第一个顶点与最后一个顶点相同,则称之为环路或环 (cycle). 在有向图 G 中,若从顶点 s 到顶点 v 有一条通路,则称 v 是从 s 可达的.对于顶点 s, 从 s 可达的所有顶点所组成的集合,称作 s 在 G 中对应的可达分量. 连通性与连通分量 在无向图中,如果从一个顶点vi到另一个顶点vj(i≠j)有路径,则称顶点vi和vj是连通的. 如果图中任意两顶点vi,vj∈V,vi和vj都是连通的,则称该图是连通图(connected graph). 所谓连通分量(connected component),是指无向图的极大连通子图.显然任何连通图的连通分量只有一个,即本身.而非连通图有多个连通分量,各个连通分量之间是分离的, 没有任何边相连. 在有向图中,若图中任意一对顶点vi和vj (i≠j)均有一条从顶点vi到另一个顶点vj的路径, 也有从vj到vi的路径,则称该有向图是强连通图.有向图的极大强连通子图称为强连通分量. 权与网 在实际应用中,图不但需要表示元素之间是否存在某种关系,而且图的边往往与具有一 定实际意义的数有关,即每条边都有与它相关的实数,称为权.这些权值可以表示从一个顶点到另一个顶点的距离或消耗等信息,在本章中假设边的权均为正数.这种边上具有权值的图称为带权图(weighted graph)或网(network). 4.2 图的存储方法4.2.1 邻接矩阵图的邻接矩阵(adjacent matrix)表示法是使用数组来存储图结构的方法,也被称为数组表示法.它采用两个数组来表示图：一个是用于存储所有顶点信息的一维数组,另一个是 用于存储图中顶点之间关联关系的二维数组,这个关联关系数组也被称为邻接矩阵. 假设图G＝(V , E)有n个顶点,即V＝{v0,v1,…,vn-1},则表示G中各顶点关联关系的为一个n×n的矩阵A,若&lt; u,v &gt;之间存在直接连线，那么对应矩阵元素为1，否则为∞. 邻接矩阵存储存在以下特点： ① 首先,无向图的邻接矩阵一定是一个对称矩阵.因此,在具体存放邻接矩阵时只需存放上(或下)三角矩阵的元素即可. ② 其次,对于无向图, 邻接矩阵的第i行(或第i列)非∞元素的个数正好是第i个顶点的度TD(vi). ③ 再次,对于有向 图,邻接矩阵的第i行(第i列)非∞元素的个数正好是第i个顶点的出度OD(vi)(入度ID(vi)). ④ 最后,通过邻接矩阵很容易确定图中任意两个顶点之间是否有边相连；但是,要确定图中有多少条边,则必须按行,按列对每个元素进行检测,所花费的时间代价很大. 邻接矩阵存储的缺点： ① 尽管由n个顶点构成的图中最多可以有n的2次方条边,但是在大多数情况下,边的数目远远达不到这个量级,因此,在邻接矩阵中大多数单元 都是闲置的.空间利用率较低。 ② 矩阵结构是静态的,其大小N需要预先估计,然后创建N×N的矩阵.然而,图的规模往往是动态变化的,N的估计过大会造成更多的空间浪费,如果估计过小则经 常会出现空间不够用的情况. 4.2.2 邻接表邻接表(adjacency list)是图的一种链式存储方法,邻接表表示法类似于树的孩子链表表示法.在邻接表中对于图G中的每个顶点vi建立一个单链表,将所有邻接于vi的顶点vj链成 一个单链表,并在表头附设一个表头结点,这个单链表就称为顶点vi的邻接表. 在邻接表中共有两种结点结构,分别是边表结点和表头结点.每个边表结点由 3 个域组成,其中邻接点域(adjvex)指示与顶点vi邻接的顶点在图中的位置, 链域(nextedge)指向下一条边所在的结点,数据域(info)存储和边有关的信息,如权值等信息.在头结点中,除了设有链域(firstedge)指向链表中的第 一个结点之外,还有用于存储顶点vi相关信息的数据域(data). 就存储空间而言,对于 n 个顶点,m 条边的无向图,若采用邻接表作为存储结构,则需 要 n 个表头结点和 2m 个边表结点.显然在边稀疏(m&lt;&lt;n(n-1)/2)的情况下,用邻接表存储 要比使用邻接矩阵节省空间. 4.3 最小生成树我们看到对于连通图而言从图中不同顶点出发或从同一顶点 出发按照不同的优先搜索过程可以得到不同的生成树.如此,对于一个连通网(连通带权图)来说,生成树不同,每棵树的代价(树中每条边 上权值之和)也可能不同,我们把代价最小的生成树称为图的最小生成树(minimum spanning tree). 4.3.1 Prim算法从某个点开始，找到不在树集合但与树集合相连的最短权值的点，将其加入树集合，重复这一步，直到整个图所有点都加入树集合。 4.3.2 Kruskal算法（克鲁斯卡尔算法）找到权值最小，且两边端点至少有一个不在树集合内，不断找最小权值的边，直到所有点都加入树集合。 4.4 单源最短路径4.4.1 Dijkstra算法参考博客：深入理解 Dijkstra 算法实现原理 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 这样一个有权图，Dijkstra算法可以计算任意节点到其他节点的最短路径. 算法思路： ① 指定一个节点，例如我们要计算 ‘A’ 到其他节点的最短路径 ② 引入两个集合（S、U），S集合包含已求出的最短路径的点（以及相应的最短长度），U集合包含未求出最短路径的点（以及A到该点的路径，注意 如上图所示，A-&gt;C由于没有直接相连 初始时为∞） ③ 初始化两个集合，S集合初始时 只有当前要计算的节点，A-&gt;A = 0， U集合初始时为A-&gt;B = 4, A-&gt;C = ∞, A-&gt;D = 2, A-&gt;E = ∞. ④ 从U集合中找出路径最短的点，加入S集合，例如A-&gt;D = 2 ⑤ 更新U集合路径，若( &#39;D 到 B,C,E 的距离&#39; + &#39;AD 距离&#39; &lt; &#39;A 到 B,C,E 的距离&#39; )则更新U ⑥ 循环执行 4、5 两步骤，直至遍历结束，得到A 到其他节点的最短路径","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yangliuxiao.top/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yangliuxiao.top/categories/数据结构/"}]},{"title":"Python爬虫入门","slug":"Python爬虫入门","date":"2019-04-12T08:32:22.000Z","updated":"2019-04-24T00:22:36.311Z","comments":false,"path":"2019/04/12/Python爬虫入门/","link":"","permalink":"http://yangliuxiao.top/2019/04/12/Python爬虫入门/","excerpt":"","text":"1.网站调查在爬取某个目标网站之前，先对目标网站进行初步的调查，以确定后续的爬虫策略。 ①robots.txt文件Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 文件写法： User-agent: 这里的\\代表的所有的搜索引擎种类，*是一个通配符 Disallow: /admin/ 禁止爬寻admin目录下面的目录 Disallow: /require/ 禁止爬寻require目录下面的目录 Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以”.htm”为后缀的URL(包含子目录) Disallow: /? 禁止访问网站中所有包含问号 (?) 的网址 Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片 Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 Allow: /cgi-bin/ 允许爬寻cgi-bin目录下面的目录 Allow: /tmp 允许爬寻tmp的整个目录 Allow: .htm$ 仅允许访问以”.htm”为后缀的URL。 Allow: .gif$ 允许抓取网页和gif格式图片 Sitemap: 网站地图 一般包含多个文本段，每一个文本段设置一个用户代理（User-agent），然后紧跟着的Disallow和Allow字段表示这个用户代理的允许范围。 比如百度的robots.txt文件 ②Sitemap网站地图文件网站提供的Sitemap文件可以帮助爬虫定位网站最新的内容，而无须爬取每一个网页。但该文件经常存在缺失、过期或不完整的问题。 比如可以看到CSDN网站的robots.txt中的sitemap文件是单独放在一个文件中的。 ③估算网站大小网站的大小会影响我们选取爬取网站的方式，若是小一些的网站，比如只有几百上千的网页URL的网站，则无需考虑并行，直接串行下载就可以了，假如是几百万个网页URL的网站，则必须考虑并行爬虫。 可以使用site: + 目标网站URL的方式在百度或者谷歌等搜索引擎查询结果。因为这些搜索引擎很可能已经爬取过我们感兴趣的网站。 ④查看网站所用的技术Python有一个可以检查网站构建技术类型的工具模块——buildwith模块 安装方法直接在终端 pip install buildwith即可 123&gt;&gt;&gt; import builtwith &gt;&gt;&gt; tech_used = builtwith.parse('http://www.baidu.com') &#123;'javascript-frameworks': ['jQuery']&#125; 可以看到百度主页使用了jQuery。 2.网页下载使用Python的urllib2模块进行网页下载 123import urllib2def download(url): return urllib2.urlopen(url).read() 这里要注意网页数据的格式，如果是utf-8的则需要解析成utf-8格式。 urllib2.urlopen(url).read().decode(&#39;utf-8&#39;) 是GBK格式的也同样。 ①下载失败处理下载网页时，总会遇到一些无法控制的错误，比如请求的网页不存在等，所以这里需要异常处理。 12345try: html = urllib2.urlopen(url).read()except urllib2.URLError as e: print 'Download error:', e.reason html = None ②失败重试请求失败时，会给出错误信息urllib2.URLError as e:，可以检查错误信息e中是否有响应状态码字段code hasattr(e,&#39;code&#39;) 若存在http响应状态码，并且状态码为5xx（即代表服务器错误），则可以尝试多次重复下载，设置最大重复次数。也许在重复下载中，服务器错误已经修复，比如503服务器过载。 ③设置用户代理默认情况下，urllib2模块下载网页发送请求时，会使用Python-urllib/2.7 作为用户代理。我们可以自己设定用户代理，将其放入封装的request中。 1234567headers = &#123;'User-agent': user_agent&#125;request = urllib2.Request(url,headers=headers)try: html = urllib2.urlopen(request).read()except urllib2.URLError as e: print 'Download error:', e.reason html = None ④链接跟踪1.通过网站地图跟踪链接网站提供的Sitemap文件可以帮助爬虫定位网站最新的内容，而无须爬取每一个网页。但该文件经常存在缺失、过期或不完整的问题。 2.通过ID遍历爬虫有时网站会给一些网站设置网站别名，使用连续的ID作为标识，比如http://xxxx.com/city/1 。这样可以对搜索引擎优化起到帮助作用，Web服务器也可以直接只使用ID来匹配数据库里相关的记录。所以我们也可以利用这些连续的ID来遍历整个网站。 但一方面，这样的网站别名并不是每一个网站都有的，另一方面也有一些网站会使用非连续大数作为ID或者直接不使用数值作为ID，这样的情况下，就不能通过ID遍历爬取整个网站了。 3.通过链接跟踪爬取让爬虫表现得更像普通用户，通过跟踪所有链接的方式，下载整个网站。 步骤： 1.通过正则表达式确定需要下载的页面的URL格式 2.将相对链接转换为绝对链接，Python中有urlparse模块可以实现。 123&gt; import urlparse&gt; link = urlparse.urljoin(seed_url,re_link) #seed_url即当前页面URL，re_link是页面上的相对链接&gt; 3.记录已爬取过的链接，避免重复下载。 ⑤下载限速如果我们爬取某网站的速度过快，则会面临被封禁或者造成服务器过载的风险。所以需要在两次下载时添加延迟，对爬虫限速。 ⑥爬虫陷阱一些网站会动态地生成页面内容，这样就会出现无限多的网页，这样页面会无止境链接下去，这种情况被称为爬虫陷阱。 想要避免陷入爬虫陷阱，一个简单的方法是记录到达当前网页经过了多少个链接，即深度，达到设置的最大深度就停止爬虫。 3.数据解析查看目标网站的源代码，了解所要爬取数据的结构，之后就要找办法将数据提取出来。 ①正则表达式正则表达式就是一些符号组成的公式，由一些符号来定义匹配规则。 正则表达式简单易用，但难以适应网页的变化，健壮性不好，又有构造困难，可读性差等缺点。 关于正则表达式的学习，我的建议是以查询为主，记忆为辅，平常使用的时候直接查询每一个符号代表什么意思，用多了也就自然记住了。 关于正则表达式的规则，可以看这里。 ②BeautifulSoupBeautiful Soup是一个非常流行的Python模块，该模块可以解析网页，并提供定位内容的便捷接口。 Beautiful Soup会先将下载的HTML内容解析为soup文档。（Beautiful Soup可以正确地解析一些错误的（比如引号缺失、标签未闭合）的HTML。）然后从文档中找到目标元素。 ③lxmlLxml是基于libxml2这一XML解析库的Python封装。该模块使用C语言编写，解析速度比Beautiful Soup更快，但安装过程较为复杂。 ④性能对比 抓取方法 性能 使用难度 安装难度 正则表达式 快 困难 简单（内置） Beautiful Soup 慢 简单 简单 Lxml 快 简单 相对困难 4.爬虫优化①缓存支持1.磁盘缓存 实现简单，但受本地文件系统的限制（比如文件名不能相同、每个卷或者目录下的文件数目有限） 2.数据库缓存 加载速度慢，但NoSQL可以避免文件系统的种种限制，并且在并发环境下更加高效。 ②并发下载……待续","categories":[{"name":"Python技术","slug":"Python技术","permalink":"http://yangliuxiao.top/categories/Python技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yangliuxiao.top/tags/爬虫/"}],"keywords":[{"name":"Python技术","slug":"Python技术","permalink":"http://yangliuxiao.top/categories/Python技术/"}]},{"title":"Python句法基础","slug":"Python句法基础","date":"2019-04-10T07:56:37.000Z","updated":"2019-04-24T01:06:05.321Z","comments":false,"path":"2019/04/10/Python句法基础/","link":"","permalink":"http://yangliuxiao.top/2019/04/10/Python句法基础/","excerpt":"","text":"CPython、Jython、IronPython和PyPy 0. Python是解释型的还是编译型的？ 这是个Python新人都会迷惑的问题。 首先需要明了的是Python只是一个接口。有一个关于Python应该做什么以及怎么做的具体说明(类似其他接口的接口说明文件)，并且对应的有很多具体的实现（CPython、Jython等）。 其次需要知道的是“解释型”和“编译型”是具体实现的特性，而不是接口的特性。 所以，这个问题本身就没有组织好,没意义。 1. CPython CPython是特指C语言实现的Python，就是原汁原味的Python。当我们从Python官方网站下载并安装好比如Python 3.5后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。CPython是使用最广的Python解释器。 之所以使用CPython这个词，是因为Python解释器还有一些其它的实现，比如Java版的Jython，还有使用Python再把Python实现了一遍的PyPy。当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以用任何语言编写Python解释器来执行Python代码（当然难度很大）。 最新的语言特性都是在CPython解释器上面先实现，基本包含了所有第三方库支持，但是CPython有几个缺陷，一是全局锁使Python在多线程效能上表现不佳，二是CPython无法支持JIT（即时编译），导致其执行速度不及Java和Javascipt等语言。于是出现了Pypy。 2. JythonJython是运行在Java平台上的使用Java语言实现的Python解释器，可以直接把Python代码编译成Java字节码执行。CPython中很容易为你的Python代码写C扩展，因为最终都是由C解释器执行的。而Jython则使得和其他java程序共同工作很容易：无需其他工作，你就可导入任何Java类，在你的Jython程序中使用其他Java类。（可以把不同语言的代码混在一起，并编译成同一程序。） 下面是一个例子，一段合法的Jython代码： 1234567[Java HotSpot(TM) 64-Bit Server VM (Apple Inc.)] on java1.6.0_51&gt;&gt;&gt; from java.util import HashSet&gt;&gt;&gt; s = HashSet(5)&gt;&gt;&gt; s.add(\"Foo\")&gt;&gt;&gt; s.add(\"Bar\")&gt;&gt;&gt; s[Foo, Bar] 3. IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的使用C#实现的Python解释器，可以直接把Python代码编译成.Net的字节码。 4. PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython仍存在一些不同，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果CPython代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 PyPy是用Python自身实现的解释器。针对CPython的缺点进行了各方面的改良，性能得到很大的提升。最重要的一点就是Pypy集成了JIT。但是，Pypy无法支持官方的C/Python API，导致无法使用例如Numpy，Scipy等重要的第三方库。这也是现在Pypy没有被广泛使用的原因吧。 而PyPy与CPython的不同在于，别的一些python实现如CPython是使用解释执行的方式，这样的实现方式在性能上是很凄惨的。而PyPy使用了JIT(即时编译)技术，在性能上得到了提升。 基础数学运算 1. ** python当中^符号，区别于Matlab，在python中，^用两个**表示，如3的平方为3**2,**3表示立方，**4表示4次方，依次类推 1234&gt;&gt;&gt; 3**2 # **2 表示2次方9&gt;&gt;&gt; 3**3 # **3 表示3次方27 2. % 余数符号为%，与Java相同，见代码. 123&gt;&gt;&gt; 8%32 循环语句 1. while循环12while condition: expressions 在 Python 中除了常规比较操作 小于（&lt;) 大于 (&gt;) 不大于 (&lt;=) 不小于 (&gt;=) 等于 (==) 不等于 (!=) 会返回True和False值，其他一些变量放在条件中也会返回True和False ① 数字 整数和浮点数也能进行Boolean数据操作, 具体规则，如果该值等于0或者0.0将会返回False其余的返回True ② None 如果 while 后面接着的语句数据类型None, 将会返回False。 ③ 集合 在 Python 中集合类型有list、tuple、dict和set等，如果该集合对象作为 while 判断语句， 如果集合中的元素数量为 0，那么将会返回False, 否则返回True。 2. for循环12for item in sequence: expressions range()函数 在 Python 内置了工厂函数range()，range函数将会返回一个序列. range(start, stop, step)，step代表步长，即相隔的两个值的差值。从start开始，依次增加step的值，直至等于或者大于stop，当start为0，step为1时可省略。 step为-1时表示倒序，此时start和stop也要改为由大到小。 3. 扩展3.1 内置集合Python 共内置了list、tuple、dict和set四种基本集合，每个 集合对象都能够迭代。 tuple 类型 123tup = ('python', 2.7, 64)for i in tup: print(i) 程序将以此按行输出 ‘python’, 2.7 和 64。 dictionary 类型 123456dic = &#123;&#125;dic['lan'] = 'python'dic['version'] = 2.7dic['platform'] = 64for key in dic: print(key, dic[key]) 输出的结果为：platform 64，lan python, version 2.7, 字典在迭代的过程 中将key作为可迭代的对象返回。注意字典中key是乱序的，也就是说和插入 的顺序是不一致的。如果想要使用顺序一致的字典，请使用collections模块 中的OrderedDict对象。 set 类型 123s = set(['python', 'python2', 'python3','python'])for item in s: print(item) 将会输出python, python3, python2set 集合将会去除重复项，注意输出的结果也不是按照输入的顺序。 3.2 迭代器Python 中的for句法实际上实现了设计模式中的迭代器模式，所以我们自己也可以按照迭代器的要求自己生成迭代器对象，以便在for语句中使用。 只要类中实现了__iter__和next函数，那么对象就可以在for语句中使用。 现在创建 Fibonacci 迭代器对象, 1234567891011121314151617181920# define a Fib classclass Fib(object): def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def __next__(self): if self.n &lt; self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r raise StopIteration()# using Fib objectfor i in Fib(5): print(i) 将会输出前 5 个 Fibonacci 数据1，1, 2, 3, 5 3.3 生成器除了使用迭代器以外，Python 使用yield关键字也能实现类似迭代的效果，yield语句每次 执行时，立即返回结果给上层调用者，而当前的状态仍然保留，以便迭代器下一次循环调用。这样做的好处是在于节约硬件资源，在需要的时候才会执行，并且每次只执行一次。 1234567891011def fib(max): a, b = 0, 1 while max: r = b a, b = b, a+b max -= 1 yield r# using generatorfor i in fib(5): print(i) 将会输出前 5 个 Fibonacci 数据1，1, 2, 3, 5 判断语句 Java中的&amp;&amp;、||在Python中直接写and、or 12345if a &gt; 10 and b &lt; 6: #do stuff...if a &gt; 10 or b &lt; 5: #do stuff... Java中的condition ? value1 : value2在Python中可以通过if-else的行内表达式完成类似的功能。 1var = var1 if condition else var2 可以这么理解上面这段语句，如果condition的值为True, 那么将var1的值赋给var;如果为False则将var2的值赋给var。 函数定义 123def function_name(parameters): expressions return 1. 参数如果我们忘记了函数的参数的位置，只知道各个参数的名字，可以在 函数调用的过程中给指明特定的参数func(a=1, b=2), 这样的话，参数的位置将不受影响，所以func(b=2,a=1)是同样的效果。 1.1 默认参数我们在定义函数时有时候有些参数在大部分情况下是相同的，只不过为了提高函数的适用性，提供了一些备选的参数， 为了方便函数调用，我们可以将这些参数设置为默认参数，那么该参数在函数调用过程中可以不需要明确给出。 12def function_name(para_1,...,para_n=defau_n,..., para_m=defau_m): expressions 函数声明只需要在需要默认参数的地方用=号给定即可, 但是要注意所有的默认参数都不能出现在非默认参数的前面。 1.2 可变参数顾名思义，函数的可变参数是传入的参数可以变化的，1个，2个到任意个。当然可以将这些 参数封装成一个list或者tuple传入，但不够pythonic。使用可变参数可以很好解决该问题，注意可变参数在函数定义不能出现在特定参数和默认参数前面，因为可变参数会吞噬掉这些参数。 12345def report(name, *grades): total_grade = 0 for grade in grades: total_grade += grade print(name, 'total grade is ', total_grade) 定义了一个函数，传入一个参数为name, 后面的参数*grades使用了*修饰，表明该参数是一个可变参数，这是一个可迭代的对象。该函数输入姓名和各科的成绩，输出姓名和总共成绩。所以可以这样调用函数report(&#39;Mike&#39;, 8, 9)，输出的结果为Mike total grade is 17, 也可以这样调用report(&#39;Mike&#39;, 8, 9, 10)，输出的结果为Mike total grade is 27 1.3 关键字参数关键字参数可以传入0个或者任意个含参数名的参数，这些参数名在函数定义中并没有出现，这些参数在函数内部自动封装成一个字典(dict). 1234def portrait(name, **kw): print('name is', name) for k,v in kw.items(): print(k, v) 定义了一个函数，传入一个参数name, 和关键字参数kw，使用了**修饰。表明该参数是关键字参数，通常来讲关键字参数是放在函数参数列表的最后。如果调用方法portrait(&#39;Mike&#39;, age=24, country=&#39;China&#39;, education=&#39;bachelor&#39;)输出: 1234name is Mikeage 24country Chinaeducation bachelor 通过可变参数和关键字参数，任何函数都可以用universal_func(*args, **kw)表达。 2. 全局变量global关键字 首先我们在外部定义一个全局变量a=None, 然后再fun()中声明这个a是来自外部的a. 声明方式就是global a. 然后对这个外部的a修改后, 修改的效果会被施加到外部的a上. 所以我们将能看到运行完fun(),a的值从None变成了20. 123456789101112APPLY = 100 # 全局变量a = Nonedef fun(): global a # 使用之前在全局里定义的 a a = 20 # 现在的 a 是全局变量了 return aprint(APPLE) # 100print('a past:', a) # Nonefun()print('a now:', a) # 20 读写文件 open()打开文件使用open能够打开一个文件,open的第一个参数为文件名和路径 ‘file.txt’, 第二个参数为将要以什么方式打开它, 比如w为可写方式. 如果计算机没有找到 ‘my file.txt’ 这个文件,w方式能够创建一个新的文件, 并命名为my file.txt。 写文件以&#39;w&#39;、&#39;a&#39;方式打开文件，使用write()函数写文件 12345my_file=open('file.txt','w') #用法: open('文件名','形式'), 其中形式有'w':write;'r':read;'a':appendmy_file.write(text) #该语句会写入先前定义好的 textmy_file.close() #关闭文件 12345append_text='\\nThis is appended file.' # 为这行文字提前空行 \"\\n\"my_file=open('file.txt','a') # 'a'=append 以增加内容的形式打开my_file.write(append_text)my_file.close() 读文件 使用file.read()能够读取到文本的所有内容. 1234file= open('file.txt','r') content=file.read() print(content) 按行读取 file.readline(),file.readline()读取的内容和你使用的次数有关, 使用第二次的时候, 读取到的是文本的第二行, 并可以以此类推: 123456789101112131415file= open('file.txt','r') content=file.readline() # 读取第一行print(content)\"\"\"\"This is my first test.\"\"\"\"second_read_time=file.readline() # 读取第二行print(second_read_time)\"\"\"This is the second line.\"\"\" 读取所有行 file.readlines()，如果想要读取所有行, 并可以使用像for一样的迭代器迭代这些行结果, 我们可以使用file.readlines(), 将每一行的结果存储在list中, 方便以后迭代. 12345678file= open('file.txt','r') content=file.readlines() # python_list 形式print(content)\"\"\"\"['This is my first test.\\n', 'This is the second line.\\n', 'This the third line.\\n', 'This is appended file.']\"\"\"\" 类的定义 1234567891011121314151617class Calculator: #首字母大写，冒号不能缺 name='Good Calculator' #定义类的属性 price=18 def add(self,x,y): #定义类的方法 print(self.name) result = x + y print(result) def minus(self,x,y): result=x-y print(result) def times(self,x,y): print(x*y) def divide(self,x,y): print(x/y) 1234567891011121314&gt;&gt;&gt; cal=Calculator() #新建一个Calculate类的对象&gt;&gt;&gt; cal.name'Good Calculator'&gt;&gt;&gt; cal.price18&gt;&gt;&gt; cal.add(10,20)Good Calculator30&gt;&gt;&gt; cal.minus(10,20)-10&gt;&gt;&gt; cal.times(10,20)200&gt;&gt;&gt; cal.divide(10,20)0.5 在类中定义__init()__方法，相当于Java、C++中的构造函数; self相当于Java中的this； 123456789class Calculator: name='good calculator' price=18 def __init__(self,name,price,height,width,weight): # 注意，这里的下划线是双下划线 self.name=name self.price=price self.h=height self.wi=width self.we=weight 123456789101112&gt;&gt;&gt; c=Calculator('bad calculator',18,17,16,15)&gt;&gt;&gt; c.name'bad calculator'&gt;&gt;&gt; c.price18&gt;&gt;&gt; c.h17&gt;&gt;&gt; c.wi16&gt;&gt;&gt; c.we15&gt;&gt;&gt; 异常处理 try:,except ... as ...:相当于Java中的try...catch...语句 12345678try: file=open('eeee.txt','r') #会报错的代码except Exception as e: # 将报错存储在 e 中 print(e)\"\"\"\"[Errno 2] No such file or directory: 'eeee.txt'\"\"\"\"","categories":[{"name":"Python技术","slug":"Python技术","permalink":"http://yangliuxiao.top/categories/Python技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"}],"keywords":[{"name":"Python技术","slug":"Python技术","permalink":"http://yangliuxiao.top/categories/Python技术/"}]},{"title":"Java多线程二三事","slug":"Java多线程","date":"2019-03-20T14:11:33.000Z","updated":"2019-04-24T00:19:28.862Z","comments":false,"path":"2019/03/20/Java多线程/","link":"","permalink":"http://yangliuxiao.top/2019/03/20/Java多线程/","excerpt":"","text":"（1）Java线程创建方式 方法一：继承Thread类，作为线程对象存在（继承Thread对象） 123456789101112131415161718192021222324252627282930313233public class CreatThreadDemo1 extends Thread&#123; /** * 构造方法： 继承父类方法的Thread(String name)；方法 * @param name */ public CreatThreadDemo1(String name)&#123; super(name); &#125; @Override public void run() &#123; /*Thread类的interrupted方法，是来判断该线程是否被中断*/ while (!interrupted())&#123; System.out.println(getName()+\"线程执行了...\"); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; CreatThreadDemo1 d1 = new CreatThreadDemo1(\"first\"); CreatThreadDemo1 d2 = new CreatThreadDemo1(\"second\"); d1.start(); d2.start(); d1.interrupt(); /*中断第一个线程*/ &#125;&#125; 终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样。 方法二：实现runnable接口，作为线程任务存在 123456789101112131415public class CreatThreadDemo2 implements Runnable &#123; @Override public void run() &#123; while (true)&#123; System.out.println(\"线程执行了...\"); &#125; &#125; public static void main(String[] args) &#123; /*将线程任务传给线程对象*/ Thread thread = new Thread(new CreatThreadDemo2()); /*启动线程*/ thread.start(); &#125;&#125; Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里（new Thread(实现了Runnable接口的类)） 方法三：匿名内部类创建线程对象 12345678910111213141516171819202122232425262728293031public class CreatThreadDemo3 extends Thread&#123; public static void main(String[] args) &#123; /*创建无参线程对象*/ new Thread()&#123; @Override public void run() &#123; System.out.println(\"线程执行了...\"); &#125; &#125;.start(); /*创建带线程任务的线程对象*/ new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"线程执行了...\"); &#125; &#125;).start(); /*创建带线程任务并且重写run方法的线程对象*/ new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"runnable run 线程执行了...\"); &#125; &#125;)&#123; @Override public void run() &#123; System.out.println(\"override run 线程执行了...\"); &#125; &#125;.start(); &#125;&#125; 执行结果： 123线程执行了...线程执行了...override run 线程执行了... 方法四：创建带返回值的线程（FutureTask） 123456789101112131415161718192021222324252627282930313233343536public class CreatThreadDemo4 implements Callable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CreatThreadDemo4 demo4 = new CreatThreadDemo4(); FutureTask task = new FutureTask(demo4); /*FutureTask最终实现的是runnable接口*/ Thread thread = new Thread(task); thread.start(); System.out.println(\"我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务\"); /*拿出线程执行的返回值*/ Integer result = task.get(); System.out.println(\"线程中运算的结果为:\"+result); &#125; /*重写Callable接口的call方法*/ @Override public Object call() throws Exception &#123; int result = 1; System.out.println(\"业务逻辑计算中...\"); Thread.sleep(3000); return result; &#125;&#125;Callable接口介绍：public interface Callable &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 返回指定泛型的call方法。然后调用FutureTask对象的get方法得道call方法的返回值。 方法五：定时器(Timer、TimerTask) 1234567891011121314151617import java.util.Timer;import java.util.TimerTask;public class CreatThreadDemo5&#123; public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(\"定时器线程执行了...\"); &#125; &#125;,0,1000); /*延迟0，周期1s*/ &#125;&#125; 方法六：线程池创建线程 1234567891011121314151617181920212223import java.util.concurrent.ExecutorService;public class CreatThreadDemo6 &#123; public static void main(String[] args) &#123; /*创建一个具有10个线程的线程池*/ ExecutorService threadPool = Executors.newFixedThreadPool(10); long threadpoolUseTime = System.currentTimeMillis(); for (int i = 0;i&lt;10;i++)&#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"线程执行了...\"); &#125; &#125;); &#125; long threadpoolUseTime1 = System.currentTimeMillis(); System.out.println(\"多线程用时\"+(threadpoolUseTime1-threadpoolUseTime)); /*销毁线程池*/ threadPool.shutdown(); threadpoolUseTime = System.currentTimeMillis(); &#125;&#125; （2）线程状态说明 Java源码中Thread类中的内部枚举类型State一共声明了六种状态： 1. NEW： 新建状态，线程对象已经创建，但尚未启动。实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。 2. RUNNABLE：就绪状态，可运行状态，调用了线程的start方法，已经在java虚拟机中执行，等待获取操作系统资源如CPU，操作系统调度运行。 2.1 就绪状态 就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。调用线程的start()方法，此线程进入就绪状态。当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。锁池里的线程拿到对象锁后，进入就绪状态。 2.2 运行中状态 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。 3. BLOCKED:堵塞状态。线程等待锁的状态，等待获取锁进入同步块/方法或调用wait后重新进入需要竞争锁 4. WAITING：等待状态。等待另一个线程以执行特定的操作。调用以下方法进入等待状态。 Object.wait(), Thread.join(),LockSupport.park,处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。 5. TIMED_WAITING: 线程等待一段时间。调用带参数的Thread.sleep(), objct.wait(),Thread.join()，LockSupport.parkNanos,LockSupport.parkUntil会进入这种状态,处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。 6. TERMINATED:进程结束状态。当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 （3）Thread中的方法 （1）start方法API中对于该方法的介绍： 调用start()方法会使该线程开始执行，Java 虚拟机调用该线程的run方法。结果是两个线程并发地运行；当前线程（从start方法调用返回）和另一个线程（执行其run方法）。多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 （2）run方法API中对该方法的介绍： 如果该线程是使用独立的Runnable运行对象构造的，则调用该Runnable对象的run方法；否则，该方法不执行任何操作并返回。Thread的子类应该重写该方法。 run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。 调用start方法方可启动线程，而直接调用run方法只是Thread的一个普通方法调用，还是在主线程里执行。 （3）join方法Thread类中的join()方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。 join方法也可以传递一个参数给它，t1.join(10)表示主线程线程会等待t1线程10毫秒，10毫秒过去后，主线程和t1线程之间执行顺序由串行执行变为普通的并行执行，join(0)等价于join()。 join方法必须在线程start方法调用之后调用才有意义，join方法在start方法前调用时，并不能起到同步的作用，即join没有作用，等到start方法执行完后，两个线程依旧交替执行。 join()方法实现原理 join()源码： 123456789101112131415161718192021222324public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; join方法是通过调用线程的wait方法来达到同步的目的的。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态,当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。 （4）yield方法yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ yield()和wait()方法的比较 ① wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。 ② wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁（即只让出cpu时间片）。 （5）sleep方法sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行 sleep() 与 wait()的比较 wait()的作用是让当前线程由“运行状态”进入“等待(WAITING)状态”的同时，而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(TIMED_WAITING)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 （6）interrupt方法和线程中断方式interrupt()的作用是中断本线程（不会终止处于“运行状态”的线程，而是通过将线程的中断标记设为true来终止线程）。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。 中断一个“已终止的线程”不会产生任何操作。 中断线程的方式 Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！Why is Thread.stop deprecated? 使用interrupt()终止线程： interrupt()：在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。 isInterrupted()：用来返回当前线程的中断状态(true or false)。 interrupted()：是一个Thread的static方法，用来恢复中断状态，即将中断标记重新设为false （1）终止处于“阻塞状态”的线程 当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下： 12345678910@Overridepublic void run() &#123; try &#123; while (true) &#123; /* 执行任务...*/ &#125; &#125; catch (InterruptedException ie) &#123; /* 由于产生InterruptedException异常，退出while(true)循环，线程终止！*/ &#125;&#125; 注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理(添加break语句)。 （2）终止处于“运行状态”的线程 通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。 ① 通过“中断标记”终止线程 123456@Overridepublic void run() &#123; while (!isInterrupted()) &#123; /*执行任务...*/ &#125;&#125; isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。 ② 通过“额外添加标记” 1234567891011private volatile boolean flag= true;protected void stopTask() &#123; flag = false;&#125;@Overridepublic void run() &#123; while (flag) &#123; /* 执行任务...*/ &#125;&#125; 线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。 注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。 综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下： 1234567891011@Overridepublic void run() &#123; try &#123; /* 1. isInterrupted()保证，只要中断标记为true就终止线程。*/ while (!isInterrupted()) &#123; /* 执行任务...*/ &#125; &#125; catch (InterruptedException ie) &#123; /* 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。*/ &#125;&#125; （4）Object类中的wait、notify、notifyAll方法 首先看以下示例代码： 代码定义了一个3秒后唤醒等待线程的NotifyThread线程类，定义了一个用以等待的WaitThread类，定义了一个flag数组对象用来充当等待的对象（flag需要进行修改判断的原因是防止notifyAll方法执行完后还有线程执行wait方法，比如线程1、2运行至wait方法，而线程3因未知原因阻塞了一会，这时NotifyThread线程执行完了notifyAll方法，则线程3无法被唤醒）。在main方法中同时启动一个Notify线程和三个wait线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class NotifyTest &#123; private String flag[] = &#123;\"true\"&#125;; class NotifyThread extends Thread &#123; public NotifyThread(String name) &#123; super(name); &#125; public void run() &#123; try &#123; sleep(3000);/* 推迟3秒钟通知*/ System.out.println(\"3s later\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (flag) &#123; flag[0] = \"false\"; flag.notifyAll(); &#125; &#125; &#125;; class WaitThread extends Thread &#123; public WaitThread(String name) &#123; super(name); &#125; public void run() &#123; synchronized (flag) &#123; while (flag[0] != \"false\") &#123; System.out.println(getName() + \" begin waiting!\"); long waitTime = System.currentTimeMillis(); try &#123; flag.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; waitTime = System.currentTimeMillis() - waitTime; for(int i = 0;i&lt; 3;i++) &#123; System.out.println(getName() + \" wait time :\" + waitTime); &#125; &#125; System.out.println(getName() + \" end waiting!\"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main Thread Run!\"); NotifyTest test = new NotifyTest(); NotifyThread notifyThread = test.new NotifyThread(\"notify01\"); WaitThread waitThread01 = test.new WaitThread(\"waiter01\"); WaitThread waitThread02 = test.new WaitThread(\"waiter02\"); WaitThread waitThread03 = test.new WaitThread(\"waiter03\"); notifyThread.start(); waitThread01.start(); waitThread02.start(); waitThread03.start(); &#125;&#125; 运行流程讲解：4个线程开始并行执行，3个等待线程中的某一个（比如waiter01）先获取到flag对象的锁，输出waiter01 begin waiting!，执行到wait方法，释放flag锁，开始等待，3个等待线程中的另外两个中某一个（比如waiter03）获取到flag锁，输出waiter03 begin waiting!，然后执行到wait方法，释放flag锁，开始等待，余下的一个等待线程也一样。唤醒线程等待3秒之后，获取flag锁，调用notifyAll方法唤醒所有等待flag对象的线程，3个等待线程都被唤醒，依次竞争flag对象锁，依次输出结果。 输出结果： 1234567891011121314151617Main Thread Run!waiter01 begin waiting!waiter03 begin waiting!waiter02 begin waiting!3s laterwaiter02 wait time :3000waiter02 wait time :3000waiter02 wait time :3000waiter02 end waiting!waiter03 wait time :3000waiter03 wait time :3000waiter03 wait time :3000waiter03 end waiting!waiter01 wait time :3000waiter01 wait time :3000waiter01 wait time :3000waiter01 end waiting! 在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下：notify() — 唤醒在此对象监视器上等待的单个线程。notifyAll() — 唤醒在此对象监视器上等待的所有线程。wait() — 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) — 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout, int nanos) — 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 1. wait()方法让当前线程进入等待状态，同时，wait()会让当前线程释放它所持有的锁。 2. notify()方法notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现（不确定）。 3. notifyAll()方法唤醒在此对象监视器上等待的所有线程。 为什么wait，notify，notifyAll定义在Object中？ 一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。","categories":[{"name":"Java技术","slug":"Java技术","permalink":"http://yangliuxiao.top/categories/Java技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"多线程","slug":"多线程","permalink":"http://yangliuxiao.top/tags/多线程/"}],"keywords":[{"name":"Java技术","slug":"Java技术","permalink":"http://yangliuxiao.top/categories/Java技术/"}]},{"title":"TCP协议相关内容","slug":"TCP协议","date":"2019-03-13T01:43:53.000Z","updated":"2019-04-24T00:40:26.511Z","comments":false,"path":"2019/03/13/TCP协议/","link":"","permalink":"http://yangliuxiao.top/2019/03/13/TCP协议/","excerpt":"","text":"（1）TCP/IP的分层结构 （2）各层的主要协议 （3）数据封装 （4）TCP三次握手与四次挥手 （1）TCP/IP的分层结构 1）链路层（数据链路层或网络接口层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。 2）网络层（互联网层），处理分组在网络中的活动。 3）运输层，主要负责两台主机上的应用程序提供端到端的同信。（TCP(传输控制协议）UDP（用户数据包协议）。 4）应用层，主要负责处理特定的应用程序细节。大部分TCP/IP实现都会提供以下通用程序： Telnet远程登陆 FTP文件传输协议 SMTP简单邮件传送协议 SNMP简单网络管理协议 （2）各层的主要协议 TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议 TCP使用不可靠的IP服务，但是却提供一种可靠的运输层服务 UDP为应用程序发送和接收数据报。UDP是不可靠的，它不能保证数据报能安全无误的达到目的地。 IP（网际协议）是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。 ICMP(internet控制报文协议）是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。 IGMP（internet组管理协议）它用来把一个UDP数据多播到多个主机。 ARP(地址解析协议）和RARP（逆地址解析协议）是网络接口使用的特殊协议，用来转换IP层和网络接口层使用的地址。 （3）数据封装 当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层，直接到当作一串比特流送入网络。其中每一层对收到的数据都要加一些首部信息（有时还要增加尾部信息） TCP传给IP的数据单元称作TCP报文段(segment) IP传给链路层的数据单元称作IP数据报(IP datagram) 通过以太网传输的比特流称作帧（Frame) （4）TCP三次握手与四次挥手 两个序号和六个标志位： （1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。（B）ACK：确认序号有效。（C）PSH：接收方应该尽快将这个报文交给应用层。（D）RST：重置连接。（E）SYN：发起一个新连接。（F）FIN：释放一个连接。 需要注意的是： （A）不要将确认序号ack与标志位中的ACK搞混了。 （B）确认方ack=发起方req+1，两端配对。 ① 在第一次消息发送中，A随机选取一个序列号作为自己的初始序号发送给B； ② 第二次消息B使用ack对A的数据包进行确认，因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1，同时B告诉A自己的初始序列号，就是seq=y； ③ 第三条消息A告诉B收到了B的确认消息并准备建立连接，A自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示A正准备接收B序列号为y+1的数据包。 四次挥手： 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。 首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。 （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 不应该是为了防止B发送的FIN=1的包的丢失，因为如果A没有收到来自B的释放连接请求，是不会进入TIME-WAIT状态的。所以正确的解释是：A发送的确认释放连接信息B没有收到，这时候B会再次发送一个FIN=1的释放连接请求，而这个时候A还处于TIME-WAIT，所以可以再次发送确认信息","categories":[{"name":"网络","slug":"网络","permalink":"http://yangliuxiao.top/categories/网络/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"网络","slug":"网络","permalink":"http://yangliuxiao.top/tags/网络/"}],"keywords":[{"name":"网络","slug":"网络","permalink":"http://yangliuxiao.top/categories/网络/"}]},{"title":"面试问题（一）","slug":"面试问题（一）","date":"2019-03-05T05:44:38.000Z","updated":"2019-04-24T00:28:50.386Z","comments":false,"path":"2019/03/05/面试问题（一）/","link":"","permalink":"http://yangliuxiao.top/2019/03/05/面试问题（一）/","excerpt":"","text":"（1）Java有几种基本数据类型 Java共有八种基本数据类型。 数据类型 byte boolean int long float double char short 字节 1 1 4 8 4 8 2 2 默认值 0 false 0 0 0.0f 0.0d ‘u0000’ 0 （2）Java的自动装箱和拆箱 装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。 为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型）因为容器都是装object的，这是就需要这些基本类型的包装器类了。 int byte short long float double char boolean Integer Byte Short Long Float Double Character Boolean 12345/*自动装箱*/Interger i = 99;/*自动拆箱*/int j = i; 系统会为我们自动装箱拆箱，执行的是如下代码 12345/*装箱*/Interger i = Integer.valueOf(99);/*拆箱*/int j = i.intValue(); 来看一下Interger类的构造函数源码： 123456789private final int value;public Integer(int value) &#123; this.value = value;&#125;public Integer(String string) throws NumberFormatException &#123; this(parseInt(string));&#125; 可以看到两个构造函数，一个由int类型初始化，另一个能将String类型转成int类型。 Integer.valueOf函数： 1234 public static Integer valueOf(int i) &#123; return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];&#125; 当(i &gt;= 128 || i &lt;= -128)时，Integer.valueOf()函数会返回一个新建对象； 当(-128 &lt; i &lt; 128)时，函数返回SMALL_VALUES[i + 128]； SMALL_VALUES[i + 128]是什么？（由命名规则可以看出是常量且是个数组） 1private static final Integer[] SMALL_VALUES = new Integer[256]; 它是一个静态的Integer数组对象，也就是说valueOf(i)，如果i相同的话，返回的都是同一个Integer对象。 Interger.intValue()函数： 12345public int intValue() &#123; return value;&#125; 由此可以引申出另一个常见的面试题如下 （3）包装类型的比较 （理由同上，当(-128 &lt; i &lt; 128)时，函数返回SMALL_VALUES[i + 128]，是一个静态的Integer数组对象，返回的都是同一个Integer对象。）： 1234567891011Integer i1 = 100;Integer i2 = 100;Integer i3 = 200;Integer i4 = 200;System.out.println(i1==i2); /*true*/System.out.println(i3==i4); /*false*/ 而Double类则不存在这种情况，因为在-128至128间，存在无数个浮点数，所以他俩valueOf函数的实现方法不同，Double是直接新建一个值为i的新对象，并不判断i的范围。所以可以对Java基础数据类型分一个类： Integer派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。（都以-128和128为界限，char没有负数所以以0和128为界限） Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。 至于Boolean类型的valueOf方法： 1234 public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 可以看到它并没有创建对象，因为在内部已经提前创建好两个对象，因为它只有两种情况，这样也是为了避免重复创建太多的对象。 1234public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); （4）包装类型与基本数据类型之间的比较 12345Integer num1 = 400; int num2 = 400; System.out.println(num1 == num2); /*true*/ 说明num1 == num2进行了拆箱操作 123Integer num3 = 100;int num4 = 100;System.out.println(num3.equals(num4)); /*true*/ 说明num3.equals(num4)进行了装箱操作 Integer.equals()方法源码： 1234567@Overridepublic boolean equals(Object o) &#123; return (o instanceof Integer) &amp;&amp; (((Integer) o).value == value);&#125; 再来看下面的代码： 1234567891011Integer num1 = 100; int num2 = 100; Long num3 = 200l; System.out.println(num1 + num2); /*200*/System.out.println(num3 == (num1 + num2)); /*true*/System.out.println(num3.equals(num1 + num2)); /*false*/ 当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。 对于num3.equals(num1 + num2)为false的原因很简单，equal会先判断两个参数的类型，类型不同则返回false 再看以下代码： 1234567Integer num1 = 100;Ingeger num2 = 200;Long num3 = 300l;System.out.println(num3 == (num1 + num2)); /*true*/ 当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。 “==”比较的是内存地址，”equals”比较的是值。（包装类的equal函数都已经重写过） （5）String池 (1) String str1 = &quot;abcd&quot;的实现过程：首先栈区创建String引用，然后在String池（独立于栈和堆而存在，存储不可变量）中寻找其指向的内容为”abcd”的对象，如果String池中没有，则创建一个，然后str指向String池中的对象，如果有，则直接将str1指向”abcd””； (2) String str3 = new String(&quot;abcd&quot;)的实现过程：直接在堆中创建对象。 （6）面向对象特性 面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。 封装： 把描述一个对象的属性和行为的代码封装在一个模块中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。 抽象： 把现实生活中的对象抽象为类。分为过程抽象和数据抽象 继承：子类继承父类的特征和行为。子类可以有父类的方法，属性（非private）。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码之间的耦合性。 多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(比如：向上转型，只有运行才能确定其对象属性)。方法覆盖和重载体现了多态性 耦合：简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 内聚：内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 （7）String、StringBuffer和StringBuilder区别 1. 数据可变和不可变 String底层使用一个不可变的字符数组private final char value[];所以它内容不可变。 StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：char[] value; 2. 线程安全StringBuilder是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低。 StringBuffer.append()源码（加了同步锁）: 123456@Overridepublic synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this;&#125; StringBuild.append()源码： 12345@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 3. 相同点StringBuilder与StringBuffer有公共父类AbstractStringBuilder。 最后，操作可变字符串速度：StringBuilder &gt; StringBuffer &gt; String。 （8）ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构（双向链表）。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 （9）HashMap和HashTable、ConcurrentHashMap区别 相同点: HashMap和Hashtable都实现了Map接口 都可以存储key-value数据 不同点： HashMap可以把null作为key或value，HashTable不可以 HashMap线程不安全，效率高。HashTable线程安全，效率低。 HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。 fail-fast：就是最快的时间能把错误抛出而不是让程序执行。 ConcurrentHashMap Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好，效率也更高 ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。 HashMap能否同步 HashMap可以通过下面的语句进行同步： Map m = Collections.synchronizeMap(hashMap); （10）拷贝文件的工具类使用字节流还是字符流？ 答：用字节流。 字节流：传递的是字节（二进制）， 字符流：传递的是字符 为什么使用字节流？ 使用字节流的传输的文件，不一定能使用字符流传输，使用字符流传输的文件都可以转成字节流在进行传输。音乐媒体等使用的是字节，使用字符无法传输。需要拷贝的文件不确定只包含字符流，有可能包含字节流（图片，视频，音乐）。考虑到通用性，所以要使用字节流。 （11）Java有没有goto goto属于java中的保留字，但现在没有在java中使用。 （12）&amp;和&amp;&amp;的区别 &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str!= null&amp;&amp; !str.equals(s))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp;++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 （13）在JAVA中如何跳出当前的多重嵌套循环？ 方法一：在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break语句 1234567ok:for(int i=0;i&lt;10;i++)&#123; for(intj=0;j&lt;10;j++)&#123; System.out.println(“i=” + i + “,j=” + j); if(j == 5) break ok; &#125;&#125; 方法二：添加一个命名有意义的flag，让外层的循环条件表达式的结果可以受到里层循环体代码的控制。当循环嵌套多时，这样的程序更易读。 1234567891011121314151617181920boolean found = false;/*循环跳出flag*/for(int i=0;i&lt;arr.length&amp;&amp;!found;i++) &#123; for(intj=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] ==5) &#123; found =true; break; &#125; &#125;&#125; （14）switch语句可以作用的变量类型 在switch（e）中，e只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。在JDK1.7之后，String类型已经被支持，可以在switch中使用。 long，double等是不可以在switch中使用的。 （15）+=运算符的特殊 对于short s1= 1; s1 = s1 + 1;由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1= 1; s1 += 1;由于 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 （16）使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句： final StringBuffer a=new StringBuffer(&quot;immutable&quot;); 执行如下语句将报告编译期错误： a=new StringBuffer(&quot;&quot;); 但是，执行如下语句则可以通过编译： a.append(&quot;changed&quot;); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： public void method(final StringBuffer param){} 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(&quot;a&quot;); （17）static关键字 静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。 123456789101112public class VariantTest&#123; publicstatic int staticVar = 0; publicint instanceVar = 0; publicVariantTest()&#123; staticVar++; instanceVar++; System.out.println(staticVar +instanceVar); &#125;&#125; ① static方法 static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。 ② static变量 static变量也称作静态变量、类变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static成员变量的初始化顺序按照定义的顺序进行初始化。 ③ static代码块 static关键字还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。 ④ static关键字的误区 1. static关键字会改变类中成员的访问权限吗？ 与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。 2.能通过this访问静态成员变量吗？ 可以。 12345678910111213&gt; public class Main &#123; &gt; static int value = 33; &gt; &gt; public static void main(String[] args) throws Exception&#123;&gt; new Main().printValue();&gt; &#125;&gt; &gt; private void printValue()&#123;&gt; int value = 3;&gt; System.out.println(this.value);&gt; &#125;&gt; &#125;&gt; 输出结果：33 this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。 s 3. static能作用于局部变量么？ 在Java中，static是不允许用来修饰局部变量的。 static的题目： 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; Person person = new Person(\"Test\"); static&#123; System.out.println(\"test static\"); &#125; public Test() &#123; System.out.println(\"test constructor\"); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125;class Person&#123; static&#123; System.out.println(\"person static\"); &#125; public Person(String str) &#123; System.out.println(\"person \"+str); &#125;&#125;class MyClass extends Test &#123; Person person = new Person(\"MyClass\"); static&#123; System.out.println(\"myclass static\"); &#125; public MyClass() &#123; System.out.println(\"myclass constructor\"); &#125;&#125; 输出结果： 1234567test staticmyclass staticperson staticperson Testtest constructorperson MyClassmyclass constructor 结果解释：首先要执行main()方法，要先加载Test类，所以先执行Test类的静态代码块，然后进入main()方法，执行new MyClass();语句，要先加载MyClass类，发现存在父类Test，但Test类已经进行过加载，所以开始加载MyClass，执行MyClass的静态语句块。MyClass类加载完之后，要执行新建对象操作，而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。 总结： ① 新建对象前要先加载类（静态语句） ② 加载子类之前要先加载父类 ③ 执行构造器之前要先初始化成员变量 ④ 新建子类之前要先执行父类的构造器","categories":[{"name":"面试相关","slug":"面试相关","permalink":"http://yangliuxiao.top/categories/面试相关/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"}],"keywords":[{"name":"面试相关","slug":"面试相关","permalink":"http://yangliuxiao.top/categories/面试相关/"}]},{"title":"阿里天池新人赛（工业蒸汽量预测）","slug":"阿里天池新人赛（工业蒸汽量预测）","date":"2018-12-28T13:55:03.000Z","updated":"2019-04-24T00:26:56.505Z","comments":false,"path":"2018/12/28/阿里天池新人赛（工业蒸汽量预测）/","link":"","permalink":"http://yangliuxiao.top/2018/12/28/阿里天池新人赛（工业蒸汽量预测）/","excerpt":"","text":"工业蒸汽量预测在上完数据挖掘课程之后，虽然对数据挖掘所涉及的基本算法知识有了初步的了解，但纸上得来终觉浅，绝知此事要躬行，所以在阿里天池大赛上找了这么个新人赛（除了新人赛其他的比赛都无从下手了）来练练手，一方面可以将老师教的知识巩固下，另一方面学习一下python机器学习库scikit-learn和数据处理库NumPy的使用。 阿里天池新人赛（工业蒸汽量预测） 赛题背景 火力发电的基本原理是：燃料在燃烧时加热水生成蒸汽，蒸汽压力推动汽轮机旋转，然后汽轮机带动发电机旋转，产生电能。在这一系列的能量转化中，影响发电效率的核心是锅炉的燃烧效率，即燃料燃烧加热水产生高温高压蒸汽。锅炉的燃烧效率的影响因素很多，包括锅炉的可调参数，如燃烧给量，一二次风，引风，返料风，给水水量；以及锅炉的工况，比如锅炉床温、床压，炉膛温度、压力，过热器的温度等。 赛题描述 经脱敏后的锅炉传感器采集的数据（采集频率是分钟级别），根据锅炉的工况，预测产生的蒸汽量。 数据说明 数据分成训练数据（train.txt）和测试数据（test.txt），其中字段”V0”-“V37”，这38个字段是作为特征变量，”target”作为目标变量。选手利用训练数据训练出模型，预测测试数据的目标变量，排名结果依据预测结果的MSE（mean square error）。 以上就是赛题背景和赛题描述以及比赛给出的数据说明。赛题背景和赛题描述没什么好说的，只是说明了要做的到底是什么事情罢了，从中并没有什么可以对我们做数据分析有帮助的地方。而数据说明则告诉我们一共有38个特征变量，下载打开训练数据（train.txt）可以看到38个特征变量全都是连续数值类型，而且target也是连续数值类型的，这个时候我们第一反应就很自然地想到这应该是个回归问题。训练数据（train.txt）一共有2888条，测试数据（test.txt）一共有1925条。 以上是这学期人工智能课程企业老师归纳的人工智能建模步骤。业务目标和数据获取这部分已经不用操心了，所以接下来要做的的就数据清洗和特征工程。 首次尝试思路： 读入数据之后，先计算每个特征与targtet之间的相关系数 12345678910import numpy as np#相关性分析column = data.columns.tolist()[:39]mcorr = data[column].corr()mcorr_data = np.array(mcorr.target)print('相关系数-------------------')print(mcorr_data)print('--------------------') 结果： 从中可以看到有一些特征属性与target之间的相关系数很小，这些特征属性将会对回归结果有影响，所以去掉相关系数相对较小的一些特征属性。 然后将数据进行标准化之后，进行PCA降维。 12345678from sklearn import preprocessingfrom sklearn.decomposition import PCAdata_scaled = preprocessing.scale(data)pca = PCA(n_components=0.9)pca_data = pd.DataFrame(pca.fit_transform(data)) 使用sklearn封装的PCA方法，PCA方法参数n_components，如果设置为整数，则n_components=k。如果将其设置为小数，则说明降维后的数据能保留的信息。 PCA降维的维度选择很麻烦，但有sklearn，我们只需要将n_components设置为0.9即可，即表明降维后的数据能保留90%的信息，不需要选择具体维度。 对数据的处理过程就先到这里，然后开始选择机器学习算法。前文已经说过，从给出的数据来看，这应该是个回归问题，所以选择① 线性回归 ②梯度提升回归（GradientBoostingRegressor） ③ xgboost 来做回归预测。 ① 线性回归 1234567891011121314151617181920212223242526from sklearn.cross_validation import train_test_splitfrom sklearn.linear_model import LinearRegression#训练数据和测试数据划分#train_test_split(train_data,train_target,test_size=0.3, random_state=0)#train_data：被划分的样本特征集 #train_target：被划分的样本标签#test_size：如果是浮点数，在0-1之间，表示样本占比；如果是整数的话就是样本的数量#random_state：是随机数的种子。X_train, X_test, y_train, y_test = train_test_split(pca_data, target, test_size=0.2,random_state = 40)linreg = LinearRegression()linreg.fit(X_train, y_train)print(\"截距和斜率*************\")print(linreg.intercept_)print(linreg.coef_)print(\"***********************\")target_pred = linreg.predict(X_test)# 用scikit-learn计算MSEprint(\"线性回归：\")print(metrics.mean_squared_error(y_test, target_pred)) 输出结果： 12线性回归：0.12046985211850315 ② 梯度提升回归（GradientBoostingRegressor） 1234567891011121314myGBR = GradientBoostingRegressor(alpha=0.9, criterion='friedman_mse', init=None, learning_rate=0.03, loss='huber', max_depth=15, max_features='sqrt', max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=10, min_samples_split=40, min_weight_fraction_leaf=0.0, n_estimators=300, presort='auto', random_state=10, subsample=0.8, verbose=0, warm_start=False)myGBR.fit(X_train, y_train)target_pred_2 = myGBR.predict(X_test)print(\"GBR:\")print(metrics.mean_squared_error(y_test, target_pred_2)) 输出结果： 12GBR:0.1169921728668063 ③ xgboost 12345678910111213141516171819import xgboost as xgbmodel_xgb = xgb.XGBRegressor(booster='gbtree',colsample_bytree=0.8, gamma=0.1, learning_rate=0.02, max_depth=5, n_estimators=500,min_child_weight=0.8, reg_alpha=0, reg_lambda=1, subsample=0.8, silent=1, random_state =42, nthread = 2)model_xgb.fit(X_train, Y_train)y_pred = model_xgb.predict(X_test)print(\"XGBoost：\")print(metrics.mean_squared_error(y_test, y_pred)) 输出结果： 12XGBoost：0.12128023196468511 选取其中较好的结果（GBR），提交答案后发现结果并不如预期。 出现这样的结果，很显然是过拟合的原因。所以参考了论坛中新人赛工业蒸汽预测代码notebook分享-陆玮超的思路之后，重新进行特征工程。 首先读取数据，将train数据的target字段去除后，与test数据合并，方便之后数据清洗和特征工程。 12345678import pandas as pdimport numpy as nptrain=pd.read_csv('E:\\\\projects\\\\steamPrediction\\\\dataSet\\\\zhengqi_train.txt',sep='\\t')test=pd.read_csv('E:\\\\projects\\\\steamPrediction\\\\dataSet\\\\zhengqi_test.txt',sep='\\t')train_x=train.drop(['target'],axis=1)# 将train数据的target字段去除，用以训练模型all_data = pd.concat([train_x,test]) # 将train与test数据合并 而后需要观察一下训练集和测试集中的数据分布情况，将训练集和测试集中数据分布有很大差别的那些特征去除掉，从而减小误差。 12345678#数据观察（可视化）import seabornimport matplotlib.pyplot as plt for col in all_data.columns: seaborn.distplot(train[col]) seaborn.distplot(test[col]) plt.show() 以上是截取的V1特征变量和V5特征变量的可视化结果，可以明显地看出，V1变量测试集和训练集的数据分布基本类似，而V5变量在两个数据集中的分布则存在较大的差别，所以应该手动将V5特征变量剔除。 接下来进行数据标准化和偏态修正 1234567891011121314151617181920212223all_data.drop(['V5','V17','V28','V22','V11','V9','V32','V33','V34'],axis=1,inplace=True)#数据标准化from sklearn import preprocessingmin_max_scaler = preprocessing.MinMaxScaler()data_minmax = pd.DataFrame(min_max_scaler.fit_transform(all_data),columns=all_data.columns)import math#偏态修正data_minmax['V0'] = data_minmax['V0'].apply(lambda x:math.exp(x))data_minmax['V1'] = data_minmax['V1'].apply(lambda x:math.exp(x))data_minmax['V6'] = data_minmax['V6'].apply(lambda x:math.exp(x))data_minmax['V30'] = np.log1p(data_minmax['V30'])X_scaled = pd.DataFrame(preprocessing.scale(data_minmax),columns = data_minmax.columns)train_x = X_scaled.loc[0:len(train)-1]test = X_scaled.loc[len(train):]Y=train['target'] 特征选择部分，除了上文的可视化阶段，对测试集和训练集分布不同的特征去除之外，这里再根据方差和单变量进行特征选择。 123456789101112131415161718192021222324252627#特征选择from sklearn.feature_selection import VarianceThresholdfrom sklearn.feature_selection import SelectKBestfrom sklearn.feature_selection import f_regression#方差threshold = 0.85 vt = VarianceThreshold().fit(train_x)# Find feature namesfeat_var_threshold = train_x.columns[vt.variances_ &gt; threshold * (1-threshold)]train_x = train_x[feat_var_threshold]test = test[feat_var_threshold]#单变量X_scored = SelectKBest(score_func=f_regression, k='all').fit(train_x, Y)feature_scoring = pd.DataFrame(&#123; 'feature': train_x.columns, 'score': X_scored.scores_ &#125;)head_feature_num = 18feat_scored_headnum = feature_scoring.sort_values('score', ascending=False).head(head_feature_num)['feature']train_x_head = train_x[train_x.columns[train_x.columns.isin(feat_scored_headnum)]]X_scaled = pd.DataFrame(preprocessing.scale(train_x),columns = train_x.columns)test = test[test.columns[test.columns.isin(feat_scored_headnum)]]Y_scaled = pd.DataFrame(preprocessing.scale(test),columns = test.columns) 接下来进行模型选择，这里选择了① SVR ② 线性回归 ③Lasso ④ ElasticNet ⑤ 多项式的KernelRidge ⑥ 线性的KernelRidge以及⑦ xgboost 最后对SVR、线性的KernelRidge、xgboost三种模型进行了简单的融合。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#模型尝试from sklearn.linear_model import ElasticNet, Lasso, BayesianRidge, LassoLarsIC,LinearRegressionfrom sklearn.svm import SVRfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressorfrom sklearn.kernel_ridge import KernelRidgefrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import RobustScalerfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clonefrom sklearn.model_selection import KFold, cross_val_scorefrom sklearn.metrics import mean_squared_errorfrom sklearn.model_selection import GridSearchCVimport xgboost as xgbimport lightgbm as lgb#进行10折的交叉验证n_folds = 10def rmsle_cv(model,train_x_head=train_x_head): kf = KFold(n_folds, shuffle=True, random_state=42).get_n_splits(train_x_head) rmse= -cross_val_score(model, train_x_head, Y, scoring=\"neg_mean_squared_error\", cv = kf) return(rmse)svr = make_pipeline( SVR(kernel='linear'))line = make_pipeline( LinearRegression())lasso = make_pipeline( Lasso(alpha =0.0005, random_state=1))ENet = make_pipeline( ElasticNet(alpha=0.0005, l1_ratio=.9, random_state=3))KRR1 = KernelRidge(alpha=0.6, kernel='polynomial', degree=2, coef0=2.5)KRR2 = KernelRidge(alpha=1.5, kernel='linear', degree=2, coef0=2.5)model_xgb = xgb.XGBRegressor(booster='gbtree',colsample_bytree=0.8, gamma=0.1, learning_rate=0.02, max_depth=5, n_estimators=500,min_child_weight=0.8, reg_alpha=0, reg_lambda=1, subsample=0.8, silent=1, random_state =42, nthread = 2)score = rmsle_cv(svr)print(\"\\nSVR 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))svr.fit(train_x_head,Y)score = rmsle_cv(line)print(\"\\nLine 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))score = rmsle_cv(lasso)print(\"\\nLasso 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))score = rmsle_cv(ENet)print(\"ElasticNet 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))score = rmsle_cv(KRR2)print(\"Kernel Ridge2 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))KRR2.fit(train_x_head,Y)head_feature_num = 18feat_scored_headnum = feature_scoring.sort_values('score', ascending=False).head(head_feature_num)['feature']train_x_head2 = train_x[train_x.columns[train_x.columns.isin(feat_scored_headnum)]]X_scaled = pd.DataFrame(preprocessing.scale(train_x),columns = train_x.columns)score = rmsle_cv(KRR1,train_x_head2)print(\"Kernel Ridge1 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))head_feature_num = 22feat_scored_headnum = feature_scoring.sort_values('score', ascending=False).head(head_feature_num)['feature']train_x_head3 = train_x[train_x.columns[train_x.columns.isin(feat_scored_headnum)]]X_scaled = pd.DataFrame(preprocessing.scale(train_x),columns = train_x.columns)score = rmsle_cv(model_xgb,train_x_head3)print(\"Xgboost 得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std()))model_xgb.fit(train_x_head,Y)#简单模型融合class AveragingModels(BaseEstimator, RegressorMixin, TransformerMixin): def __init__(self, models): self.models = models # 遍历所有模型，拟合数据 def fit(self, X, y): self.models_ = [clone(x) for x in self.models] for model in self.models_: model.fit(X, y) return self # 预估，并对预估结果值做average def predict(self, X): predictions = np.column_stack([ model.predict(X) for model in self.models_ ]) return np.mean(predictions, axis=1) averaged_models = AveragingModels(models = (svr,KRR2,model_xgb))score = rmsle_cv(averaged_models)print(\" 对基模型集成后的得分: &#123;:.4f&#125; (&#123;:.4f&#125;)\\n\".format(score.mean(), score.std())) 最后得到结果： 1234567891011121314151617SVR 得分: 0.1276 (0.0555)Line 得分: 0.1290 (0.0544)Lasso 得分: 0.1290 (0.0543)ElasticNet 得分: 0.1290 (0.0543)Kernel Ridge2 得分: 0.1269 (0.0531)Kernel Ridge1 得分: 0.1306 (0.0565)Xgboost 得分: 0.1312 (0.0573)对基模型集成后的得分: 0.1225 (0.0541)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"无监督对偶学习在图像转换领域的应用","slug":"无监督对偶学习在图像转换领域的应用","date":"2018-12-05T01:22:04.000Z","updated":"2019-05-16T08:03:27.686Z","comments":false,"path":"2018/12/05/无监督对偶学习在图像转换领域的应用/","link":"","permalink":"http://yangliuxiao.top/2018/12/05/无监督对偶学习在图像转换领域的应用/","excerpt":"","text":"论文阅读： DualGAN: Unsupervised Dual Learning for Image-to-Image Translation 作者将原本应用于自然语言处理领域的对偶学习应用到了图像转换领域，提出了一种通用的图像到图像转换的无监督学习框架，该框架仅依赖于未标注的图像数据。 读完这篇文章，收获是了解了对偶学习这个概念。 1. 问题定义用于跨域图像转换的条件生成对抗性网络(GANS)最近取得了很大进展。但根据任务的复杂性，需要成千上万的标记图像对来训练条件GAN模型。然而，人工标记是昂贵的，甚至是不切实际的，大量的数据并不总是可得的。 例如，虽然有大量的照片或草图可用，但是对同一个人在相同姿势下的图片和素描对很少。再比如，将白天场景转换为夜间场景，即使使用固定的摄像机可以获得标记和匹配的图像对，场景中的移动对象也常常会导致不同程度的内容差异。 2. 解决方案文章介绍了一种通用的图像到图像转换的无监督学习框架，该框架仅依赖于未标注的图像数据。显而易见的技术挑战是如何在没有任何数据描述正确转换的情况下对转换器进行训练。 受自然语言处理（NLP）中的对偶学习启发，在无监督的图像转换中应用对偶学习。 ◆ 对偶学习： 关于对偶学习，可以看一下这篇文章：微软亚洲研究院秦涛：对偶学习的对称之美 总结来说，就是利用 AI 任务的对称属性（primal-dual）使其获得更有效的反馈/正则化，从而引导、加强学习过程（特别是在数据量少的情况下）。 对称结构不仅存在于自然界，在 AI 的任务中也广泛存在。比如： 机器翻译，有英翻中和中翻英的对称； 语音处理，需要语音转文字（语音识别），也有文本转语音（语音合成）的任务； 图像理解，图像描述（image captioning）与图像生成 （image generation）也是一个对称的过程。 对话任务：问题回答（Question answering）与问题生成（Question generation） 搜索引擎：文本匹配查询（Query-document matching）与广告关键词推荐服务（Query/keyword suggestion） 由此，本文提出了基于对偶学习的图像转换： 将两种不同的图像相互转换，比如将素描转换为一个照片（生成器 A），或是反过来，将照片转换为素描（生成器 B）。通过生成器 A 和生成器 B 的两次生成，我们希望原始素描与最后生成的素描越相似越好。或是反过来，通过生成器 B 和生成器 A 的先后两次生成，我们希望原始照片与最后生成的照片的重构误差越小越好。对偶学习和GAN相结合，可以得到很好的结果。 3. 实验设计3.1 数据为了评价DualGAN在通用图像转换中的效果，针对多方面的任务进行了实验，包括照片-素描转换、标签-图像转换和艺术风格转换。 为了比较DualGAN与GAN和cGAN，使用了4个数据集： PHOTO-SKETCH ,DAY-NIGHT , LABEL-FACADES , AERIAL-MAPS,这些数据集由两个域之间的对应图像组成。它们作为ground truth(GT)，也可以用于监督学习。然而，这些数据集都不能保证像素级的精确特征对齐。这在一定程度上突出了获得高质量匹配图像对的困难。 还测试了两个未标记和配对的数据集MATERIAL dataset 、OIL-CHINESE painting dataset。材料数据集最初被用于材质识别，但在本实验中用于材质转换，有石头、金属、塑料、织物和木材等材质。油画-中国画数据集包含两种风格的画作，所有图像都是从搜索引擎中爬取的，它们包含的图像的质量、格式和大小各不相同。我们重新格式化、裁剪和调整图像了大小。在这两个数据集中，来自不同域的图像之间没有对应关系。 3.2 实验结果首先在四个有标记和配对的数据集上，比较DualGAN、GAN和cGAN的区别。这三个模型都是在相同的训练数据集上进行训练，并在不与训练数据重叠的新数据上进行测试。所有的训练都是在一个GeForce GTX Titan X GPU上进行的。在这个GPU上，所有模型都运行良好，时间都不到一秒。 日景-夜景转换：cGAN是用标记数据训练的，而DualGAN和GAN是以无监督的方式训练的。DualGAN成功地模拟了夜间场景并且保留了输入中的纹理，例如，查看DualGAN和GT在云区域上的差异。相比之下，cGAN和GAN的结果包含的细节要少得多。 标记-外观转换：DualGAN忠实地保存标签图像中的结构，即使一些标签在更精细的细节上与相应的照片不匹配。相比之下，GAN和cGAN的结果包含许多伪影。在标签照片不对齐的区域，cGAN经常产生模糊的输出(例如，第二行的屋顶和第三排的入口)。 素描-照片转换：DualGAN的结果通常比cGAN的结果更清晰，尽管前者使用未配对数据进行训练，而后者则使用图像对应。 照片-素描转换：GAN和cGAN产生的结果比DualGAN显示出更多的伪影和模糊。 3.3 结果分析与GAN相比，在几乎所有情况下，DualGAN产生的结果都较清晰，包含较少的伪影，并且更好地保存了输入的内容结构和目标域中捕获的特征(例如纹理、颜色、样式)。我们将改进归因于重构损失函数，重构损失迫使对偶生成器的输入需要根据输出进行重构，并增强了有利于目标分布编码的反馈信号。 与cGAN相比，在许多情况下，在输出的清晰度和对输入图像的准确反映性方面，DualGAN表现得更优秀。这是值得鼓舞的，因为cGAN使用了标记配对的图像对进行训练。然而，在图像和基于语义的标签之间进行转换时，例如地图-航拍图和标签-外观，通常不可能仅根据目标分布推断像素颜色和标签之间的对应关系。因此，DualGAN可能会将像素映射到错误的标签(如航拍图-地图、外观-标签），或者将标签映射到错误的颜色/纹理（地图-航拍图、标签-外观）。 4. 总结与展望本文提出了一种新的无监督对偶学习通用图像转换框架DualGAN，DualGAN的无监督特性使许多实际应用成为可能。 实验结果表明，DualGAN机制可以显著提高GAN在各种图像到图像转换任务中的输出。只使用未标记的数据，DualGAN甚至可以产生比使用标记数据的cGAN更好的结果。但另一方面，在某些涉及基于语义标签的任务中，cGAN要由于GualGAN。这是由于缺乏像素和标签对应信息，而这些信息不能仅从目标分布中推断。 在未来工作中，我们将研究这个缺陷是否可以通过使用少量的标记数据来去除。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"阅读","slug":"阅读","permalink":"http://yangliuxiao.top/tags/阅读/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"数据挖掘笔记（四）","slug":"数据挖掘笔记（四）","date":"2018-11-15T05:50:27.000Z","updated":"2019-04-24T00:38:41.137Z","comments":false,"path":"2018/11/15/数据挖掘笔记（四）/","link":"","permalink":"http://yangliuxiao.top/2018/11/15/数据挖掘笔记（四）/","excerpt":"","text":"分类：基本概念(basic-classification) 基本概念 （1）分类定义： 目标：以前未知的对象应该尽可能准确地被分配一个类。 评估：使用测试集来确定模型的性能。不同的评估方法包括准确性、召回性、精确性、AUC等。通常，给定的数据集分为训练集和测试集，其中训练集用于建立模型，测试集用于验证模型。 （2）分类任务例子 ① 比如预测肿瘤细胞良恶性② 将信用卡交易归类为合法或欺诈③ 营销经理需要进行数据分析，以帮助猜测具有给定配置文件的客户是否会购买一台新计算机(类别为购买/不购买)。④ 银行贷款官员需要对她的数据进行分析，以了解哪种贷款申请对她的银行是有风险的(课程有风险/没有风险)⑤ 将新闻故事归类为金融、天气、娱乐、体育等。 （3）一般分类方法：通常分为两步：学习模型（归纳），应用模型（演绎） 监督学习方法：决策树、朴素贝叶斯、基于规则的方法、神经网络、支持向量机、懒惰学习（K近邻）、集成方法 基础分类技术 （1）决策树 结构： ①内部节点：对属性的测试②分支：表示测试的结果③叶节点：分类标签 优势： ① 决策树的构造不需要领域知识或参数设置，适用于探索性知识发现② 决策树可以处理多维数据。③ 决策树的表示是直观的。④ 决策树可以很容易地转换成分类规则 决策树的构建： ① 属性选择方法：如何为树节点选择属性② 剪枝：大型的决策树可能过度拟合，许多树枝反映噪声或离群点，修剪树是为了删除这些分支，以提高对未见数据的分类精度。 决策树算法（都采用贪婪策略）： ① ID3（信息增益）② C4.5（信息增益率）③ CART（GINI指数） 数据分割方法：（对属性的类别不同分割不同）（还可分割成二路或者多路） 信息熵与信息增益：（ID3） 信息增益率：（C4.5） GINI指数：GINI反映了从数据集中随机抽取两个样本，其类别标记不一致的概率，因此，Gini越小，则数据集的纯度越高。 预剪枝(早停规则)： ① 在算法成为一棵完整的树之前停止它。② 节点的典型停止条件：（1.如果所有实例都属于同一个类，则停止；2.如果所有属性值都是相同的，则停止）③ 更严格的停止条件：（1.如果实例数小于用户指定的阈值，则停止。2.如果实例的类分布独立于可用特性(例如使用卡方测试)，则停止。3.如果扩展当前节点不改善杂质度量(GINI或信息增益)，则停止-贪婪） 后剪枝： ① 首先构建一棵完整的树② 以自下而上的方式修剪决策树的节点。③ 如果裁剪后泛化误差有所改善，则将子树替换为叶节点。④ 叶节点的类标签是从子树中的大多数实例中确定的。 缺失值处理：（《机器学习》周志华 P87） ① 如何在属性值缺失的情况下进行划分属性的选择（根据没有缺失的值进行划分，信息增益Gain乘以一个无缺失样本比例）② 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分（将属性值a缺失的样本分入每一个a的分支中，权值调整为w*比例，开始阶段，各样本权值初始化为1） （2）朴素贝叶斯 概念：贝叶斯分类方法是一种以计算出的事情发生的概率大小为分类依据的分类方法。而朴素贝叶斯中的朴素（naive）一词的来源就是假设各特征之间相互独立。这一假设可以使得朴素贝叶斯算法变得简单，但有时会牺牲一定的分类准确率。 先验概率：是指根据以往经验和分析得到的概率.如全概率公式。条件概率：在某条件下事件发生的概率。后验概率：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小。后验概率是条件概率的一种。 贝叶斯公式： 分类评价 （1） TP：正例分对 TN：反例分对 FP：反例被分错成正例 FN：正例被分错成反例 混淆矩阵 yes no Total yes TP FN P no FP TN N Total P_pred N_pred P+N 名称 英文名 公式 准确率、识别率 accuracy, recognition rate TP + TN/P + N 错误率 error rate, misclassification rate FP + FN/P + N 召回率（所有P的有多少召回了） sensitivity,true positive rate,recall TP/P 特异性 specificity,teue negative rate TN/N 精确性 precision TP/TP + FP 精确度与召回率的调和平均数 F,F-score (2 precision recall)/(precision + recall) （2）交叉验证 （3）留一法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"数据挖掘笔记（三）","slug":"数据挖掘笔记（三）","date":"2018-11-13T04:43:33.000Z","updated":"2019-04-24T00:38:11.760Z","comments":false,"path":"2018/11/13/数据挖掘笔记（三）/","link":"","permalink":"http://yangliuxiao.top/2018/11/13/数据挖掘笔记（三）/","excerpt":"","text":"频繁模式(frequent-itemsets) 基本概念 （1）频繁项集：频繁项集是经常出现在数据集中的模式（2）购物篮分析：频繁项集的挖掘可以发现大数据集中项之间的关联和相关性。这有助于许多业务决策过程，如菜单设计、交叉营销和客户购物行为分析。购物篮分析就是分析客户的购买习惯。 （1）支持度 support(A -&gt; B) = P ( AUB )（2）置信度 confidence(A -&gt; B) = P (A | B) = support(A -&gt; B)/support(A) = support_count( AUB ) /support(A)（3）最小支持阈值（4）最小置信阈值 （4）同时满足最小支持阈值和最小置信度阈值的关联规则就称为强关联规则。（5）k-itemsets （k项集），比如{a，b}就是一个2-itemsets（6）itemsets的出现频率是包含itemsets的transaction数,也称为项目集的 frequency,、support count或 count .（7）如果一个项集满足一个预定义的最小支持阈值，那么它就是一个频繁项集。（8）关联规则挖掘分两步： （1）查找所有频繁项集(大部分计算成本来自此步骤)（2）从频繁项集中生成关联规则 （9）几个概念： （1）超集：有项集S1={a,b}，那么它是项集{a}{b}的超集；{a}{b}是S1的真子集。（2）最大频繁项集：如果频繁项集L的所有超集都是非频繁项集，那么称L为最大频繁项集或称最大频繁模式，记为MFI (Maximal Frequent Itemset)。（3）闭项集：称X是数据集D上的闭项集，当且仅当没有合适的超项集Y有与X相同的支持计数。（4）项目集X是D中的闭频繁项集，如果X在D中同时是闭的和频繁的。（5）举例：最大频繁项集和频繁闭项集之间的区别：假如现在频繁阈值是3。 有10个事例里都有“花生-啤酒”，而且这10个事例没有其它共同项，那么“花生-啤酒”就是一个频繁闭项集，因为它首先是闭项集（没有总是跟它们同时出现的其它项），然后也满足频繁阈值。在10个事例里其中有5个同时也有“饼干”，因此“花生-啤酒-饼干”也是频繁集，因为“花生-啤酒-饼干”是“花生-啤酒”的超集，所以“花生-啤酒”不是最大频繁集。至于“花生-啤酒-饼干”是不是最大频繁集，那要看有没有它的超集满足频繁阈值，没有的话它就是最大频繁集。（比如{a,b,c}出现了10次，没有它的超集等于10次的了，则{a,b,c}为频繁闭项集，但是有{a,b,c,d}出现了5次，最小支持阈值为4，则{a,b,c,d}也是频繁项集，若没有它的超集满足频繁阈值，则它就是最大频繁集）模式的数目：最大频繁集&lt;频繁闭项集&lt;频繁项集，不过最大频繁集丢失了很多信息，比如可能在买“花生-啤酒-饼干”的人群中，还有一部分是买洗发水的，数目也达到了频繁项阈值，那么“花生-啤酒-饼干-洗发水”就是“花生-啤酒-饼干”的一个超集，所以“花生-啤酒-饼干”这个集合的独特性就不会在频繁最大集里体现；而频繁闭项集实际上还保留着频繁项集的信息，可以继续拆分为原来的频繁项集。D为数据集，C为频繁闭项集，M为最大频繁集。 频繁项集挖掘方法 （1）Apriori Algorithm 基本概念：该方法在1994年由Agrawal 和Srikant提出（1）找到满足最小支持度的频繁项集 ①Apriori 属性：频繁项集的子集也一定是频繁的，例如{a,b}是频繁的，则{a}和{b}都应该是频繁的。 ②迭代寻找基数从1到k的频繁项集(Kitemset)（2）使用频繁项集生成关联规则（3）步骤： 例子：给出一个有6个事务组成的数据集，设定最小支持度为2（2/9，22%），最小置信度为70% 第一步：构建1-候选项集与最小支持度比较，构建1-频繁项集 第二步：L1自连接形成C2，扫描D获得支持数，获得2-频繁项集（直到2此步还未曾使用先验属性） 第三步：L2自连接，使用Apriori属性进行剪枝（比如{l2,l3,l5}的子集{l3,l5}不是L2的成员即不是频繁项集，所以{l2,l3,l5}从C3删去），对D中的事务进行扫描，以确定L3 第四步：根据Apriori属性: 一个频繁项集的所有子集也必须是频繁的，我们可以确定四个字母候选项不可能是频繁的。 第五步：从频繁项集生成关联规则 （1）对于每一个频繁项集I，生成I的所有非空子集 （2）对于I的每一个非空子集S，如果support_count( I ) / support_ count( s ) &gt;= min_confidence 则输出关联规则S-&gt;(I-S) Apriori方法的效率改进： （2）Pattern Growth Approach （1）概念：无需生成候选集即可发现频繁项集 2步方法： （1）构建一个紧凑的数据结构，叫做FP-tree （2）直接从FP-tree中提取频繁项集 FP-tree的大小： （1）FP-树通常比未压缩数据的大小更小，因为通常许多事务共享项(前缀)。（2）最好的场景：所有事务都包含相同的项集。（fp-树只有1条路径）（3）最坏的情况：每个事务都有一组唯一的项(没有共同的项)。（fp树的存储要求更高，因为需要在节点和计数器之间存储指针。）（4）fp树的大小取决于item的排序方式。根据支持数的降序排序通常是可用的，但不一定生成最小的树（启发式的） （2）从fp树提取频繁项集 （1）分而治之（Divide and conquer）：首先寻找以e结尾的频繁项集，然后寻找de结尾等等，再找以d结尾的，然后cd等等 （2）首先从生成的FP树中提取以某一个项结尾的子树（比如以e结尾的） （3）通过在链接列表(虚线)上添加计数来检查e是否是一个频繁项。如果是的话，就把它提取出来。 （4）由于e是频繁的，查找以e结尾的频繁项集，即de、ce、be和ae。即构建以e结尾的条件FP树。使用e的条件fp-树查找以de、ce和ae结尾的频繁项集。注意be不被考虑，因为b在e的条件FP树中计数为1，是非频繁的。递归计算e-&gt;de-&gt;ade （3）FP-tree的优缺点 （1）优点： （1）只在数据集上进行了2步（2）一定程度上压缩了数据集（3）没有候选集生成（4）比Apriori方法要快得多 （2）缺点： （1）fp树可能不适合内存存储。（2）fp树的构建成本很高。（权衡：构建需要时间，但一旦构建，频繁的项目集就很容易读取；时间是浪费的(特别是如果min_upp很高的话)，因为唯一可以做的剪枝是在单个项目上；只有在将整个数据集添加到fp树后才能计算支持。） 频繁模式的评价方法 强关联规则不一定是感兴趣的。比如，通过分析，我们发现，在10000次交易中，有6000次购买了电脑游戏，7500次购买了视频，4000次两者都买了。 上述关联规则很强，但购买视频的实际独立的概率为75%，甚至大于60%。事实上，电脑游戏和视频是负面关联的，因为购买其中一个项目降低了购买另一个项目的可能性。 （1）相关性测量( A -&gt; B [support, confidence, correlation])： （1）Lift（ lift值=1表示A和B是独立的，&gt;1表示正相关，&lt;1表示负相关 ） （2）Chi-square measure卡方测试","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"DeepRoad:基于GAN的图片转换以及蜕变测试技术","slug":"DeepRoad-基于GAN的图片转换以及蜕变测试技术","date":"2018-11-08T12:30:53.000Z","updated":"2019-05-16T06:55:46.874Z","comments":false,"path":"2018/11/08/DeepRoad-基于GAN的图片转换以及蜕变测试技术/","link":"","permalink":"http://yangliuxiao.top/2018/11/08/DeepRoad-基于GAN的图片转换以及蜕变测试技术/","excerpt":"","text":"论文阅读： DeepRoad: GAN-based metamorphic testing and input validation framework for autonomous driving systems 作者提出了一种针对自动驾驶系统的基于GAN的蜕变测试以及输入验证框架。主要是为了解决自动驾驶领域的安全问题，具体点说就是当进行自动驾驶系统的测试的时候，很难获取到匹配的图像数据。比如说，你给自动驾驶系统一段路的晴天图像时，系统运行良好，然而此时你想测试雪天场景下系统的鲁棒性，但没有同一段路的雪天场景数据，若给到另一段路的雪天图像，又难以进行对比测试（涉及蜕变测试概念）。基于此，作者提出了解决方案。 读完论文之后，比较有收获的是了解了蜕变测试概念，关于图像转换技术，作者貌似也只是使用了别人给出的已有方法，而且有点语焉不详（也可能就是我没看懂而已……）。 1. 问题定义基于DNN的自动驾驶系统发生错误可能致命，为了解决基于DNN的自动驾驶系统的安全问题，最近出现了一些测试技术，可以从原始图像自动生成驾驶场景来增加测试用例，然而由于以下局限，这些测试技术是不够的。 1.1 这些技术合成的图像缺乏真实世界的多样性作者给出了已有的一些测试技术，分析了其缺陷所在。 ① DeepXplore ◆ 一种深度学习系统的自动白箱测试方法 ◆ 通过“哄骗”系统犯错，以暴露神经网络中的缺陷 ② DeepTest ◆ 通过简单的仿射变换和模糊化/雾/雨等各种效果滤波器对原始图像进行变换 上图是从论文中引用的合成图像，a存在彩色补丁，b存在多个黑洞，c存在黑色边线，都影响了图像质量。此外，对于图d，它似乎是通过简单地调暗原始图像并将其与加扰的“烟雾”效应混合而得到的，它违背了雾气密度变化的事实。类似地，在图e中，DeepTest只是通过在原始图像上添加一组线条来模拟雨。 这些事实表明，很难确定错误驾驶行为是由基于DNN的模型的缺陷引起的，还是由于测试技术本身的不足造成的。这些图像转换技术只能生成相似的图像，而不能复杂地合成不同风格的图像，从而限制了测试用例的多样性。 1.2 自动驾驶系统基于机器学习，所以当训练数据和应用领域数据不匹配的时候会大幅度降低系统精度传统软件往往需要验证输入，比如Web应用需要检查和过滤非法和恶意的输入。 但据我们所知，目前基于DNN的系统缺乏验证输入(例如驱动场景的图像)，因而容易造成系统脆弱性。具体来说，无效的输入，如驾驶场景中的异常图像，会严重降低预测精度，大大增加基于DNN的系统的风险。 例如，假设一个基于DNN的自动驾驶系统被训练在一个数据集上，该数据集只包含阳光下驾驶场景的图像。对于系统没有经过训练的领域外输入(例如驾驶场景的雨天图像)，很有可能导致系统输出错误的控制信号，从而给司机和乘客带来危险。 2. 解决方案文章提出了DeepRoad框架，主要包括两个模块：蜕变测试模块（DeepRoadMT）和输入验证模块（DeepRoadIV）。 2.1 蜕变测试模块采用了一种基于生成对抗性网络(GAN)的技术来合成各种天气条件下的驾驶场景，并开发了基于DNN的自动驾驶系统的蜕变测试（Metamorphic Testing）系统。 ① 蜕变测试蜕变测试：是一种用来缓解“测试准则问题”的软件测试技术。当测试人员对于所选择的测试用例难以确定预期的正确结果，或无法判定程序输出是否满足预期的结果时，便认为存在“测试准则问题”。 蜕变关系：假设p是程序输入映射到程序输出的程序数学表示，也就是有p[i] = o时，那么假设fi和 fo代表对输入和输出域进行特定转换的函数，满足下列关系： 一个或多个用来验证系统或待实现函数的必要属性（称为蜕变关系）的后续测试用例可以被构造出来，然后判断源测试用例和后续测试用例产生的输出是否在蜕变关系下一致。任何不一致的输出表示了程序的实现中存在缺陷。 ◆ 举例蜕变测试 拿正弦函数举例，正弦函数存在如下蜕变关系： 那么，根据这两个变换关系，可以根据一个测试用例，构造出两个蜕变测试用例： 由以上蜕变测试的定义，文章给出了基于DNN的自动驾驶系统的蜕变关系： 公式含义：对于任一输入图像i，做某种图像变换τ，经过DNN预测的转向角应该相同。 ② 图像变换使用UNIT （Unsupervised image-to-image translation network） 上图显示了UNIT的结构，S1和S2表示两个不同的区域(例如晴天和雨天驾驶场景)，E1和E2表示两个自动编码器，它们将从s1和s2的图像投影到共享的潜在空间Z。 假设x1和x2是一对图像，它们共享相同的内容。理想情况下，E1和E2将它们编码到相同的潜在向量z，并且可以由两个结构域特异的生成器G1和G2分别将其翻译回S1和S2。 D1和D2是检测图像是否分别属于S1和S2的两个鉴别器。具体来说，它们被期望区分输入图像是从目标域(例如真实图像)取样还是由训练有素的生成器(例如合成图像)产生。 基于自动编码器和生成器，UNIT可以用于两个域之间的图像转换。例如，图像x1可以通过G2(E1(X1)转换为S2。 在图5中，DeepRoadMT首先从两个目标域(例如，晴天和大雪天气下驾驶场景的数据集)获取未配对的训练图像，并通过优化损失函数，利用UNIT将两个域投影到相同的潜空间。训练结束后，DeepRoadmt使用经过良好训练的模型，将整个晴天驾驶场景的数据集转换为多雪天气。具体来说，给出阳光天气I下的任何图像，DeepRoadMT通过E1将其编码为矢量Zi，并使用G2合成在大雪天气下的相应版本τ(I)。DeepRoadMT将每一对真实和合成的驾驶场景图像提供给被测试的自主驾驶系统，即DNN，并比较它们的预测结果DNN⟦τ(I)⟧和DNN⟦I⟧来检测任何不一致的行为。 2.2 输入验证模块我们可以定义一个输入验证（Input Validation）标准，比如输入数据应该是任何大小为640*480的RGB图像，或者任何输入数据应该存在于训练数据集中，以保证其正确性。但是，第一条准则太弱，无法提高系统的鲁棒性，而第二条准则太强，使得系统缺乏通用性。 文章提到Probably Approximately Correct (PAC)学习理论，即不要求进行零误差的预测，而要求误差在一定范围内；不要求对所有样本都能预测成功，而要求预测误差在一定范围内。 根据PAC学习理论，文章给出输入验证标准：输入数据I应该从训练数据D中取值（从D中采样输入I的概率应该大于预定义的阈值θ）。 使用VGGNet提取其内容和风格特征选择卷积层conv 4_2和conv 5_3分别提取内容和样式特征。成为彩色网格F 4_2和 F 5_3，表示从VGGNet中提取的内容特征，样式特征G 5_3由Gram matrix计算 注意，这些彩色网格只是用来可视化的。它们的尺寸与实际输出不匹配 然后，矩阵F 4_2和G 5_3转换到特征向量V，对所有的图像都进行这样的处理，然后进行PCA主成分分析进行降维。在图6中，我们将目标维度设置为2。所处理的数据Y是在二维平面上给出的，蓝色和红色节点分别表示训练和在线驾驶图像。最后，DeepRoadIV计算训练数据与每个在线I之间的最小距离。拒绝对距离大于某一阈值的图像进行预测。 3. 实验设计3.1 数据准备◆ 图像数据 1.使用Udacity发布的真实世界数据集作为基线。2.选择了两集高速驾驶视频，视频中可以观察到不同帧间照明和道路状况的明显变化。3.为了训练UNIT模型，从YouTube收集极端场景的图像。在实验中，我们选择了大雪和大雨这两种极端的天气条件。4.为了使采集到的图像的差别比较大，我们只搜索超过20分钟的视频。5.在大雨的情况下，视频记录了雨刷刮过挡风玻璃，这可能会降低合成图像的质量。因此，在数据预处理阶段，手动检查和过滤这些图像。6.在实验中使用的所有图像都被裁剪并调整为320*240。7.对YouTube视频进行了低采样，以跳过内容接近的连续帧。 ◆ 自动驾驶系统 选择 Udacity 社区中的Autumn、Chauffeur和Rwightman三种基于DNN的自动驾驶模型进行测试，其中Rwightman的模型细节并不公开，但是，类似于黑匣子测试，我们的方法旨在检测模型的不一致性，因此，Rwightman仍用于测试。 3.2 实验度量◆ 一致性度量： 如果其转向角预测值在修正后的某一误差范围内，则该系统的行为是一致的。其中DNN表示自动驾驶模型，I表示真实的驾驶数据集，i表示I中的第i个图像，τ表示能够改变天气状况的图像生成器/转换器。f是一个指示函数，当输入是true的时候返回1，false的时候返回0，而ϵ是错误阈值。 ◆ 输入验证度量： 首先，为了平衡输入数据和训练数据，我们从在线驾驶场景中收集M个图像作为输入数据，从训练数据集中随机选取M个图像作为训练数据。第二，为了估计出更稳定的距离，我们平均每幅图像的最小k个距离来表示它们的相似之处。同时使用L2范数来改善过拟合。 4. 实验结果 从上图可以看出，从质量上讲，GAN生成的图像在视觉上与从YouTube视频中收集的图像相似，它们还可以保存原始图像的主要语义信息(如树和道路的形状)。雪天天空相对较暗，雨天清晰度相对较低，与DeepTest有明显对比。 在上图中，每一行分别显示雪和雨的场景。在每个子图中蓝色标题表示模型名称，而红色和绿色曲线分别表示真实图像和合成图像上预测的转向角。这些曲线将预测结果可视化。 从图中我们可以看到，模型Autumn(前两列)在两个场景中都有最高的不一致数；相比之下，模型Rwightman(最后2列)是不同场景下最稳定的模型。这表明，DeepRoadmt能够在不同的道路场景下发现真实世界中的自动驾驶不一致的行为。例如，像Autumn或Chauffeur 这样的模型(它们在Udacity挑战中的排名都高于Rwightman)可能在阳光明媚的日子里工作得很好，但在雨天或下雪的日子里，可能撞到路边或者更糟糕的——迎面而来的汽车。 图10显示了DeepRoadIV关于晴天、多雨的结果还有雪景。具体来说，图10的前三张图分别显示了晴天、雨天和雪景的结果。橙色和蓝色点表示取样t雨和相应的输入图像。结果表明，晴天和训练图像的分布比较接近，而雨雪图像则远离聚类，和训练图像线性可分，阳光下的图像较分散，而雨雪图像较紧凑。究其原因，可能是由于雨雪图像的纹理统一，内容相对贫乏，使得图像之间的距离较小。。然而，阳光图像的光照条件和内容比较多样，因此距离很远。此外，从图10d中，我们发现晴天图像分布的距离主要在0~3之间，而几乎所有雨雪图像的距离都大于2。那么取阈值为2.5时，DeepRoadIV可以检测到100%的降雨，85%的降雪图像和21%的晴天图像中的离群点作为无效输入，有效地提高了系统的鲁棒性。 4. 可信性威胁内部有效性威胁：在本工作中，对内部有效性的主要威胁是我们的技术实现中的潜在缺陷。为了减少这些威胁，在实现DeepRoadMT时，我们使用了UNIT的原始实现以确保DeepRoadMT的性能。此外，在DeepRoadIV的实现中，我们从PyTorch网站下载了经过预先培训的VGGNet权重，而不是在ImageNet上进行培训。 外部有效性威胁：外部有效性的威胁主要来自于图像质量、数据集和自动驾驶模型。 1.我们缺乏评价图像质量(即真实性)的良好标准。在本文中，我们将让读者检查他们的质量。这种方法相当直截了当，但不那么客观。Salimans等人建议的 Inception 评分法来评价合成图像的质量，然而，经过证明，在比较生成模型(如GANs)时，Inception 评分不能提供有用的指导。 2.Udacity上的数据集相对较小，自动驾驶模型比较简单。假如数据集足够大，则可以训练一个更复杂、更健壮的模型，从而显著地减少不一致行为。 3.自动驾驶系统是非常复杂的，而在这项工作中，我们只关注了转向角的准确性。 5. 总结本文提出了一种无监督学习框架DeepRoad，用于合成真实的驾驶场景来测试基于DNN的自动驾驶系统的不一致行为（DeepRoadMT），并对在线输入图像进行验证（DeepRoadIV）。 在三个真实的Udacity自动驾驶模型上的实验结果表明，DeepRoad能够成功地检测出数千种不一致行为。此外，结果还表明DeepRoad可以有效地验证输入图像，从而提高系统的鲁棒性。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"阅读","slug":"阅读","permalink":"http://yangliuxiao.top/tags/阅读/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"数据挖掘笔记（二）","slug":"数据挖掘笔记（二）","date":"2018-11-05T10:25:47.000Z","updated":"2019-04-24T00:37:35.127Z","comments":false,"path":"2018/11/05/数据挖掘笔记（二）/","link":"","permalink":"http://yangliuxiao.top/2018/11/05/数据挖掘笔记（二）/","excerpt":"","text":"数据预处理(data-preprocessing) 数据预处理概论 （1）为什么要对数据进行处理为了数据的质量： 不准确、不完整和不一致的数据在现实世界的数据库和数据仓库中很常见。为了数据的实时性，实时性也影响数据质量（用户不及时更新数据）。为了数据的可信度，可信度反映了用户对数据的信任程度。为了数据的可解释性，可解释性反映了对数据的理解难易程度。 预处理方法： （1）数据清洗（Data Cleaning） （1）处理缺失的值 （2）处理噪音数据 （2）数据整合（Data Integration） （1）冗余与相关性分析 （3）数据缩减（Data Reduction） （1）维度约减 （2）数度约减 （3）数据压缩 （4）数据转化和数据离散化（Data Transformation and Data Discretization） 数据清洗（Data Cleaning） 处理缺失的值，平滑噪音数据，识别或者移除极端值，解决不一致问题 （1）处理缺失的值 1.直接忽略这个元组2.人工填补缺失值3.使用一个全局的常量进行填补（Unknown或者负无穷-∞）4.使用表示数据中心倾向的数值（平均数或者中位数）进行填充5.使用属于同一类的所有值的平均值或者中位数进行填充6.使用最可能的值填充（使用贝叶斯公式得到最可能的值，或根据决策树等基于推理回归的方法） （2）处理噪音数据：噪声数据是测量变量中的随机误差。 使用平滑技术去除噪音数据，许多平滑方法也用于数据离散化(数据转换的一种形式)和数据约简。（1）分箱使用箱平均数进行平滑使用箱中位数进行平滑使用箱边界进行平滑 （2）回归 （3）极端值分析（聚类） 数据整合（Data Integration） 当集成来自多个源的数据时，可能会出现不一致和冗余。（1）元数据（属性名、意义、数据类型、取值范围）可用于帮助避免模式集成中的错误。（2）冗余与相关性分析 对于名词属性，（先对名词属性计数）使用卡方检验（卡方检验：检验两个属性之间是否独立） 卡方检验公式：（实际值） - （两者独立情况下的理论值） 的平方再除以后者，对所有值求和） 对于数值属性，使用相关系数、协方差 协方差：协方差是描述随机变量相互关联程度的一个特征数。是X的偏差【X-E(X)】与Y的偏差【Y-E(Y)】的乘积的数学期望。由于偏差可正可负，因此协方差也可正可负。协方差为正时，即X、Y正相关，负为负相关，0为不相关（仅表示没有线性关系，不表示没有其他关系）。协方差仅能进行定性的分析，并不能进行定量的分析，公式如下：（E(X)为分量X的期望，E(Y)为分量Y的期望） 相关系数：定量分析两个变量之间关系。 数据缩减（Data Reduction） （1）维度约减： （1）小波变换有N个元素 从S0 至 SN计算两两元素之间的平均值和差值，得到N/2个平均值和差值以平均值为下一次递归计算的输入在仅剩一个平均值和差值时，递归结束最后得到1个平均值和N-1个差值（细节系数）可以逆变换回原数据（2）主成分分析（Principle Component Analysis）（3）属性子集选择 （2）数度约减： （1）参数化方法：使用统计模型代替实际数据（2）非参数化方法（3）抽样（4）聚类（5）柱状图 （3）数据压缩 数据转化和数据离散化（Data Transformation and Data Discretization） （1）平滑（2）属性构造（3）聚合（4）归一化 （1）Min-Max归一化：将A数据集中的vi映射成新的范围里的vi’（易受离群点影响） （2）Z-score归一化：在z分数规范化（或零均值规范化）中，属性基于均值和标准差规范化。 （3）小数定标规范化：移动小数点的位置进行规范化（除以10的次方，使得转化后的vi’绝对值的最大值小于1） （5）离散化 （1）使用分桶进行离散化（2）使用直方图分析离散化（3）使用聚类、决策树进行离散化（4）使用ChiMerge离散化 （6）概念层次生成","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"数据挖掘笔记（一）","slug":"数据挖掘笔记（一）","date":"2018-11-02T09:25:23.000Z","updated":"2019-04-24T00:39:27.274Z","comments":false,"path":"2018/11/02/数据挖掘笔记（一）/","link":"","permalink":"http://yangliuxiao.top/2018/11/02/数据挖掘笔记（一）/","excerpt":"","text":"数据挖掘介绍 数据探索 数据挖掘介绍（intro） 历史 从数据中人工提取模式： Bayes理论（1700s） 回归分析（1800s） 为什么进行数据挖掘 （1）已获得的大量数据往往是数据丰富但信息贫乏的（2）计算设备变得廉价且功能强大（3）没有强大的工具的话，数据量已经超过人类的理解能力（4）数据收集存储的速度越来越快（5）传统技术已经不适用于原始数据（6）数据挖掘有助于科学研究 什么是数据挖掘 （1）定义：对大量数据进行自动或半自动的探索和分析，以发现有意义的模式。（2）数据挖掘是知识发现的一个步骤 什么样的数据可以被挖掘 （1）关系型数据库数据（2）数据仓库（3）事务（transaction）数据 每一个记录（事务transaction）包含一组项集（items）（4）时间-空间数据（5）图以及网状数据（超链接图、社会和信息网络）（6）超文本和多媒体数据（文本、图像、视频和音频数据）（7）时间相关序列数据（8）数据流（监控、传感器） 可以挖掘出什么样的模式 （1）类别/概念描述：特征和区分（2）挖掘频繁模式（频繁模式通常是指经常出现在事务性数据集中的一组项，挖掘频繁模式可以发现数据中有趣的关联和相关性）、关联关系（3）使用分类和回归（找到一个描述和区分数据类或概念的模型）进行预测分析（4）聚类分析（5）异常分析（离群点分析） 挖掘结果的意义 （1）可能会找到许多无意义的模式（2）什么叫有意义的模式？：有效性、新的（对系统来说是未知的）、有用的（可以对项集采取动作的）、可理解的（人类能解释的） 使用哪些技术 机器学习、统计、人工智能、数据库、可视化等 应用 （1）确定网页重要性的PageRank算法（2）用于判断（银行是否应该予以贷款……）（3）…… 数据挖掘中的主要问题 （1）挖掘方法（2）用户交互（3）效率与可扩展性（4）数据库类型的多样性（5）数据挖掘与社会应用 数据挖掘和机器学习工具 （1）Weka (java)（2）Scikit-learn (Python) 数据探索（DataExploration） 数据对象和属性类型 （1）数据集由数据对象（也叫样本、实例、数据点等）组成（2）属性表示一个数据对象的特征，属性也可以称为维度、特性（3）属性类型： 名词属性（nominal attribute）：值是事物的符号或名称 二值属性（binary attribute）：只有0或1的取值，其中0常表示不出现，1表示出现。 序数属性（ordinal attribute）：属性值有意义上的排序，例如 A+ A- B+…… 数值属性（numerical attribute）:是可度量的，即以整数或实数表示的可测量的数量，有区间标度和比率标度两种类型。 数值属性又分为： 区间标度（interval-scaled）属性（没有真正零值，可以计算差值，不可计算倍数、比率）：区间标度属性用相等的单位尺度度量。区间属性的值有序。所以，除了秩评定之外，这种属性允许比较和定量评估值之间的差。 例如，身高属性是区间标度的。A同学身高170cm比B同学165cm高出5cm。对于摄氏温度和华氏温度，其零值不表示没有温度，零值不表示真正零点。例如，摄氏温度的度量单位是水在标准大气压下沸点温度与冰点温度之差的1/100。尽管可以计算温度之差，但因没有真正的零值，因此不能说10℃比5℃温暖2倍，不能用比率描述这些值。 比率标度（ratio-scaled）属性：比率标度属性的度量是比率的，可以用比率来描述两个值，即一个值是另一个值的倍数，也可以计算值之间的差。例如，不同于摄氏和华氏温度，开氏温度具有绝对零点。在零点，构成物质的粒子具有零动能。比率标度属性的例子还包括字数和工龄等计数属性，以及度量重量、高度、速度的属性。 属性的类型取决于它拥有以下属性中的哪一个： （4）离散和连续属性 离散属性：有限的或可数的无限个属性值（发色，饮料类别），如一个属性可能取值的值集合是无限的，但可以建立一个与自然数的一一对应，则其也是离散属性。 连续属性：不是离散的，就是连续的（在文献中常和数值属性Numeric attribute 交替使用） 数据的基本统计描述 基本统计描述可以用来识别数据的属性（集中趋势的量度、数据的分散性）（1）集中趋势的度量：平均值(Mean)，中位数(Median)，众数(mode). 平均值(Mean)：均值不是鲁棒的测量方法，也就是说，它们对噪声或异常值很敏感。通过去除极值可以得到修整的平均值。而且均值仅可用于数值属性(或连续属性)。 中位数(Median)：比均值更鲁棒，可以应用于数值属性，也可以扩展到序数属性。但当有大量的观测数据时，计算中位数代价很高。（大型数据集的近似中位数计算方式如下） 众数(mode)：数据集的众数是数据集合中最常见的值。众数既可用于名词属性，也可用于数字属性。具有一、二或三种众数的数据集分别称为单峰、双峰和三峰模态。 （2）度量数据的分散性：（2.1）范围、四分位数和四分位距 范围（Range）：最大和最小之间的差值 分位数：第k个q分位数是指值x，数据集中的k/q的数值比x小，数据集中（q-k）/q的数值比x大。（0&lt;k&lt;q） 百分位数（Percentiles）：即100-分位数 四分位数（Quartiles）：4-分位数 四分位距（Interquartile range （IQR））：IQR = Q3 - Q1（Q3：第三个四分位数，即第75个百分位数；Q1是第一个四分位数，即25%百分位数。） （2.2）方差：（标准差是方差的开方） （3）数据可视化柱状图（histogram) 箱形图（Box Plots） 分位图（Quantile Plot） 散点图（Scatter Plots） 等高线图（Contour plots） 平行坐标图（Parallel Coordinates）：一个纵坐标表示一个属性，在查看这样的分组时，属性的排序是很重要的。 星图（Star Plots）：与平行坐标图相似，但轴从中心点辐射，连接对象值的线是多边形。 测量数据相似性和差异性 （1）数据矩阵与相异矩阵具有n个对象，每个对象具有p个属性的数据集可以由n到p的数据矩阵表示： 相异矩阵： （2）名词属性的相异度测量：具有名词属性的两个对象xi和xj之间的不同可以根据不匹配的属性数比率来计算：（p是属性总数，m是相等的属性数） （3）二元属性的相异度测量： 对称二元相异度：r（s）是i（j）为1，j（i）为0的数量；q是i和j都为1的数目，t是i和j都为0的数目。 非对称二元相异度：只关心两者都取1的情况，而认为两者都取0的属性并不意味着两者更相似。例如在根据病情对病人聚类时，如果两个人都患有肺癌，我们认为两个人增强了相似度，但如果两个人都没患肺癌，并不觉得这加强了两人的相似性，如果用1减去非对称二元相异度，则得到非对称二元相似度，也叫Jaccard系数。 （4）数值属性的相异度测量： 欧几里得距离： 曼哈顿距离： 明可夫斯基距离Minkowski distance：h为2时即欧几里得距离，h为1时即曼哈顿距离 （5）有序属性的相异度测量： 序数变量是具有序数意义的分类变量，通常可以按照一定顺序意义排列，如冠军、亚军和季军。对于序数变量，一般为每个值分配一个数，叫做这个值的秩，然后以秩代替原值当做标量属性计算相异度。（分配1，2，3……然后归一化） （6）混合属性的相异度测量：i和j之间的相异度，f为属性序号，delta是指示器，当xif或者xjf缺失时或xif=xjf=0并且属性f为非对称二元属性时，为0，否则为1（就是把指示器为0的属性去除之后算了个平均值） 文档表示和文档之间的相似性度量 （1）TF.IDF（2）将term向量化后，使用余弦相似度","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/tags/机器学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://yangliuxiao.top/tags/Python/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://yangliuxiao.top/categories/机器学习/"}]},{"title":"读《人月神话》等有感","slug":"读人月神话等有感","date":"2018-10-25T02:40:30.000Z","updated":"2019-05-16T03:04:54.511Z","comments":false,"path":"2018/10/25/读人月神话等有感/","link":"","permalink":"http://yangliuxiao.top/2018/10/25/读人月神话等有感/","excerpt":"","text":"《人月神话》 《人件》 《精益创业》 《黑客与画家》 《软件管理沉思录》 《人月神话》 《人月神话》这本书可以说是闻名已久，在我刚上大一的时候，就有老师在课堂上说起过。由此也可以看出这本书确实是软件工程领域的一本非常经典的书籍。然而不知道是因为书中的内容已经太过久远了（对于计算机领域来说），还是我作为一个软件开发的新手尚缺乏实际的软件开发经验，尤其是团队软件开发实践，导致在大一买的这本书，直至大四本科毕业也仅仅才翻了几页而已就被放在书架低端吃灰去了。现在到了研究生阶段，再次拿起这本书，虽然依旧有很多看得不明所以的地方，但也终于能看明白一些理论，也有了一些自己的感悟，算是在这么久的学习生涯中的一些进步吧。 首先这本书严格来说实际上是一本文集，集选了作者Brooks的一些文章，阐述了他对于软件工程领域的一些看法和意见。所以书中其实分为了很多篇未必有上下联系的文章，每一篇文章都阐述、讨论了某个问题并且提出了一些解决方案。所以我就在其中挑选几篇感兴趣的文章在作者的观点基础之上再做些粗浅的讨论。 “焦油坑”是本书的开头第一篇，相信编者是由挑选过的，甚至将书名来源的“人月神话”都排到了第二篇，因为这篇文章阐述了引起问题的关键，就是初看并不复杂的软件项目往往有可能演化成互相累积和纠缠在一起的所谓“焦油坑”，一旦陷进这个“焦油坑”就难以再挣脱束缚，最终只能沉于坑底。文中用了一种在我看来挺别扭的表达方式，说明了完成一个编程系统产品的成本是完成一个已经经过测试的单纯程序的至少九倍。这其中成本的增加主要是由于扩展性、测试、文档、接口要求、资源限制等限制造成的。 文中还讨论了编程，或者说软件开发这个职业的乐趣与苦恼所在。我记得曾看见过这么一句话：“人的兴趣来自于成就感，而成就感来源于两个方面：创造与毁灭”这句话放在软件行业也是相当适用的，Brooks在文中就提出编程职业所带来的快乐在于四个方面，即创造、对别人有用、经过精妙的编程得到预期结果、学习。就我个人而言，Brooks的总结非常准确，我在从事编程时得到的快乐就大体来源于这四个方面。编程的乐趣来源总体来说与其他行业大同小异，而编程行业的苦恼就稍显特殊了。Brooks总结了几点，第一就是必须追求完美，书中所用的词语是完美，但其实我觉得应该是追求正确，因为实际上有时候没必要要求完美的文档，完美的算法，但一定要做到的是正确的程序，否则就根本跑不起来。其二是软件项目往往由他人设定目标即所谓的软件规格需求说明书，而不是由真正的编程人员自己编写的。这与建筑行业的设计图与建筑工人的比喻有所不同，建筑工人无需理解整栋楼的设计，只需要按照图纸进行工作即可达到建筑师的要求，而相对的，编程人员如果片面地，不假思索地进行程序编写，则往往会引发灾难的后果。这一方面与后文的很多内容都有联系，比如说“外科手术团队”这一章节，就提出由“外科医生”这一个人来进行设计与编程以确保所谓的概念一致性。第三个困恼则是关于软件测试的繁琐和难以面面俱到。最后一个则可以说是软件行业独特的一个烦恼，就是软件行业迭代更新太快了，快到连开发进度都有可能赶不上技术更新进度，这在建筑等其他行业是难以想象的。 全书的第二篇才是“人月神话”，也就是书名的由来，这篇文章讲述了几个软件行业异于其他行业的事实，其一就是软件行业的进度估算极为困难，因为每一个软件项目之间都是不同的，拿建筑行业举例，一栋大楼的时间进度是可估计的，有很多类似项目的经验可以直接拿来类比。但软件行业不同，不可能存在一摸一样的软件，否则根本无需开发，复制一下即可，即使是看起来相似的软件，其中内部的区别也可能极大地影响时间进度。第二就是人月无法互换，也就是说进度和工作量之间无法等同，这一点在其他行业也有体现，但在软件行业为甚。比如大家都曾听过的一个问题就是一百个人一个月可以盖好一栋大楼，那么是不是三千个人一天就可以盖好这栋大楼呢？答案显然是不可能的。但软件行业同样区分与这些传统行业，特殊在哪儿呢？就在于向这些传统行业加派人手最多就是无法再提升项目效率，而向软件项目盲目地加派人手则有可能降低开发效率，用书中的话说就是会进入一场注定会导致灾难的循环。所以由此引出了本文题目：用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话。 全书的第三章是“外科手术团队”，作者在这篇文章中提出了一种叫做“外科手术团队”的团队组织方式，将团队成员按照职责分工分为了外科医生、副手、管理员、编辑、两个秘书、程序职员、工具维护人员、测试人员、语言专家等，分别负责不同的任务。这其中“外科医生”的角色负责了最多的职责，可以说整个团队都是围绕这一角色构建的，他将负责整个程序项目从设计到编程实现的整个过程，以保证书中提到的概念一致性问题。但同时这一团队组织方式也有其缺陷，就是精简的团队虽然易于组织，也无需花费太多时间在沟通交流方面，但少量的人员始终胜任大量工作量的项目，比如5000人年的任务假如分配给仅仅几人的话将会是一个灾难。所以大型项目将会需要进行分解成小任务，再由“外科手术团队”这样的组织进行开发实现，不过这就又引出了一个新的问题，就是项目如何进行分解？ 另外一篇我比较感兴趣的文章是“贵族专制、民主政治和系统设计”。初看这篇文章题目感觉就和初看“没有银弹”题目一样让人摸不着头脑，但是其实这个题目取得恰到好处。文章首先说明了概念一致性的意义和重要性。由于设计被分成了由若干人完成的若干任务，系统体现出的概念差异和不一致性往往会造成很大麻烦。Brooks认为在系统设计中，概念完整性应该是最重要的考虑因素。也就是说为了反映一系列连贯的设计思路，宁可省略一些不规则的特性和改进，也不提倡独立和无法整合的系统，哪怕它们其实包含着许多很好的设计。这就引出了一个显然的矛盾，即设计是由一个人或一小部分人完成的，但是开发任务需要被分派给很多员工共同完成，最后系统由多个部分整合组装而成。如何解决这个矛盾就是本章的主要内容。 最后一篇不得不讲的就是被编排在本书最后一章的“没有银弹”了，相较于前面的“人月神话”一文，“没有银弹”这篇文章同样的声名在外，但是受到了更多的质疑，很多人都不同意这篇文章的观点，认为存在“银弹”使得软件开发的效率能够得到数量级的提升，在作者之后的“再论没有银弹”一文中也可以看到相应质疑，不过最后结论颇让人无奈，因为至少迄今为止，仍未发现可以对软件项目的开发一击致命的所谓“银弹”。这篇文章中最让我深以为然的一句话是“除非它占了所有工作的 9/10，否则即使全部次要任务的时间缩减到零，也不会给生产率带来数量级上的提高。”作者在文章中也提出了在他那个年代认为的有可能是“银弹”的一些技术，在今天看来，有一些技术已经得到了发展，但仍不能作为“银弹”使用，比如高级编程语言、面向对象编程和人工智能，而有一些技术在某些领域之外则已经被放弃，比如程序验证、专家系统。不得不说，可能真的没有“银弹”来解决软件开发这个怪兽。 《人件》 相较于之前阅读的《人月神话》，《人件》虽然也有一个初看让人摸不着头脑的名字，但是内容却简单易懂多了。看完这本书，第一反应是我以后一定要把这本书推荐给将来的上司。这本书与人月神话有相似的地方，比如两本书都讨论了有关工作效率提升的方法和现今工作中存在的问题，不同点在于《人月神话》中更多的是讨论软件工程这一个大的范畴中，应该如何提高效率，而《人件》则就如它的名字那样，主要讨论了“人”在项目中的调度管理问题，题目取得也是非常贴切，虽然有物化程序员的嫌疑，但是整本书看下来还是很为程序员一族说话的。这本书中关于项目中人员的管理方面提出了很多的意见，从人员也就是工作者的心理状态到工作环境的影响以及人员的选拔与培养再到整个团队的养成包括团队凝聚力的培养等，很多地方都让我有一种耳目一新的感觉。 在书的开头部分就提出的几个观点：“软件系统的主要问题不在于技术，而在于社会性因素”，“没有一个项目是由单纯的技术问题导致失败的”。其实软件行业的管理者有别与其他行业，软件行业的管理者需要一定的软件技术专业知识，但是又不能只关注于技术。书中举了例子，当管理者只关注技术的时候，就容易陷入所谓的“高科技幻觉”。我也经常有这种“幻觉”，当自己在敲代码，在各种黑色白色命令行背景下敲出各种命令，然后返回一大堆代码结果不断刷屏的时候，很有外国电影中的“科技感”。也许是计算机技术发展太迅速了，很多小时候仅仅在科幻电影中才能出现的场景，现在甚至可以在一个普通本科生手下借助一些框架进行实现，所以也难免有这样的高科技“幻觉”了。但是普通程序员可以有这种幻觉，没准还能有助于进行技术的钻研，保持工作的热情，但是当管理者有这种幻觉的话，他就会开始钻技术的牛角尖，将管理的重心由人转向技术，导致南辕北辙，舍本逐末了。 然而管理者也不能是对于软件开发行业的完全门外汉，书中将“干酪汉堡”的制作与软件的生产做了对比，提出了几种在制作汉堡时的生产量度指标，指出“这种‘干酪汉堡，做一个，卖一个’的思维观念在开发领域是致命的”。实际上这就是对于纯粹脑力劳动与体力劳动的管理方法的对比，在书的很多地方都可以看到这样的对比，比如后文提到的所谓的“流状态”的工作模式、新人培训费用的计算等等。其实程序员这种工作的管理确实需要多费脑筋，因为程序员这种行业既非纯粹的创造性的工作，比如作家、画家这种，也非纯粹的重复性工作，比如一些体力劳动者。让我来做一个比喻的话，我常常将程序员比作按照严格八股文写作的作家，而且一本书（一个项目）需要由很多这样的作家（程序员）你写一章我写一章地拼凑而成，事先的软件规格说明书就是这本书的大纲或者中心思想，所有作家需要自行理解这份大纲，了解自己需要做的，再将其写成一篇文章，虽然规定了格式，角色姓名等等，但是还是有很多地方可以自我发挥，而不同作者文章中存在冲突的地方就导致了项目程序中的bug。 文中还有一些听起来充满哲学意味的话：“只有愿为质量倾其所有的人，质量才是免费的”，这话听起来很奇怪，但是细想确实是有道理的，书中举了日本高质量与高产能并存的例子。在追求高质量的同时往往也就是在追求对自己的高要求，而在对自己高要求的同时又会促进高产能的实现！产品的高质量还会促进员工的信心提升。但是现实中这种情况却往往难以做到，书中也解释了一定的原因：软件用户往往把开发流程置于极度压力之下，同时又接受低质量的产品。无论如何，高质量会同时带来高产能确实是一个令人激动的发现，但是知道这件事和做到这件事还是存在很大差别的。这句话更多的可能需要作为一个指导方针对待，而不能直接生搬硬套。 书的中间部分主要介绍了工作环境对于程序员生产效率的影响。这一部分也是我为什么会想要将这本书推荐给我以后的上司的原因，其中有一些话说的深得我心。比如“一些公司环境及文化不但不能吸引或留住好的人才，更是让真正的人才无法在这种环境下有效工作。”还有“朝九晚五在这里啥也完成不了”，也就是说当工作人员在正常工作时间内无法工作，而需要额外找时间或者找地点去完成原本工作的时候，管理人员一定要引起注意，这绝对是管理人员的失职表现。书中举了很多例子，最荒谬也让人印象深刻的就是那个扩音器大喊某某请到办公室来一下，而打扰了整个工作环境的例子，真是让人哭笑不得。另一个书让我我印象很深的结论就是关于使用音乐来消除环境噪声的影响。当我在学习或者工作的时候往往也会无可避免地受到噪声的影响，这时候我会戴起耳机，放起音乐来尽量让自己不被外界噪声所打扰。我能感受出这毫无疑问地影响了我的效率。书中提到创造空间的问题，说边听音乐边工作会影响到创造力的发挥，我也深以为然。 书的后半部分主要提出了培养团队凝聚力的方法。书中的方法让我想到阿里巴巴公司文化，众所周知，阿里巴巴公司的程序员在入职之后都会给自己取一个武侠小说中的所谓花名，比如让人津津乐道的“风清扬”、“鲁肃”等。这毫无疑问也是提升团队凝聚力与集体荣誉感的一中很好的方式，就像书中提到的测试团队“black team”，让团队在团队外的人眼中变得与众不同，甚至变得奇怪，恰恰有助于团队中的人的团结与互相认同。 《精益创业》 这次读的书是埃里克·莱斯的著作《精益创业》。在读这本书之前已经在课堂上听老师提到过所谓的“精益模式”了，是起源于日本丰田公司的生产模式，主要是通过系统结构、人员组织、运行方式和市场供求等方面的变革，使生产系统能很快适应用户需求不断变化，并能使生产过程中一切无用、多余的东西被精简，最终达到包括市场供销在内的生产的各方面最好结果的一种生产管理方式。与传统的大生产方式不同，其特色是“多品种”，“小批量”。形象地说就是将生产模由“推”改为“拉”，以达到精简，无库存的目的。但是光听这个理论，我对于怎么将它应用到软件开发过程领域上毫无头绪，毕竟软件开发领域能有什么库存呢，除了人员是开发资源，还有什么是可以被精简的呢？怀着这样的疑问，我开始阅读这本书。 “新创企业的成功不在于优良的基因，或生逢其时其地。它可以因为遵循了正确的流程而获得，也就是说，成功是可以习得的，是可以传授的。”这句话可以说是本书的中心思想，虽然说得有些像成功学鸡汤的口吻，但也是基于这句话才有了“精益创业”这个理论，否则作者何必写这本书呢。 这本书的封面写上了用以吸引顾客的一些字眼，比如“风靡全球”“FACEBOOK 的创业成长模式”“李开复作序”之类的，其中最吸引我的就是“FACEBOOK 的创业成长模式”这句话了，文章中提到马克·扎克伯格在哈佛大学读大二是，鼓捣出的“Facebook”的第一个版本时，功能仅仅只是男女间彼此投票，看对方头像是否好看，根据用户反馈，后来才陆续加入了照片评选、个人主页、分享传播等功能。其实在我看来这是很平常的，就像平时我们自己开发了一个小小的程序功能，给同学使用一下，同学也会说哪好哪不好，然后返回再修改，这是很平常的一种状态。但作者毕竟是作者，他就能从其中看出这是一种互联网时代的区别于传统软件业的开发模式。传统软件业就像传统制造业，在推出新产品之前，要小心翼翼地保密，以防竞争对手的窥视，照着原定计划画上多年时间去制作某件产品。但这在互联网时代的高频率，高传播面，高传播速度的情形下恐怕行不通，因为市场的变化太快了，经验再丰富的产品经理也不可能在提前一年乃至几年的情形下，想明白现在的用户需求。所以这种开发-测量-认知的具有反馈的开发模式也就是作者所推崇的“精益模式”，由先获取需求，然后按部就班地根据需求进行开发，转至获取需求与开发同步进行，不断地根据用户反馈来改善自己的产品，这样的开发模式才能跟得上互联网时代的软件迭代速度。 和之前阅读的许多书目的作者一样，本书作者也有自己的创业经历。他在组建他的公司的产品开发团队时，使用了一些非正统、无厘头的方式，他希望将这种方式介绍给其他人，但是缺乏统一的表述语言来说明这种做法，也没有具体的原则来理解它们。简而言之就是一种野狐禅，虽然没有经验，没有理论指导，但是作者敏锐的感觉了解到了这种开发模式正是他所需要的，所以借鉴了传统制造业的日本丰田生产系统的精益生产理论用以说明，把精益生产的想法加以小小的变化和改动，运用到他的创业挑战中，这样整个理论框架就开始有了意义，最后获得了成功。所以其实作者并不是参照着所谓丰田生产系统的精益生产理论来进行软件开发模式的创新的，而是先有了软件开发的这种创新模式，但苦于没有理论指导，没有方式来说明这种模式的意义所在，所以将丰田生产系统的精益生产理论套用了过来，将其命名为“精益创业”。 《黑客与画家》 首先照例先与之前的阅读书目做个比较，这次阅读的是 Paul Graham 的著作《黑客与画家》，从书籍名字就可以看出，这本书与之前阅读的《人月神话》《人件》《软件管理沉思录》之类的书有所不同。之前的书虽然也名曰神话、沉思录之流，但实际上完完全全地是在讲软件管理理论，从项目管理、人员管理到团队管理，通篇其实就在讨论一个问题：如何提高软件项目的效率？即使作者的水平非常高，经验非常足，举例很多很生动，但还是不免让人感到枯燥无聊，尤其对于我这种还尚在学校的“理论派”程序员，没有足够的团队软件项目经验的人来说，很多理论其实都是听着有道理，但感悟感触并不深。但这本书就不同了，这本书几乎没有涉及到软件项目管理，更像是在向你传达作者的人生观、价值观、创业观以及顺带地介绍了一下计算机行业的一些相关事宜。书中有很多内容作者以一种类似讽刺、发牢骚的语气在进行阐述，其中对于一些针砭时弊的事例的语气可以说得上是尖酸刻薄了（比如第一章将学校比作“监狱”甚至“关住牲口的围栏”、比如讨论笨拙的书呆子和一些装作笨拙的呆子），这也使得这本书读起来趣味性更强。 首先本书的第一章题目就很吸引人：“为什么书呆子不受欢迎”。我并不算是严格意义上的书呆子，但是当然我也不是什么受人欢迎的家伙，这让我可以以一种相对客观的态度阅读这一章，因为这一章有些话太直白了。比如这一句“他们折磨书呆子的原因就像是拔掉一条蜘蛛腿一样，觉得很好玩。在一个人产生良知之前，折磨就是一种娱乐”，听着很像是荀子“人之初，性本恶”的观点。现在我也持有这种观点了，因为不论是从我周围看，还是作者身处的美国校园看，这种情况并不是个例，小孩子在没有受到教育之前，他是没有所谓恻隐之心也就是同情心同理心的。“一群人在一起，挑出一个书呆子，居高临下地欺负他，就会把彼此联系起来。一起攻击一个外人，所有人因此就都成了自己人”这种情况难道不是普遍存在的吗？从一起说某个相貌有缺陷的女生到社会上的各种歧视，这种投名状式的社交方式不是一直都存在的吗？ 作者把学校比作监狱，这让我感到有点好笑，因为这种比喻往往是学生自己比出的，作为一个成年人，社会上对学习的主观论调不应该是“象牙塔”“无忧无虑”“洁白无暇”吗？怎么会和肮脏的监狱相比呢？其实作者想要做类比的是在这两类场所里人们都没有什么具体的目标，大家做的事情没有具体的意义，当人们找不到生活的意义的时候，各种野蛮的不可思议无法理喻的事情就会发生了，比如说校园欺凌、做奇怪的事情引人注目、叛逆等，成人们一边将这样的事情认为是激素在作祟，一边责骂自己的孩子为什么不像隔壁家孩子一样听话，而不想具体是为什么导致孩子之间的差别。这就是孩子与成人矛盾的由来。作者非常不客气地说学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事情完。他们都是在办公室工作，所以就在上班的路上，顺路把孩子送到学校去关着，这有点像他们周末外出度假时，把狗送到寄养的地方。 作者提到青少年的问题在于他们在生产活动中是毫无作用的。要知道说这话的是个美国人！几乎所有我认识的年长者在谈起中美青年之间的差别的时候都会提到，美国青年更为独立，他们在成年之后就会出外打工赚钱，而无需父母供养了，而在中国恐怕除了家境艰难或者极少数思想西化的父母与孩子之外，大部分人都要直到大学毕业才能经济独立，甚至刚开始踏上社会仍需父母资助。美国青年尚且被认为在生产活动中毫无作用，就可想而知中国青年的状况了。这些青少年在生产活动中无法体现价值，那么他们会从哪里寻求价值呢？只能从各种奇怪的方面，由此网瘾、炫富、浓妆艳抹、勾心斗角就开始在校园里滋生了。 作者对书呆子一类人很是推崇，一方面是因为作者也是自属于书呆子之流的人，另一方面书呆子这类的人对于从事技术行业来说，确实是再合适不过了。 在发完了关于书呆子的牢骚之后，本书的第二章正式开始讨论起黑客这个话题。作者提到他读完了计算机的研究生后去了艺术学校学习绘画，当时人们感到很吃惊，实际上就算在现在发生这样的事情，人们还是会很吃惊，见到过很多从其他专业转过来计算机行业的，没见过转出去去艺术系的。作者提出黑客与画家其实有很多的相同之处，比如他们都是创作者，都试图创作出优秀的作品。他们本质上都不是做研究，虽然在创造过程中可能会发现一些新技术。我的理解是黑客并不是计算机科学家，他们不需要知道怎么去发明一个新东西（偶然有所发明当然是意外之喜），他们需要知道的是怎么用新东西以及怎么用好新东西。 作者还提出了一些离经叛道的观念，比如怎么找到与世俗观念不同的然而却应该是正确的东西，也就是所谓的“不能说的话”。这与前几年一直提倡的“言论自由”有相同也有不同，“言论自由”所争取的权利应该更加主要一些。而所谓的“不能说的话”要相对程度轻一些，比如在哥白尼那个时代，“日心说”就应该属于言论自由的范围，我们说阻止哥白尼宣扬“日心说”的教廷是邪恶的。而在现在我们知道“日心说”（太阳是宇宙的中心）当然是错的，因为太阳只是太阳系的中心，不可能是宇宙的中心。然而在现在你如果宣称太阳不是太阳系的中心，这就是“不能说的话”了，所有人都会嘲笑你，但这些人当中又有多少人真的观测过星空，计算过相应的天文学参数呢？他们所谓的言之凿凿，也不过是人云亦云罢了。 《软件管理沉思录》 这次阅读的是沃茨·汉弗莱写的《软件管理沉思录》。这本书的作者沃茨和先前阅读过的几本这类书籍的作者一样，都曾在如 IBM 一类的大公司担任管理工作，在自己数十年的工作经历中结合所见所闻和感受逐渐形成了自己对于软件开发、项目管理以及团队建设的一些看法，才有了现在我正在拜读的这本《沉思录》。由于这些书都是由这些经验丰富的开发者以及管理者的亲身经历组成的，所以即使过去了不短的时间，对这些书籍的阅读仍然可以使我们受益匪浅，毕竟其中的工作经历、人际交往、沟通技巧和团队建设一类的经验是仍可以通用的。 将这本书与之前阅读的《人月神话》和《人件》做一个对比的话，可以发现这本书相较于《人月神话》，更多地聚焦于人，而不是软件，和《人件》倒是有点像，其中也提到了一些和《人件》书中提到的类似的概念，接下来会讲到。这本书虽然排版分为了四个部分分别是管理项目、管理团队、管理领导和管理自己，但实际上我认为可以分为两部分——第一部分管理项目和第二部分管理项目人员，从涉及内容多少就可以看出本书的重点放在了管理项目人员这一部分，下面从这两个部分分别进行讨论。 首先看第一部分：管理项目，书中比较精简地从两个步骤讨论了项目管理，即第一部分阐述了质量的概念和重要性，第二部分阐述了为了实现质量需要对项目制定计划。在这一部分，比较让我感到新奇的是作者说到软件产品的质量应当被定义为产品对用户的有用性。这和我之前的想法有很大的不同，我之前一直认为所谓的软件质量仅仅指的是软件的健壮性，直到现在才知道软件的质量实际包含很多要求，包括对用户需求的实现度，易用性以及包含缺陷的多少等。只有得到了清晰的需求，才有可能开发出高质量的程序。而至于我们平常最关心的程序漏洞，也就是程序 bug，当然也是软件质量当中的一部分，而且是应当最先关注的那部分，因为软件产品必须要能完成用户的工作，否则软件质量就无从谈起，而只有在软件能够运行时，软件功能才能使用，所以首先应当关注的质量问题就是缺陷问题。但是质量问题不仅仅只有缺陷问题。 书中有一个非常形象且有趣的比喻，相较于我们现在将软件漏洞叫成 bug（小虫），作者觉得更应该将软件漏洞叫成定时炸弹。理由是小虫对我们的威胁感并不大，容易小视漏洞在软件产品中的破坏性，而将其称为定时炸弹则足以引起我们的重视。这一段另外一个引起我兴趣的是为了保证软件质量采取的“局部测评”、“质量到人”的策略，我认为这些策略就是现在的所谓代码评审制度，对开发人员的代码进行当中评审，虽然作为一个开发人员，这样的行为会让我感到更大的压力，但是不可否认的是压力使人进步，为了在代码评审环节不出状况，才会对自己所犯的错误更加敏感，也算是另外一种增强责任心的方式吧。 然后是占了一大半篇幅的项目人员管理部分，这部分分为了管理团队、管理领导、管理自己三个部分。首先是管理团队，这一部分和《人件》中讲的提高团队凝聚力的部分很像，《人件》中举出的“黑衣团队”的例子也和本书中提出的所谓“凝胶型团队”的概念基本一致。但是我认为书中的一些场景太过理想化了，比如书中提到的“自主指导型团队”，说到“团队成员会主动发现需要做什么并及时去做，而无需人提醒，为了能完成工作任务他们会去做任何需要做的事。对于工作，他们勇于承担，并决心把它做好”这样的一支团队虽然听起来十分美好，颇有种社会主义大家团结其利断金的感觉，但是确实太过理想化了，实际工作中很难做到。 另外还有 4.3 节中谈到目标时的描述“目标是一种每个人都认可并且能通力合作去实现的东西。”“实现目标会提供一种成就感和满足感。目标对个人非常重要，对团队来说甚至更加重要”实际上这两句话的前提是团队成员以实现目标为自我实现的一种途径，假如团队成员并不认为实现目标能对我带来什么满足感与成就感的话，他们就不会对目标达成有什么期待并为之努力，而一个团队中往往只需要一两个这样的人存在，所有人实现目标带来的成就感与满足感都会被慢慢破坏殆尽。 另一个让我感兴趣的观点是开发人员其实并不孤独，所谓“孤胆英雄”在团队项目中是不可取的。这条观点实际上是告诉我们遇到问题要学会寻求帮助，一个你从来没遇到过的问题，需要大量时间去解决它，然而可能你的同事时常遇到类似问题，很简单就可以搞定它。“互相帮助”这一在传统工作中非常习以为常的行为为什么在软件开发行业却要特别提出来呢？因为软件开发人员往往会自认为能力强于他人，认为依靠他人完成工作是一种耻辱，从而希望靠自己找出问题所在，陷入一种“孤胆英雄”式的个人英雄主义，实际上这样是很拖慢项目进度的。 其二谈到了管理领导，这一部分很有意思，而且是最有别于《人月神话》和《人件》的，这一部分提到了很多人际交往之类的相关知识，比如关于截止期限和你的管理者讨价还价。书中提到一点我觉得很有道理，当管理者向你提出一个项目截止期限时，他实际上有在征求你的意见，当然假如你直接反驳他说这么点时间不足以完成任务，他肯定是不听的，这时候就需要制定一个项目计划，仔细地告诉他为何这个项目需要这么多的时间，有时候你的直接管理者也并不想给你这个期限，是更上一级的管理者提出的，这样你提交的计划也可以成为他向上一级寻求期限改变的筹码。 最后一部分是管理你自己，这一部分和一些心灵鸡汤之类的文章或者说成功学之类的文章倒是有点像，比如说什么高效能人士的几个习惯之类的。书中提到了如何控制自己的工作，我觉得是学习工作生活中挺重要的几点。首先需要有一个明确定义和精确衡量自身提高的过程，只有这样才能激发自己去提高去学习工作的信心与意愿。然后提到了需要对自己的工作负责任和信守承诺，这两点放在一起说是因为我觉得这两点其实是同一个道理，简而言之就是需要对自己当前的工作学习有责任心，有了责任心，才能有内在驱动力去完成它。 总的来说这本书给我的感觉就是当我工作一段时间之后，或者走上管理岗位，或者在项目团队中工作，我应该还会再将这本书读几遍，到那时应该会有更深的感触。当然书中的一些例子一些观点，就算以我现在的阅历来看，在学习生活中也是大有帮助的。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://yangliuxiao.top/categories/阅读/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://yangliuxiao.top/tags/阅读/"}],"keywords":[{"name":"阅读","slug":"阅读","permalink":"http://yangliuxiao.top/categories/阅读/"}]},{"title":"设计模式（四）","slug":"设计模式（四）","date":"2018-06-05T05:31:37.000Z","updated":"2019-04-24T00:30:31.552Z","comments":false,"path":"2018/06/05/设计模式（四）/","link":"","permalink":"http://yangliuxiao.top/2018/06/05/设计模式（四）/","excerpt":"","text":"代理模式 模板方法模式 适配器模式 状态模式 组合模式 代理模式 模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 模式结构 代理模式包含如下角色： Subject: 抽象主题角色Proxy: 代理主题角色RealSubject: 真实主题角色 通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。 模式优缺点 优点： ① 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。② 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。③ 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。④ 保护代理可以控制对真实对象的使用权限。 缺点： ① 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。② 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 模式适用环境 根据代理模式的使用目的，常见的代理模式有以下几种类型：① 远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。② 虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。③ Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。 ④ 保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。⑤ 缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。⑥ 防火墙(Firewall)代理：保护目标不让恶意用户接近。⑦ 同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。⑧ 智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。 模式应用 (1) Java RMI (Remote Method Invocation，远程方法调用)。 (2) EJB、Web Service等分布式技术都是代理模式的应用。在EJB中使用了RMI机制，远程服务器中的企业级Bean在本地有一个桩代理，客户端通过桩来调用远程对象中定义的方法，而无须直接与远程对象交互。在EJB的使用中需要提供一个公共的接口，客户端针对该接口进行编程，无须知道桩以及远程EJB的实现细节。 (3) Spring 框架中的AOP技术也是代理模式的应用，在Spring AOP中应用了动态代理(Dynamic Proxy)技术。 模板方法模式 模式定义 模板方法模式(Template Method Pattern)：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。 模式结构 模板方法模式包含如下角色： AbstractClass: 抽象类ConcreteClass: 具体子类 在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。实现这些具体逻辑步骤的方法称为基本方法(Primitive Method)，而将这些基本法方法汇总起来的方法称为模板方法(Template Method)，模板方法模式的名字从此而来。 ① 模板方法：一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。② 基本方法：基本方法是实现算法各个步骤的方法，是模板方法的组成部分。包括 抽象方法(Abstract Method)具体方法(Concrete Method)钩子方法(Hook Method)：“挂钩”方法和空方法 12345678910111213141516&gt; public void template()&gt; &#123;&gt; open();&gt; display();&gt; if(isPrint()) /*钩子方法用以约束*/&gt; &#123;&gt; print();&gt; &#125;&gt; &#125;&gt; /*子类的钩子方法将覆盖父类的钩子方法，从而可以通过在子类中实现*/&gt; /*的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。*/&gt; public boolean isPrint()&gt; &#123;&gt; return true;&gt; &#125;&gt; 模式优缺点 优点: 模板方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。模板方法模式是一种代码复用的基本技术。模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”。 缺点： 每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。 模式适用环境 ① 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。② 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。③ 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。④ 控制子类的扩展。 模式应用 (1) 模板方法模式广泛应用于框架设计（如Spring，Struts等）中，以确保父类控制处理流程的逻辑顺序（如框架的初始化）。 (2) Java单元测试工具JUnit中的TestCase类的设计 适配器模式 模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 模式结构 类适配器： 对象适配器： 适配器模式包含如下角色： Target：目标抽象类Adapter：适配器类Adaptee：适配者类Client：客户类 模式优缺点 优点： ① 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。② 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。③ 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 类适配器模式还具有如下优点： 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强 类适配器模式的缺点如下： 对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。 对象适配器模式还具有如下优点： 一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 对象适配器模式的缺点如下： 与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 模式适用环境 ① 系统需要使用现有的类，而这些类的接口不符合系统的需要。② 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 模式应用 (1) JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。 (2)在Spring AOP框架中，对BeforeAdvice、AfterAdvice、ThrowsAdvice三种通知类型借助适配器模式来实现。 状态模式 模式定义 状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 模式结构 状态模式包含如下角色： Context: 环境类State: 抽象状态类ConcreteState: 具体状态类 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。 模式优缺点 优点： ① 封装了转换规则。② 枚举可能的状态，在枚举状态之前需要确定状态种类。③ 将所有与某个状态有关的行为放到一个类中（环境类），并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。④ 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。⑤ 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： ① 状态模式的使用必然会增加系统类和对象的个数。② 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。③ 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 模式适用环境 ① 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。② 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。 模式应用 ① 状态模式在工作流或游戏等类型的软件中得以广泛使用，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。 ② 在目前主流的RPG（Role Play Game，角色扮演游戏）中，使用状态模式可以对游戏角色进行控制，游戏角色的升级伴随着其状态的变化和行为的变化。对于游戏程序本身也可以通过状态模式进行总控，一个游戏活动包括开始、运行、结束等状态，通过对状态的控制可以控制系统的行为，决定游戏的各个方面，因此可以使用状态模式对整个游戏的架构进行设计与实现。 组合模式 模式定义 组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。组合模式又可以称为“整体-部分”(Part-Whole)模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。 模式结构 组合模式包含如下角色： Component: 抽象构件Leaf: 叶子构件Composite: 容器构件Client: 客户类 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。 组合模式根据抽象构件类的定义形式，又可以分为透明组合模式和安全组合模式。 透明组合模式： 安全组合模式： 模式优缺点 优点： ① 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。② 客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。③ 定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。④ 更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。 缺点： ① 使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。② 增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。 模式适用环境 需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。 模式应用 (1) XML文档解析 (2) 操作系统中的目录结构是一个树形结构，因此在对文件和文件夹进行操作时可以应用组合模式，例如杀毒软件在查毒或杀毒时，既可以针对一个具体文件，也可以针对一个目录。如果是对目录查毒或杀毒，将递归处理目录中的每一个子目录和文件。 (3) JDK的AWT/Swing是组合模式在Java类库中的一个典型实际应用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}]},{"title":"设计模式（三）","slug":"设计模式（三）","date":"2018-06-02T04:25:39.000Z","updated":"2019-04-24T00:29:58.644Z","comments":false,"path":"2018/06/02/设计模式（三）/","link":"","permalink":"http://yangliuxiao.top/2018/06/02/设计模式（三）/","excerpt":"","text":"策略模式 观察者模式 装饰模式 策略模式 模式定义 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。 模式结构 策略模式包含如下角色： Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 模式优缺点 优点： ① 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。② 策略模式提供了管理相关的算法族的办法。③ 策略模式提供了可以替换继承关系的办法。④ 使用策略模式可以避免使用多重条件转移语句。 缺点： ① 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。② 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 模式适用环境 ① 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。② 一个系统需要动态地在几种算法中选择一种。③ 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。④ 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。 模式应用 Java SE的容器布局管理就是策略模式应用的一个经典实例 jframe.setLayout(FlowLayout) 策略模式与状态模式区别 可以通过环境类状态的个数来决定是使用策略模式还是状态模式。策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。 观察者模式 模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。 模式结构 观察者模式包含如下角色： Subject: 目标ConcreteSubject: 具体目标Observer: 观察者ConcreteObserver: 具体观察者 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。（是由目标主动向观察者通知，所以严格意义上并不是观察者在“监视”，而是被观察者主动“自首”）作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publish-subscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 观察者模式优缺点 优点: ① 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。② 观察者模式在观察目标和观察者之间建立一个抽象的耦合。③ 观察者模式支持广播通信。④ 观察者模式符合“开闭原则”的要求。 缺点： ① 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。② 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。③ 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 模式适用环境 ① 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。② 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。③ 一个对象必须通知其他对象，而并不知道这些对象是谁。④ 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 模式应用 (1) JDK1.1版本及以后的各个版本中，事件处理模型采用基于观察者模式的委派事件模型(Delegation Event Model, DEM)。在DEM中，事件的发布者称为事件源(Event Source)，而订阅者叫做事件监听器(Event Listener)，在这个过程中还可以通过事件对象(Event Object)来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。事件源对象、事件监听对象（事件处理对象）和事件对象构成了Java事件处理模型的三要素。 (2)除了AWT中的事件处理之外，Java语言解析XML的技术SAX2以及Servlet技术的事件处理机制都基于DEM，它们都是观察者模式的应用。(3) 观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 模式扩展 在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。 MVC模式： MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。 装饰模式 模式定义 装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。 模式结构 装饰模式包含如下角色： Component: 抽象构件ConcreteComponent: 具体构件Decorator: 抽象装饰类ConcreteDecorator: 具体装饰类 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。 模式优缺点 优点 ① 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。② 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。③ 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。④ 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。 缺点 ① 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。② 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 模式适用环境 ① 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。② 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。③ 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。 模式应用 (1) 在javax.swing包中，可以通过装饰模式动态给一些构件增加新的行为或改善其外观显示。 如JList构件本身并不支持直接滚动，即没有滚动条，要创建可以滚动的列表，可以使用如下代码实现： 12JList list = new JList();JScrollPane sp = new JScrollPane(list); (2) 装饰模式在JDK中最经典的实例是Java IO。以InputStream为例： 角色分配： 抽象构件类：InputStream具体构件类：FileInputStream、ByteArrayInputStream等抽象装饰类：FilterInputStream具体装饰类：BufferedInputStream、DataInputStream等 客户端代码： 1234567/*……*/FileInputStream inFS=new FileInputStream(\"temp/fileSrc.txt\"); BufferedInputStream inBS=new BufferedInputStream(inFS);/*定义一个字节数组，用于存放缓冲数据*/byte[] data = new byte[1024];inBS.read(data);/*…… */","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}]},{"title":"设计模式（二）","slug":"设计模式（二）","date":"2018-06-02T03:31:18.000Z","updated":"2019-04-24T00:29:25.905Z","comments":false,"path":"2018/06/02/设计模式（二）/","link":"","permalink":"http://yangliuxiao.top/2018/06/02/设计模式（二）/","excerpt":"","text":"建造者模式 原型模式 单例模式 建造者模式 模式定义 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 模式结构 建造者模式包含如下角色：Builder（抽象建造者）、ConcreteBuilder（具体建造者）、Director（指挥者）、Product（产品角色） 建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 1234/*客户端代码*/Builder builder = new ConcreteBuilder();Director director = new Director(builder);Product product = director.construct(); 模式优缺点 优点： ① 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。② 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。③ 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。④ 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。 缺点： ① 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。② 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 模式适用环境 ① 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。② 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。③ 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。④ 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 模式应用 ① JavaMail（一步一步构造一个完整的邮件对象，然后发送） ② 在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。 原型模式 模式定义 原型模式(Prototype Pattern)：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。 原型模式的基本工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程。 模式结构 原型模式包含如下角色：Prototype（抽象原型类）、ConcretePrototype（具体原型类）、Client（客户类） 通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆和浅克隆。 Java语言提供的clone()方法将对象复制了一份并返回给调用者。一般而言，clone()方法满足： (1) 对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。(2) 对任何的对象x，都有x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。 模式优缺点 优点： ① 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。② 可以动态增加或减少产品类。③ 原型模式提供了简化的创建结构。④ 可以使用深克隆的方式保存对象的状态。 缺点： ① 需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。② 在实现深克隆时需要编写较为复杂的代码。 模式适用环境 ① 创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改。② 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。③ 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 模式应用 ① 复制(Ctrl + C)和粘贴(Ctrl + V)操作 ② 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。③ 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。 单例模式 模式定义 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 模式结构 单例模式包含如下角色：Singleton（单例） 单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。 1234567891011121314public class Singleton&#123; private static Singleton instance=null; /*静态私有成员变量*/ /*私有构造函数*/ private Singleton()&#123;&#125; /*静态公有工厂方法，返回唯一实例*/ public static Singleton getInstance() &#123; if(instance==null) instance=new Singleton(); return instance; &#125;&#125; 在单例模式的实现过程中，需要注意如下三点：① 单例类的构造函数为私有；② 提供一个自身的静态私有成员变量；③ 提供一个公有的静态工厂方法。 模式优缺点 优点： ① 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。② 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。③ 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。 缺点： ① 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。② 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。③ 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 模式适用环境 ① 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。② 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。③ 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。 模式应用 ① java.lang.Runtime类 12345678public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; /*......*/&#125; ② 数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复。因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。 ③ 默认情况下，Spring会通过单例模式创建bean实例 &lt; bean id=”date” class=”java.util.Date” scope=”singleton” /&gt; 模式扩展 饿汉式单例类： 懒汉式单例类： 饿汉式单例类在自己被加载时就将自己实例化。单从资源利用效率角度来讲，这个比懒汉式单例类稍差些。从速度和反应时间角度来讲，则比懒汉式单例类稍好些。 懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过同步化机制进行控制。 懒汉式单例类 ——&gt; 加锁（synchronized）——&gt; 双重检测锁（Double Checked locking） ——&gt; 使用volatile修饰静态变量（防止指令重排序）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}]},{"title":"设计模式（一）","slug":"设计模式（一）","date":"2018-06-02T02:49:08.000Z","updated":"2019-05-28T01:43:34.356Z","comments":false,"path":"2018/06/02/设计模式（一）/","link":"","permalink":"http://yangliuxiao.top/2018/06/02/设计模式（一）/","excerpt":"","text":"设计模式概述 工厂模式（简单工厂、工厂方法、抽象工厂） 设计模式概述 1. 模式 ① 起源于建筑业 ② 经典定义：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的解决方案，无需再重复相同的工作。 （模式是在特定环境中解决问题的一种方案 ） 2. 软件模式 最早将模式的思想引入软件工程方法学的是1991-1992年以“四人组(Gang of Four，GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”自称的四位著名软件工程学者，他们在1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。 设计模式的定义 设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式的基本要素 设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式 设计模式的分类 ① 根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种 创建型模式主要用于创建对象。 结构型模式主要用于处理类或对象的组合。 行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。 ② 根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种 类模式：处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。 对象模式：处理对象间的关系，这些关系在运行时刻变化，更具动态性。 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式、模板方法模式 对象模式 抽象工厂模式、建造者模式、原型模式、单例模式 （对象）适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式 职责链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式 设计模式的优点 ① 融合了众多专家的经验，提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流，可以降低开发人员理解系统的复杂度。 ② 更加简单方便地复用成功的设计和体系结构，使得重用成功的设计更加容易，并避免那些导致不可重用的设计方案。 ③ 使设计方案更加灵活，且易于修改。 ④ 提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本。 ⑤ 有助于初学者更深入地理解面向对象思想 工厂模式（简单工厂、工厂方法、抽象工厂） 简单工厂模式 模式定义 简单工厂模式又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构 简单工厂模式包含如下角色：Factory（static的工厂角色）、Product（抽象产品角色）、ConcreteProduct（具体产品角色） 模式优缺点 优点： ① 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 ② 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 ③ 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点： ① 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。② 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。③ 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。（违背开闭原则）④ 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。（静态方法不能实现多态） 模式适用环境 ① 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。② 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 模式应用 ① JDK类库中工具类（java.text.DateFormat） 123public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Locale locale); ② Java加密（DESEncrypt.java） 12345/*获取不同加密算法的密钥生成器*/KeyGenerator keyGen=KeyGenerator.getInstance(\"DESede\");/*创建密码器*/Cipher cp=Cipher.getInstance(\"DESede\"); 工厂方法模式 模式定义 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 模式结构 工厂方法模式包含如下角色：Product（抽象产品）、ConcreteProduct（具体产品）、Factory（抽象工厂）、ConcreteFactory（具体工厂） 为了提高系统的可扩展性和灵活性，在定义工厂和产品时都必须使用抽象层，如果需要更换产品类，只需要更换对应的工厂即可，其他代码不需要进行任何修改。 在实际的应用开发中，一般将具体工厂类的实例化过程进行改进，不直接使用new关键字来创建对象，而是将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。 Java反射：是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、超类等信息，还包括实例的创建和实例类型的判断等。可通过Class类的forName()方法返回与带有给定字符串名的类或接口相关联的Class对象，再通过newInstance()方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例。 12345&gt; /*创建一个字符串类型的对象*/&gt; Class c = Class.forName(“String”);&gt; Object obj = c.newInstance();&gt; return obj;&gt; 工具类XMLUtil.java 123456789101112131415161718&gt; /*创建DOM文档对象*/&gt; DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();&gt; DocumentBuilder builder = dFactory.newDocumentBuilder();&gt; Document doc; &gt; doc = builder.parse(new File(\"config.xml\")); /*获取包含类名的文本节点*/NodeList nl = doc.getElementsByTagName(\"className\");Node classNode=nl.item(0).getFirstChild();String cName=classNode.getNodeValue();/*通过类名生成实例对象并将其返回*/Class c=Class.forName(cName);&gt; Object obj=c.newInstance();&gt; return obj;&gt; &gt; 模式优缺点 优点： ① 在工厂方法模式中，工厂方法向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。② 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。③ 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点： ① 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。② 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 模式适用环境 ① 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。② 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。③ 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 模式应用 ① java.util.Collection接口的iterator()方法 ② Java消息服务JMS(Java Messaging Service) ③ JDBC中的工厂方法 1234Connection conn=DriverManager.getConnection(\"jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=\");Statement statement=conn.createStatement();ResultSet rs=statement.executeQuery(\"select * from UserInfo\"); 抽象工厂模式 模式定义 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 模式结构 抽象工厂模式包含如下角色：AbstractFactory（抽象工厂）、ConcreteFactory（具体工厂）、AbstractProduct（抽象产品）、Product（具体产品） 模式优缺点 优点： ① 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。② 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。③ 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点： ① 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。② 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦） 模式适用环境 ① 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。② 系统中有多于一个的产品族，而每次只使用其中某一产品族。③ 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。④ 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 模式应用 ① Java SE AWT（抽象窗口工具包）：在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。 ② 在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}]},{"title":"7个面向对象设计原则","slug":"7个面向对象设计原则","date":"2018-06-02T02:06:28.000Z","updated":"2019-04-24T00:15:29.001Z","comments":false,"path":"2018/06/02/7个面向对象设计原则/","link":"","permalink":"http://yangliuxiao.top/2018/06/02/7个面向对象设计原则/","excerpt":"","text":"面向对象设计原则概述单一职责原则开闭原则里氏代换原则依赖倒转原则接口隔离原则合成复用原则迪米特法则 面向对象设计原则概述软件的复用(Reuse)或重用拥有众多优点，比如可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。面向对象设计复用的目标在于实现支持可维护性的复用。在面向对象的设计里面，可维护性复用都是以面向对象设计原则为基础的，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。 面向对象设计原则和设计模式也是对系统进行合理重构的指南针，重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。 常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 设计原则名称 设计原则简介 重要性 单一职责原则(Single Responsibility Principle, SRP) 类的职责要单一，不能将太多的职责放在一个类中 ★★★★☆ 开闭原则(Open-Closed Principle, OCP) 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能 ★★★★★ 里氏代换原则(Liskov Substitution Principle, LSP) 在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象 ★★★★☆ 依赖倒转原则(Dependency Inversion Principle, DIP) 要针对抽象层编程，而不要针对具体类编程 ★★★★★ 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口来取代一个统一的接口 ★★☆☆☆ 合成复用原则(Composite Reuse Principle, CRP) 在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系 ★★★★☆ 迪米特法则(Law of Demeter, LoD) 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互 ★★★☆☆ 下面详细地介绍这7个原则。 单一职责原则 定义：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。（就一个类而言，应该仅有一个引起它变化的原因。 ） 分析：一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 开闭原则 定义：一个软件实体应当对扩展开放，对修改关闭。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。 分析：抽象化是开闭原则的关键（设立抽象层）。 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation, EVP)要求找到系统的可变因素并将其封装起来。 一般可以通过建立抽象层（里氏代换原则）、从配置文件中读取具体参数、反射机制来达成开闭原则。 里氏代换原则 定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。（所有引用基类（父类）的地方必须能透明地使用其子类的对象。） 分析：里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 依赖倒转原则 定义：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。（要针对接口编程，不要针对实现编程。） 分析：简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。 依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。 “Put Abstractions in Code, Details in Metadata”（将抽象放进代码，将细节放进元数据）—— 《程序员修炼之道：从小工到专家》 依赖注入（如何将具体子类注入到使用抽象基类的方法或类中去）： ① 构造注入(Constructor Injection)：通过构造函数注入实例变量。 ② 设值注入(Setter Injection)：通过Setter方法注入实例变量。 ③ 接口注入(Interface Injection)：通过接口方法注入实例变量。 接口隔离原则 定义：客户端不应该依赖那些它不需要的接口。（一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。） 分析：接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。 合成复用原则 定义：尽量使用对象组合，而不是继承来达到复用的目的。 分析：合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。 继承复用和组合复用的比较： 继承复用：实现简单，易于扩展。但会破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。（“白箱”复用 ） 组合/聚合复用：可以使系统更加灵活，类与类之间的耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ） 迪米特法则 定义：不要和“陌生人”说话（只与你的直接朋友通信）（每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位） 分析：简单地说，迪米特法则就是指一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。 ① 狭义的迪米特法则：可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协调。 ② 广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。 迪米特法则的主要用途在于控制信息的过载： 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及； 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}]},{"title":"UML概述及几种重要的UML图","slug":"UML概述及几种重要的UML图","date":"2018-06-02T01:35:19.000Z","updated":"2019-05-28T01:43:02.323Z","comments":false,"path":"2018/06/02/UML概述及几种重要的UML图/","link":"","permalink":"http://yangliuxiao.top/2018/06/02/UML概述及几种重要的UML图/","excerpt":"","text":"UML的诞生在一个现代化的工程中，人们要相互沟通和合作，就必须使用标准的工业化设计语言，用这些语言来对待开发的产品进行建模。建模过程把复杂的问题分解成为易于理解的小问题，以达到问题的求解。建模是开发优秀软件的所有活动中核心部分之一，其目的是把所要设计的结构和系统的行为联系起来，并对系统的结构进行可视化控制。 从1994年起，Grady Booch和James Rumbaugh在Rational软件公司开始了UML的创建工作。1995年，OOSE方法和Objectory方法的创建者Ivar Jacobson也加入其中。 UML三位创始人正式联手，共同为创建一种标准的建模语言而一起工作，他们将开发出来的产品名称定为UML（Unified Modeling Language，统一建模语言）。 UML的结构UML的13种图都可以归结到以下5类结构中。用户视图1个，结构视图4个，行为视图6个，实现视图1个，环境视图1个。 视图(View) 用户视图(1)：以用户的观点表示系统的目标，它是所有视图的核心，该视图描述系统的需求。结构视图(4)：表示系统的静态行为，描述系统的静态元素，如包、类与对象，以及它们之间的关系。行为视图(6)：表示系统的动态行为，描述系统的组成元素如对象在系统运行时的交互关系。实现视图(1)：表示系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系。环境视图(1)：表示系统中物理元素的分布，描述系统中硬件设备以及它们之间的关系。 13种UML图⑴ 用例图(Use Case Diagram): 又称为用况图，对应于用户视图。在用例图中，使用用例来表示系统的功能需求，用例图用于表示多个外部执行者与系统用例之间以及用例与用例之间的关系。用例图与用例说明文档(Use Case Specification)是常用的需求建模工具，也称之为用例建模。 ⑵ 类图(Class Diagram)：对应于结构视图。类图使用类来描述系统的静态结构，类图包含类和它们之间的关系，它描述系统内所声明的类，但它没有描述系统运行时类的行为。（用例图与类图是UML 13种图中使用频率最高的两种图。） ⑶ 对象图(Object Diagram)：对应于结构视图。对象图是类图在某一时刻的一个实例，用于表示类的对象实例之间的关系。 ⑷ 包图(Package Diagram)：UML2.0新增图，对应于结构视图。包图用于描述包与包之间的关系，包是一种把元素组织到一起的通用机制，如可以将多个类组织成一个包。 ⑸ 组合结构图(Composite Structure Diagram)：UML2.0新增图，对应于结构视图。组合结构图将每一个类放在一个整体中，从类的内部结构来审视一个类。组合结构图可用于表示一个类的内部结构，用于描述一些包含复杂成员或内部类的类结构。 ⑹ 状态图(State Diagram)：对应于行为视图。状态图用来描述一个特定对象的所有可能状态及其引起状态转移的事件。一个状态图包括一系列对象的状态及状态之间的转换。 ⑺ 活动图(Activity Diagram)：对应于行为视图。活动图用来表示系统中各种活动的次序，它的应用非常广泛，既可用来描述用例的工作流程，也可以用来描述类中某个方法的操作行为。 ⑻ 顺序图(Sequence Diagram)：又称为时序图或序列图，对应于行为视图。顺序图用于表示对象之间的交互，重点表示对象之间发送消息的时间顺序。 ⑼ 通信图(Communication Diagram)：在UML1.x中称为协作图，对应于行为视图。通信图展示了一组对象、这些对象间的连接以及它们之间收发的消息。它与顺序图是同构图，也就是它们包含了相同的信息，只是表达方式不同而已，通信图与顺序图可以相互转换。 ⑽ 定时图(Timing Diagram)：UML2.0新增图，对应于行为视图。定时图采用一种带数字刻度的时间轴来精确地描述消息的顺序，而不是像顺序图那样只是指定消息的相对顺序，而且它还允许可视化地表示每条生命线的状态变化，当需要对实时事件进行定义时，定时图可以很好地满足要求。 ⑾ 交互概览图(Interaction Overview Diagram)：UML2.0新增图，对应于行为视图。交互概览图是交互图与活动图的混合物，可以把交互概览图理解为细化的活动图，在其中的活动都通过一些小型的顺序图来表示；也可以将其理解为利用标明控制流的活动图分解过的顺序图。 ⑿ 组件图(Component Diagram)：又称为构件图，对应于实现视图。组件图用于描述每个功能所在的组件位置以及它们之间的关系。 ⒀ 部署图(Deployment Diagram)：又称为实施图，对应于环境视图。部署图用于描述软件中各个组件驻留的硬件位置以及这些硬件之间的交互关系。 通用机制(General mechanism)：UML提供的通用机制为模型元素提供额外的注释、修饰和语义等，主要包括规格说明、修饰、公共分类和扩展机制四种。扩展机制允许用户对UML进行扩展，以便一个特定的方法、过程、组织或用户来使用。 UML的特点：工程化、规范化、可视化、系统化、文档化、智能化 类与类图在UML类图中，类一般由三部分组成： 类名：每个类都必须有一个名字，类名是一个字符串。 属性(Attributes)：属性是指类的性质，即类的成员变量。类可以有任意多个属性，也可以没有属性。 可见性 名称:类型[ = 默认值] 操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，操作是类的成员方法。 类之间的关系 ① 关联关系 关联关系(Association)是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。在UML类图中，用实线连接有关联的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的属性。在使用类图表示关联关系时可以在关联线上标注角色名。 （单向关联、双向关联、自关联、多重性关联（1..1、0..*、1..*、0..1、m..n） 1. 聚合关系(Aggregation)：表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。 在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。 1234567891011&gt; public class Car&gt; &#123;&gt; private Engine engine;&gt; public Car(Engine engine)&gt; &#123;&gt; this.engine = engine;&gt; &#125;&gt; &#125;&gt; public class Engine&gt; &#123;/*……*/&#125;&gt; 2. 组合关系(Composition)：也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在UML中，组合关系用带实心菱形的直线表示。 1234567891011121314&gt; public class Head&gt; &#123;&gt; private Mouth mouth;&gt; public Head()&gt; &#123;&gt; mouth = new Mouth();&gt; &#125;&gt; /*……*/&gt; &#125;public class Mouth&#123;/*……*/&#125;&gt; ② 依赖关系 依赖关系(Dependency)是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 ③ 泛化关系 泛化关系(Generalization)也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的实线来表示。在代码实现时，使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字、在C++/C#中使用冒号“：”来实现。 ④ 接口与实现关系 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangliuxiao.top/tags/笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/tags/设计模式/"},{"name":"UML","slug":"UML","permalink":"http://yangliuxiao.top/tags/UML/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yangliuxiao.top/categories/设计模式/"}]},{"title":"深入理解Java虚拟机（七）","slug":"深入理解Java虚拟机（七）","date":"2018-05-26T08:52:14.000Z","updated":"2019-05-28T01:42:36.163Z","comments":false,"path":"2018/05/26/深入理解Java虚拟机（七）/","link":"","permalink":"http://yangliuxiao.top/2018/05/26/深入理解Java虚拟机（七）/","excerpt":"","text":"Java内存模型与线程 概述多任务和高并发是衡量一台计算机处理器的能力重要指标之一。一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。在讨论Java内存模型和线程之前，先简单介绍一下硬件的效率与一致性。 硬件的效率与一致性需要多任务处理的一个重要原因是计算机的运算速度与它的存储和通信子系统速度的差距太大。所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。 除此之外，为了使得处理器内部的运算单元能被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Recorder）优化。 Java内存模型Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 定义Java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。经过长时间的验证和修补，在JDK1.5发布后，Java内存模型就已经成熟和完善起来了。 Java内存模型的主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。 Java内存模型规定： ① 所有变量都存储在主内存 ② 每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），保存了该线程使用到的变量到主内存副本拷贝 ③线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成： lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则： 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 对volatile型变量的特殊规则volatile可以说是Java虚拟机提供的最轻量级的同步机制。 当一个变量定义为volatile后，它将具备两种特性： ①保证此变量对所有线程的可见性（synchronized和final关键字也能保证可见性） “可见性”指的是当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程传递均需要通过主内存完成。 “可见性”并不能保证基于volatile的变量的运算在并发下是安全的。因为Java里的运算并非原子操作。 由于volatile只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果不依赖变量的当前值，或者确保只有单一的线程修改变量的值（其他线程只读） 变量不需要与其他的状态变量共同参与不变约束 12345678910111213&gt; /*以下这类场景就很适合使用volatile，当shutdown方法被调用时，能保证所有线程中的doWork方法都停止。*/&gt; volatile boolean shutsownRequested;&gt; &gt; public void shutdown()&#123;&gt; shutdownRequested = true;&gt; &#125;&gt; &gt; public void doWork()&#123;&gt; while(!shutdownRequested)&#123;&gt; /* do stuff */&gt; &#125;&gt; &#125;&gt; ② 禁止指令重排序优化 1234567891011121314151617181920Map configOptions;char[] configText;/*此变量必须为volatile*/volatile boolean initialized = false;/*假设以下代码在线程A中执行*//*模拟读取配置信息，读取完成后将initialized改为true以通知其他线程配置可用*/configOptions = new HashMap();configText = readConfigFile(fileName);processCofigOptions(configText, configOptions);initialized = true;/*假设以下代码在线程B中执行*//*等待initialized为true，代表线程A已经把配置信息初始化完成*/while(!initialized)&#123; sleep();&#125;/*使用线程A中初始化好的配置信息*/doSomethingWithConfig(); 如果定义initialized变量时没有使用volatile修饰，就可能因为指令重排序优化，导致线程A中“initialized = true”被提前执行，这样在线程B中使用配置信息就可能出错，而volatile关键字可用避免此类情况发生。 在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型： ① 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 ② 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 ③ 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 3个特性Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 ① 原子性 大致可以认为基本数据类型的访问是具备原子性的（long和double这两个64位长度的存在非原子协定，但几乎不会发生）。除此之外，在synchronized块之间的操作也具备原子性。 ② 可见性 指的是当一条线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。（volatile保证了新值立即同步到主内存，以及每次使用前立即从主内存刷新）。synchronized和final关键字也能保证可见性 ③ 有序性 “如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。” 前半句是指“线程内表现为串行的语义(Within-Thread As-If-Serial Semantics)，后半句是指”指令重排序“和”工作内存和主内存同步延迟“现象。volatile和synchronized关键字都能保证有序性。 可以看到synchronized关键字在3种特性下，都可以作为解决方案，大部分并发控制操作都能使用synchronized关键字完成。但在大多数场景下，volatile的总开销都比锁要低。所以当volatile能解决的场景下，应选择volatile。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"Java编译优化技术","slug":"Java编译优化技术","date":"2018-05-26T08:15:55.000Z","updated":"2019-04-24T00:19:04.184Z","comments":false,"path":"2018/05/26/Java编译优化技术/","link":"","permalink":"http://yangliuxiao.top/2018/05/26/Java编译优化技术/","excerpt":"","text":"Java编译优化技术Java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的共识，除了虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是——虚拟机设计团队把几乎所有的代码优化措施都集中在了即时编译器中，因此一般来说，即时编译器产生的本地代码会比Javac产生的字节码更优秀。 以下代码优化变换建立在代码的某种中间或机器码上，绝不是建立在Java源码之上的，为了展示方便，才使用Java语言的语法来表示这些优化技术。 优化前的原始代码： 12345678910111213static class B&#123; int value; final int get()&#123; return value; &#125;&#125;public void foo()&#123; y = b.get(); /*...do stuff...*/ z = b.get(); sum = y + z;&#125; 1. 方法内联 Method Inlining 方法内联的重要性要高于其他优化措施。它的主要目的有两个：①去除方法调用的成本（如建立栈帧等） ② 为其他优化建立良好基础（方法内联膨胀之后可以便于在更大范围上采取后续的优化手段） 方法内联之后的代码 123456public void foo()&#123; y = b.value; /*...do stuff...*/ z = b.value; sum = y + z;&#125; 2. 冗余访问消除 Redundant Loads Elimination 假如代码中do stuff中所代表的操作不会改变b.value和y的值，就可以把“z = b.value”替换为”z = y”，这样就可以不再去访问对象b的局部变量了。 冗余访问消除后的代码 123456public void foo()&#123; y = b.value; /*...do stuff...*/ z = y; sum = y + z;&#125; 3. 复写传播 Copy Propagation 在这段代码逻辑中没有必要使用一个额外的变量“z”，它与“y”是完全等价的。 复写传播后的代码 123456public void foo()&#123; y = b.value; /*...do stuff...*/ y = y; sum = y + y;&#125; 4. 无用代码消除 Dead Code Elimination 无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码，也被称为“Dead Code” 无用代码消除后的代码 12345public void foo()&#123; y = b.value; /*...do stuff...*/ sum = y + y;&#125; 再介绍以下几项最具代表性的优化技术： 语言无关的经典优化技术之一：公共子表达式消除 语言相关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 5.公共子表达式消除 含义：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式，无需再次计算，用之前的结果代替即可。 举例： int d = (c b) 12 + a + (a + b * c); ⇩（通过JIT编译器，检测到b c 与 c b是一样的表达式，且计算中b与c的值不变） int d = E * 12 + a + (a + E); ⇩（还可能（取决于在哪种VM的编译器上以及具体的上下文而定）进行另一种优化：代数化简 int d = E 13 + a 2; 6. 数组边界检测擦除 Java 是一门动态安全的语言，对数组的访问也不像C、C++本质上是裸指针操作。对开发者来说，可以避免大部分的溢出攻击（运行时错误 ArrayIndexOutOfBoundsException），即使没有编写专门的防御代码。对VM来说，每次数组元素的读写都带有一次隐含的条件判定操作，是一种性能负担。 ①数组下标是常量：编译期根据数据流分析确定length，确定没越界，执行时就无需判断 ②数组访问发生在循环中：判断循环变量的取值范围在 [0,length )之内，就可以把整个循环中的数组上下界检查消除 （相当于把“运行期”检查提到了“编译期”完成） 隐式异常优化： 另外Java中大量的安全检查，如空指针（NullPointException）、除数为零（ArithmeticException），需要Java做大量检查判断——隐式异常处理。Java中空指针和除数为零都采用了这种思路。 比如如下代码： 123456&gt; if(foo != null)&#123;&gt; return foo.value;&gt; &#125;else&#123;&gt; throw new NullPointException();&gt; &#125;&gt; 使用隐式异常优化之后： 123456&gt; try&#123;&gt; return foo.value;&gt; &#125;catch(segment_fault)&#123;&gt; uncommon_trap();&gt; &#125;&gt; 优点：这样当foo不为空时，对value的访问不会额外消耗一次对foo的判空开销 缺点：当foo为空的时候，需要转入异常处理器中恢复并抛出NullPointException异常，开销更大。 7. 逃逸分析 前沿技术，并不直接优化代码，而是为其他优化手段提供依据的分析技术。 逃逸分析的基本行为就是分析对象动态作用域。 方法逃逸：一个对象在方法中被定义，可能被外部方法所引用，例如作为调用参数传递到其他方法中。 线程逃逸：可能被外部线程访问到，例如赋值给类变量或可以在其他线程中访问的实例变量。 若能证明一个对象不会逃逸到方法或线程之外，则可能为这个这个变量进行一些高效的优化。 ①栈上分配：对象分配在栈上，占用的内存可以随栈帧出栈而销毁，减少GC压力。 ②同步消除：既然对象不会逃逸出线程，无法被其他线程访问，则可消除对其的同步措施。 ③标量替换：“标量”是指一个数据已经无法再分解成更小的数据来表示（如Java原始数据类型），与之相对的叫“聚合量”（如对象）。“标量替换”是指程序执行时不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替（成员变量则分配再栈上）。 ”逃逸分析技术尚未成熟“：仍不能保证逃逸分析的性能收益一定高于它的消耗。 Java与C/C++的编译器对比 Java：即时编译器（JIT） C/C++：静态编译器 Java即时编译器的劣势：（这些性能上的劣势都是为了换取开发效率，如“动态安全”、“动态扩展”、“垃圾回收”等） ① JIT占用用户程序的运行时间，具有很大的时间压力，能提供的优化手段也严重受制于编译成本。不敢引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。 ②Java是动态的类型安全语言，需由VM确保程序不会违反语言语义 或访问非结构化内存。（需进行空指针检查、数组边界检查……） ③ 使用虚方法频率远大于C/C++，意味着对方法接收者进行多态选择的频率远大于C/C++。导致“方法内联”难度高。 ④ Java可动态扩展，运行时可改变类的继承关系，进行全局优化难。 ⑤ Java中对象堆上分配，只有方法中局部变量在栈上分配，而C/C++则有多种内存分配方式（栈、堆上都有可能） Java即时编译器的优势： ① 在C/C++中，“别名分析”难度远高于Java ② C/C++的所有优化都在编译器，以运行期性能监控为基础的优化，它都无法进行","categories":[{"name":"Java技术","slug":"Java技术","permalink":"http://yangliuxiao.top/categories/Java技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"Java技术","slug":"Java技术","permalink":"http://yangliuxiao.top/categories/Java技术/"}]},{"title":"深入理解Java虚拟机（六）","slug":"深入理解Java虚拟机（六）","date":"2018-05-26T07:21:35.000Z","updated":"2019-04-24T00:33:08.672Z","comments":false,"path":"2018/05/26/深入理解Java虚拟机（六）/","link":"","permalink":"http://yangliuxiao.top/2018/05/26/深入理解Java虚拟机（六）/","excerpt":"","text":"早期（编译期）优化 晚期（运行期）优化 早期（编译器）优化 Java的“编译器”其实是一段“不确定”的过程，因为它可能指以下三种情况： 前端编译器：把.java转变成 .class字节码文件的过程（包括Javac编译器、Eclipse JDT中的增量式编译器（ECJ） 后端运行期编译器（JIT）：将字节码编译为机器码（包括HotSpot VM的C1、C2编译器） 静态提前编译器（AOT，Ahead Of Time Compiler）：直接把*.java编译为机器码（包括GCJ、Excelsior JET） 在这里提到的“编译器”和“编译期”都指第一类编译过程。 Javac这类编译器对代码的运行效率几乎没有任何优化措施，对性能的优化集中到了后端的即时编译器中。这样可以让不是由Javac产生的class文件也享受到编译器优化带来的好处（与上一章末尾MethodHandle的优点一的理由相同）。 Javac编译器对于Java语言的优化在于编码过程，来改善程序员的编码风格和提高编码效率。——“语法糖” Java中的语法糖 语法糖：指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但更方便程序员使用。 解语法糖：VM运行时不支持这些语法，他们在编译阶段还原回简单的基础语法结构。 ①泛型与类型擦除 泛型是JDK1.5的一项新增特性，它的本质是参数化类型的应用，也就是说所操作的数据类型被指定为一个参数（泛型类、泛型接口、泛型方法）。Java中的泛型只是一种伪泛型。 真实泛型：泛型无论在源码、编译后的中间语言还是运行期的CLR中都是切实存在的，List &lt; int&gt;和List &lt; String&gt; 就是两个不同的类型，它们在运行期生成，有自己的虚方法表和类型数据。这种实现称为类型膨胀，如C#中的泛型。 伪泛型：只在源码中存在，在编译后的字节码文件中就已经替换为原来的原生类型（Row Type裸类型）了，并且在相应的地方插入了强制转型代码，对运行期的Java来说，List &lt; int&gt;和List &lt; String&gt;就是同一个类，所以泛型就是Java中的一颗语法糖。这种实现称为类型擦除。如Java中的泛型。 12345678910&gt; //当泛型遇到重载1&gt; public class GenericTypes&#123;&gt; public static void method(List&lt;String&gt; list)&#123;&gt; System.out.println(\"invoke method(List&lt;String&gt; list)\");&gt; &#125;&gt; public static void method(List&lt;Integer&gt; list)&#123;&gt; System.out.println(\"invoke method(List&lt;Integer&gt; list)\");&gt; &#125;&gt; &#125;&gt; 由于List &lt; String&gt;和List &lt; Integer&gt;在经过Java编译后都被擦除了，变成了一样的原生类型List &lt; E&gt;，两个方法的签名变得一摸一样，所以无法编译执行。 1234567891011121314151617&gt; //当泛型遇到重载2&gt; public class GenericTypes&#123;&gt; public static String method(List&lt;String&gt; list)&#123;&gt; System.out.println(\"invoke method(List&lt;String&gt; list)\");&gt; return \"\";&gt; &#125;&gt; public static int method(List&lt;Integer&gt; list)&#123;&gt; System.out.println(\"invoke method(List&lt;Integer&gt; list)\");&gt; return 1;&gt; &#125;&gt; &gt; public static void main(String[] args)&#123;&gt; method(new ArrayList&lt;String&gt;());&gt; method(new ArrayList&lt;Integer&gt;());&gt; &#125;&gt; &#125;&gt; 执行结果： 123&gt; invoke method(List&lt;String&gt; list)&gt; invoke method(List&lt;Integer&gt; list)&gt; 方法重载要求方法具备不同的特征签名，返回值不包含在方法的特征签名中，故返回值不参与重载选择。 但在Class文件格式中，只要描述符不同的两个方法就可以共存，所以名称和特征签名相同，但返回值不同的两个方法可以合法共存于一个Class中。 所以只能添加2个本不需要的返回值才能完成重载，这样不优雅且存在语义上的混乱。 ② 自动装箱、拆箱与遍历循环 直接看代码。 原始代码： 12345678910&gt; public static void main(String[] args)&#123;&gt; List&lt;Integer&gt; list = Array.asList(1,2,3,4);&gt; /*如果在JDK1.7中，还有另一颗语法糖，可以简写成List&lt;Integer&gt; list = [1,2,3,4]。*/&gt; int sum = 0;&gt; for (int i:list)&#123;&gt; sum += 1;&gt; &#125;&gt; System.out.println(sum);&gt; &#125;&gt; 编译之后再反编译出的代码： 123456789101112131415&gt; public static void main(String[] args)&#123;&gt; List list = Array.asList(new Integer[]&#123;&gt; Integer.valueOf(1),&gt; Integer.valueOf(2),&gt; Integer.valueOf(3),&gt; Integer.valueOf(4), &#125;)&gt; &gt; int sum = 0;&gt; for (Iterator localIterator = list.iterator(); localIterator.hasNext();)&#123;&gt; int i = ((Integer)localIterator.next()).intValue();&gt; sum += 1;&gt; &#125;&gt; System.out.println(sum);&gt; &#125;&gt; 以上代码一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖。 自动装箱、拆箱在编译之后被转换成了对应的包装和还原方法（Integer.valueOf()和Integer.intValue()） 遍历循环则还原成了迭代器的实现（遍历循环需要被遍历的类实现Iterable接口） 变长参数变成了一个数组类型的参数 ③ 条件编译 Java中的条件编译方法是使用条件为一个常量的if语句 12345678&gt; public static void main(String[] agrs)&#123;&gt; if(true)&#123;&gt; System.out.println(\"1\");&gt; &#125; else&#123;&gt; System.out.println(\"2\");&gt; &#125;&gt; &#125;&gt; 编译之后再反编译出的代码： 1234&gt; public static void main(String[] agrs)&#123;&gt; System.out.println(\"1\");&gt; &#125;&gt; 只能使用条件为常量的if语句才能达到上述效果。 如果使用常量与其他带条件判断能力的语句搭配（如while(true)），则可能编译错误（编译报错：Unreachable code） 其他语法糖还有内部类、枚举类、断言语句、对枚举和字符串的switch支持（JDK1.7）、try语句中定义和关闭资源（JDK1.7）等。 晚期（运行期）优化即时编译器：在部分商业Java VM中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码“（Hot Spot Code），为了提高热点代码的执行效率，在运行时，VM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler） ① 解释器与编译器 许多主流的商业VM，都同时包含解释器和编译器。 解释器和编译器各有各的优势。 解释器： 当程序需要迅速启动和执行时，解释器可以立即执行，省去编译的时间 当程序运行环境中内存资源限制较大时，可以节约内存 可作为编译器激进优化时的一个”逃生门“（当激进优化不成立时，可以通过逆优化退回到解释状态继续执行） 编译器： 在程序运行后，把代码编译成本地代码，可以获取更高的执行效率。 内存限制不大时，可编译执行来提升效率。 HotSpot虚拟机内置了两个即时编译器：Client 编译器和Server编译器，简称C1和C2编译器，使用哪个编译器决定于JVM是运行client还是server模式，但是无论使用C1还是C2，都可使用 java -Xmixed命令切换混合模式（默认）、java -Xint切换interpreted解释器模式、java -Xcomp切换compiled编译器模式 解释器可以为编译器收集性能监控信息 HotSpot虚拟机采用分层编译的策略，层数越高，编译程度越高 C1编译速度更快，C2编译质量越高 ②编译对象和触发条件 在运行过程中会被即时编译器编译的“热点代码”有两类： 1 . 被多次调用的方法 2. 被多次执行的程序体（仍以整个方法作为编译对象，这种编译方式因为编译发生在方法执行过程中，因此形象地被称为栈上替换（On Stack Replacement OSR编译），即方法栈帧还在栈上，方法就被替换了） 判断是否是热点代码，是否需要即时编译，这样的行为叫做“热点探测”(Hot Spot Detection)： 基于采样的热点探测：周期性检查方法栈顶，经常出现的即“热点方法”。 ▶优点：实现简单，高效，容易获取方法调用关系（将调用堆栈展开即可）。 ▶缺点：热度确认不精确，容易受到线程阻塞或别的外界因素影响。 基于计数器的热点探测：为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，次数超过一定阈值就认为它是“热点方法”。 ▶优点：精确、严谨 ▶缺点：实现麻烦、不能直接获取到方法的调用关系 HotSpot虚拟机使用的是第二种——基于计数器的热点探测，因此它为每个方法准备了两类计数器：方法调用计数器（统计多次调用的方法）和回边计数器（统计被多次执行的程序体），两个计数器都会设置一个阈值，当计数器超过该阈值就会触发编译，对于第一类热点代码采用的是普通的JIT编译，对于循环体采用的是OSR编译 如果不做任何设置，方法调用统计器统计的并不是方法调用的绝对次数，而是一个相对的执行频率，也就是超过一段时间限度后，若方法调用器仍未达到规定的阈值，则该数量会减半，这个过程称为方法调用计数器热度的衰减。 回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。回边计数器的阈值是通过计算公式计算出来的。对于循环体的场景，如果计数器的和超过阈值后，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。回边计数器没有热点衰减过程，因此统计的是绝对次数 ③ 编译优化技术 见《Java编译优化技术》篇","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"深入理解Java虚拟机（五）","slug":"深入理解Java虚拟机（五）","date":"2018-05-25T12:26:39.000Z","updated":"2019-04-24T00:36:14.875Z","comments":false,"path":"2018/05/25/深入理解Java虚拟机（五）/","link":"","permalink":"http://yangliuxiao.top/2018/05/25/深入理解Java虚拟机（五）/","excerpt":"","text":"运行时栈帧结构 方法调用 虚拟机字节码执行引擎执行引擎是Java虚拟机最核心的组成部分之一，“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别在于： ①物理机：执行引擎直接建立在处理器、硬件、指令集和操作系统层面上的 ②虚拟机：执行引擎由自己实现，可以自行制定指令集与执行引擎的体系结构 字节码文件 —&gt; 虚拟机字节码执行引擎（字节码解析） —&gt; 执行结果 虚拟机字节码执行引擎： Java虚拟机规范中制定了虚拟机字节码执行引擎的统一外观（Facade） 而执行引擎有不同的虚拟机实现，在不同实现中，可能会有解释执行（通过解释器执行）、编译执行（通过即时编译器产生本地代码执行），也可能两者皆备，但从外观上看，所有不同实现的虚拟机执行引擎都是一致的。 运行时栈帧结构 ①栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构 ②是虚拟机运行时数据区中的虚拟机栈的栈元素 ③存储了方法的局部变量表、操作数栈、动态连接、方法返回地址等 ④一个栈帧需要多少内存在编译器已确定，不受运行期影响 ⑤对活动线程来说，在栈顶的栈帧才是有效的（执行引擎的所有字节码指令都只针对当前栈帧进行操作），称为当前栈帧，与这个栈帧相关联的方法称为当前方法。 1. 局部变量表 ①局部表量表用来存储方法参数和方法内定义的局部变量，在编译时，Code属性中的max_local就定义了其最大容量。 ②局部变量表的基本存储单位是变量槽（Variable Slot），Slot的长度和虚拟机相关，但是VM规范指明，每个Slot要满足存储一些基本的数据类型（像int这种32位的数据类型）。对于64位的基本数据类型，虚拟机会以高位对齐的方式分配两个连续地Slot空间 类变量有两次赋初始值的过程，在“准备”阶段会被赋予系统初始值（类型零值），因此，即使在初始化阶段程序员没有为类变量赋值也没有关系。 局部变量定义了但没有赋初始值是不能使用的。 2. 操作数栈 ①操作数栈的最大深度也是编译时确定好的，存于Code属性表中 ②操作数栈的每一个元素可以是任意的Java数据类型，包括long和double，32位占栈容量为1，64位占2 ③当一个方法开始执行的时候，操作数栈是空的，在方法执行的过程中，不断的会有入栈和出栈的操作 ④操作数栈中元素的数据类型必须和当前要执行的字节码指令类型严格匹配，不然会报错 ⑤在概念模型中，栈帧是相互独立的。但在大多VM中，为了减少额外的参数赋值传递，会让上面栈帧的局部变量表共享区域和下面栈帧操作数栈共享区域重叠 ⑥Java虚拟机是基于栈的执行引擎，其中栈就是指操作数栈 3. 动态连接 ①每个栈帧都持有一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接 ②符号引用一部分会在类加载阶段直接化为直接引用，这称为静态解析，另一部分会在运行时进行动态解析 4. 方法返回地址 当一个方法开始执行后，只有两种方式可以退出这个方法。 ① 遇到了任意一个方法返回的字节码指令，这种退出方法的方式称为正常完成出口，正常退出时，调用者的PC计数器的值可以作为返回地址 ② 在方法执行过程中遇到了异常，且异常没有在方法体内得到处理，就会导致方法退出。这种退出方式称为异常完成出口。异常退出时，不会给它的上层调用者产生任何返回值。返回地址通过异常处理器表来确定 5. 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分完全取决于具体的虚拟机实现 方法调用方法调用唯一任务的就是确定调用方法的版本（即调用哪一个方法），不涉及方法内部的运行过程。 Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）。这样做的优点是赋予了Java更强大的动态扩展能力，而缺点是Java方法调用更复杂，Java需要在类加载阶段甚至是运行时才能决定所调用目标方法的直接引用 1. 解析 如果方法在真正运行之前就可以确定调用的版本，并且在运行时是不可变的（“编译器可知，运行期不可变”），则在类加载的解析阶段就会转换为可确定的直接引用，这类方法的调用称为解析。采用这种调用方式的方法一般是静态方法和私有方法，前者与类型直接关联，后者在外部不可被访问，所以都没法重写和改变。 在类加载的时候就把符号引用解析为该方法的直接引用，这些方法可以称为非虚方法：①静态方法 ②私有方法 ③实例构造器 ④父类方法 ⑤final修饰的方法 2. 分派 “多态性”的一些基本体现。如“重载”和“重写”在JVM中怎么实现的。 分派调用可能是静态也可能是动态；根据分派依据的宗量数可分为单分派、多分派。 “解析”与“分派”并不是二选一的排他关系，而是在不同层次上去筛选、确定目标方法的过程。 ①静态分派 123456789101112131415161718192021222324252627282930313233&gt; public class StaticDispatch&#123;&gt; &gt; static abstract class Human&#123;&gt; &#125;&gt; &gt; static class Man extends Human&#123;&gt; &#125;&gt; &gt; static class Woman extends Human&#123;&gt; &#125;&gt; &gt; public void sayHello(Human guy) &#123;&gt; System.out.println(\"hello,guy!\");&gt; &#125;&gt; &gt; public void sayHello(Man man) &#123;&gt; System.out.println(\"hello,gentleman!\");&gt; &#125;&gt; &gt; public void sayHello(Woman woman) &#123;&gt; System.out.println(\"hello,lady!\");&gt; &#125;&gt; &gt; public static void main(String[] agrs) &#123;&gt; Human man = new Man();&gt; Human woman = new Woman();&gt; &gt; StaticDispatcht = new StaticDispatch();&gt; t.sayHello(man);&gt; t.sayHello(woman);&gt; &#125;&gt; &#125;&gt; 运行结果： 123&gt; hello,guy!&gt; hello,guy!&gt; 关于这句创建对象的代码 12&gt; Human man = new Man();&gt; 我们把“Human”称为变量的静态类型（Static Type），或者叫外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type）。 静态类型仅仅在使用时发生变化，变量本身的静态类型不会被改变，并且最终的静态类型在编译期即可知，而实际类型在运行期才可确定，编译器在编译时并不知道一个对象的实际类型是什么。 1234567&gt; //实际类型变化&gt; Human man = new Man();&gt; man = new Woman();&gt; //静态类型变化&gt; t.sayHello((Man) man);&gt; t.sayHello((Woman) man);&gt; 虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的。 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。 静态分派发生在编译阶段。 编译器虽然能确定出方法的重载版本，但很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，其静态类型只能通过语言上的规则去理解和推断。（字面量：比如c.functin(‘a’)、c.function(“H”)、 c.function(100)这样的参数就不确定静态类型） ②动态分派 1234567891011121314151617181920212223242526272829303132&gt; public class DynamicDispatch&#123;&gt; &gt; &gt; static abstract class Human&#123;&gt; protected abstract void sayHello();&gt; &#125;&gt; &gt; static class Man extends Human&#123;&gt; @Override&gt; protected void sayHello() &#123;&gt; System.out.println(\"man say Hello!\");&gt; &#125;&gt; &#125;&gt; &gt; static class Woman extends Human&#123;&gt; @Override&gt; protected void sayHello() &#123;&gt; System.out.println(\"woman say Hello!\");&gt; &#125;&gt; &#125;&gt; &gt; public static void main(String[] agrs) &#123;&gt; Human man = new Man();&gt; Human woman = new Woman();&gt; &gt; man.sayHello();&gt; woman.sayHello();&gt; man = new Woman();&gt; man.sayHello();&gt; &#125;&gt; &#125;&gt; 运行结果： 1234&gt; man say Hello!&gt; woman say Hello!&gt; woman say Hello!&gt; 在运行期根据实际类型确定方法执行版本的过程称为动态分派。动态分派的典型应用是方法重写。 动态分派会调用invokevirtual指令，invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型。 ③ 单分派与多分派 方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派（根据一个宗量对目标方法进行选择）和多分派（根据多个宗量）。 1. 在编译阶段编译器的选择过程（静态分派） 会根据静态类型、方法参数两个宗量进行选择 （静态多分派） 2. 在运行阶段虚拟机的选择过程 （动态分派） 唯一影响选择的因素只有方法接收者的实际类型 （动态单分派）——方法签名已经在编译器确定 综上，目前的Java语言是一门静态多分派、动态单分派的语言（将来也许会改变） 123456789101112131415161718192021222324252627282930313233343536&gt; public class Dispatch&#123;&gt; &gt; &gt; static class QQ&#123;&#125;&gt; &gt; static class _360&#123;&#125;&gt; &gt; public static class Father&#123;&gt; public void hardChoice(QQ arg) &#123;&gt; System.out.println(\"father choose QQ\");&gt; &#125;&gt; &gt; public void hardChoice(_360 arg) &#123;&gt; System.out.println(\"father choose 360\");&gt; &#125;&gt; &#125;&gt; &gt; public static class Son extends Father&#123;&gt; public void hardChoice(QQ arg) &#123;&gt; System.out.println(\"son choose QQ\");&gt; &#125;&gt; &gt; public void hardChoice(_360 arg) &#123;&gt; System.out.println(\"son choose 360\");&gt; &#125;&gt; &#125;&gt; &gt; public static void main(String[] agrs) &#123;&gt; Father f = new Father();&gt; Father s = new Son();&gt; &gt; f.hardChoice(new _360());&gt; s.hardChoice(new QQ());&gt; &#125;&gt; &#125;&gt; 运行结果： 123&gt; father choose 360&gt; son choose QQ&gt; 首先看看编译阶段编译器的选择，也就是静态分派的过程(关于重载)。此时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是_360。此处选择结果最终的产物是产生了两条invokevirtual指令，两条指令的参数分别是指向Father.hardChoice(_360)和Father.hardChoice(QQ)方法的符号引用。因为是根据两个宗量进行分派，所以java语言的静态分派属于多分派类型。 再看看运行阶段虚拟机的选择，也就是动态分派的过程（关于重写），在执行“son.hardChoice(new QQ());”这句代码时，更准确的说，是在执行invokevirtual指令时，由于编译器已经确定了目标方法的签名必须是hardChoice(QQ)，虚拟机此时不会关心传过来的参数类型，也就是此时传过来的实际类型、静态类型都不会对产生任何影响。唯一可以对虚拟机的选择产生影响的就是此方法的接收者的实际类型是Father还是Son。因为只有一个宗量作为依据，所以java语言的动态分派属于单分派。 ④ 分派的优化 由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正的进行如此频繁的搜索。面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（vtable），使用虚方法表索引来代替元数据查找以提高性能。 如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的入口地址是一致的，都指向父类的实现入口。如果子类重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。 ⑤ 动态语言的支持 JDK1.7新增了invokedynamic指令和invoke包来支撑动态语言。 动态语言的一个特征是：变量无类型而变量值才有类型。 invoke包的使用案例： 123456789101112131415161718192021222324&gt; import java.lang.invoke.MethodHandle;&gt; import java.lang.invoke.MethodHandles;&gt; import java.lang.invoke.MethodType;&gt; &gt; public class MethodHandleTest &#123;&gt; &gt; static class ClassA&#123;&gt; public void println(String s) &#123;&gt; System.out.println(\"myPrintln \" + s);&gt; &#125;&gt; &#125;&gt; public static void main(String[] args) throws Throwable &#123;&gt; Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();&gt; getPrintlnMH(obj).invokeExact(\"output\");&gt; &#125;&gt; //MethodHandle可以动态确定方法&gt; private static MethodHandle getPrintlnMH(Object obj) throws NoSuchMethodException, IllegalAccessException &#123;&gt; //MethodType代表方法类型，包括方法的返回值和参数&gt; MethodType methodType = MethodType.methodType(void.class, String.class);&gt; //bindTo用来绑定java方法的第一个隐式this参数&gt; return MethodHandles.lookup().findVirtual(obj.getClass(), \"println\", methodType).bindTo(obj);&gt; &#125;&gt; &#125;&gt; MethodHandle和反射的区别： 反射是在java代码层次模拟方法的调用，而MethodHandle是在字节码层面模拟方法的调用 反射是重量级的，而MethodHandle是轻量级的 MethodHandle可以享有调用类似字节码指令时的虚拟机优化（字节码层面的优化，如方法内联），同时它可以设计成可服务于所有Java虚拟机之上的语言，包括但不限于Java","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"深入理解Java虚拟机（四）","slug":"深入理解Java虚拟机（四）","date":"2018-05-25T11:15:06.000Z","updated":"2019-04-24T00:34:43.711Z","comments":false,"path":"2018/05/25/深入理解Java虚拟机（四）/","link":"","permalink":"http://yangliuxiao.top/2018/05/25/深入理解Java虚拟机（四）/","excerpt":"","text":"Java语言无关性的基石 虚拟机类加载机制 类的生命周期 类的引用场景 类加载的过程 类加载器 类加载器的种类 双亲委派模型 无关性的基石 Sun公司以及其他VM提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，实现了程序的“一次编写，到处运行”。 实现平台、语言无关性的基础是：虚拟机和字节码存储格式 Java VM不和任何语言绑定，只与“Class文件”这种特定的二进制文件格式关联，VM不关心Class文件的来源，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件。 虚拟机类加载机制VM把描述类的数据从Class字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 与在编译时进行连接工作的语言不同，在Java语言里，类型的加载、连接、初始化都是在程序运行期完成的。虽然稍微地增加了性能开销，但提供了高度的灵活性，Java动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如编写一个面向接口的应用程序，等到运行时再指定其实际的实现类；或者通过预定义的和自定义的类加载器，让一个本地的应用程序在运行时从网络或他处加载一个二进制流作为程序代码的一部分（Applet、Jsp、OSGi） 类的生命周期 加载 —&gt; 验证 —&gt; 准备 —&gt; 解析 —&gt; 初始化 —&gt; 使用 —&gt; 卸载 （验证、准备、解析统称为连接） 除了解析阶段，其他阶段都按这个顺序开始（不一定等前一个阶段结束，都一个阶段才开始，通常互相交叉地混合式进行），而解析阶段则不一定，某些情况下可以在初始化之后再开始（Java的运行时绑定，也称为动态绑定或晚期绑定） 类的引用场景 对类进行主动引用 虚拟机规范中规定“有且只有”这5种场景会触发类初始化（而加载、验证、准备自然在此之前开始） ①遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则先初始化。生成这四条指令常见的Java场景是：new关键字实例化对象时、读取或设置类的静态字段时（final修饰、已在编译期放入常量池的静态字段除外）、调用一个类的静态方法时。 ②使用java.lang.reflect包的方法对类进行反射调用的时候，若未初始化，则初始化。 ③当初始化一个类时，发现其父类还未初始化，则先触发其父类的初始化。 接口与类初始化的区别：接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时才会初始化。 ④虚拟机启动时，会先初始化主类（包含main()方法的那个类） ⑤当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄对应的类没有进行过初始化，则先初始化。（没怎么看懂，动态连接的时候发现类未初始化？） 被动引用 除以上5种主动引用的场景外，其他所有引用类的方式都不会触发初始化，称为被动引用。 ①通过子类引用父类的静态字段，不会导致子类初始化。 对于static字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化，而不会触发子类初始化 123456789101112131415161718192021&gt; //父类&gt; public class SuperClass&#123;&gt; static &#123;&gt; System.out.println(\"SuperClass init!\");&gt; &#125;&gt; public static int value = 123;&gt; &#125;&gt; &gt; //子类&gt; public class SubClass extends SuperClass&#123;&gt; static &#123;&gt; System.out.println(\"SubClass init!\");&gt; &#125;&gt; &#125;&gt; &gt; public class NotInitialization &#123;&gt; public static void main(String[] args)&#123;&gt; System.out.println(SubClass.value);&gt; &#125;&gt; &#125;&gt; 输出 123&gt; SuperClass init!&gt; 123&gt; ②通过数组定义来引用类，不会触发此类的初始化 12345&gt; public class NotInitialization &#123;&gt; public static void main(String[] args)&#123;&gt; SuperClass[] s = new SuperClass[10];&gt; &#125;&gt; 运行之后没有输出 SuperClass init！ ③常量在编译阶段会存入调用类的常量池中（编译阶段通过常量传播优化），本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1234567891011121314&gt; public class ConstClass&#123;&gt; static&#123;&gt; System.out.println(\"ConstClass init!\");&gt; &#125;&gt; &gt; public static final String HELLOWORLD = \"hello world\";&gt; &#125;&gt; &gt; public class NotInitialization&#123;&gt; public static void main(String[] args)&#123;&gt; System.out.println(ConstClass.HELLOWORLD);&gt; &#125;&gt; &#125;&gt; 运行之后没有输出 SuperClass init！ 编译阶段，此常量HELLOWORLD的值已经被存储到了NotInitialization类的常量池中，之后NotInitialization对ConstClass.HELLOWORLD的引用实际都被转换为对自身常量池的引用了，也就是说，NotInitialization的Class文件中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。 类加载的过程加载 —&gt; 验证 —&gt; 准备 —&gt; 解析 —&gt; 初始化 —&gt; 使用 —&gt; 卸载 1. 加载 在加载阶段，虚拟机完成以下3件事： ①通过一个类的全限定名来获取定义此类的二进制字节流 ②将字节流代表的静态存储结构转化为方法区的运行时数据结构 ③在内存生成该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 2. 验证 ①目的：验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 ②Java语言本身是安全的，编译器将拒绝编译不安全的行为（访问数组越界……）但Class文件不一定由源代码编译而来，甚至可以直接编写Class文件，所以验证是VM对自身保护的重要工作。 ③验证包括：文件格式验证（是否符合Class文件格式）、元数据验证（语义校验，保证元数据符合Java语言规范）、字节码验证、符号引用验证 3. 准备 ①是正式为类变量（static）分配内存并设置变量初始值阶段，这些变量所使用的内存都将在方法区中进行分配，注意这时候分配的是类变量不是实例变量，实例变量将在对象实例化时与对象一起分配在java堆中 ②初始值是指对应类型的零值（特殊情况：被final修饰的变量，如public static final int value = 123； 则会在准备阶段即赋值123. 数据类型 零值 最大值 最小值 说明 boolean false true false 一位的信息,只作为一种标志来记录 true/false 情况 byte 0 127(2^7-1) -128(-2^7) 8位、有符号的，以二进制补码表示的整数 short 0 32767(2^15-1) -32768(-2^15) 16 位、有符号的以二进制补码表示的整数 char \\u0000 \\uffff(65535) \\u0000(0) 单一的 16 位 Unicode 字符,可以储存任何字符 int 0 2^31-1 -2^31 32位、有符号的以二进制补码表示的整数 float 0.0f 2^128-1 2^-149 单精度、32位、符合IEEE 754标准的浮点数 long 0L -2^63 2^63-1 64 位、有符号的以二进制补码表示的整数 double 0.0d 2^1024-1 2^-1024 双精度、64 位、符合IEEE 754标准的浮点数 4. 解析 ①解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程 ②符号引用是以一组符号来描述所引用的目标，直接引用则是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄 ③解析包括：类或接口的解析，字段解析，类方法解析，接口方法解析 ④同一个符号引用在不同VM翻译出的直接引用一般不同，若有了直接引用，则引用目标必已存在内存中 5. 初始化 ”初始化阶段“是根据程序员通过程序制定的主观计划去初始化类变量和其他资源的过程，即执行类构造器&lt; client &gt;()的过程。&lt; client &gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的 编译器收集的顺序和类中出现的顺序一致，因此静态语句块中只能访问到定义在静态语句块之前的变量，定义在静态语句块之后的变量，在静态语句块中可以赋值，但不能访问 1234567&gt; static &#123;&gt; i = 0; //到这句代码，可以正常编译通过&gt; System.out.println(i); //报错 \"非法向前引用\"&gt; &#125;&gt; &gt; static int i = 1;&gt; 虚拟机保证在子类的&lt; client &gt;()方法执行之前，父类的&lt; client &gt;()方法已经执行完毕，因此父类中定义的静态语句块要优先于子类的变量赋值操作 clinit方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不生成该方法 虚拟机会保证一个类的&lt; client &gt;()方法在多线程环境中被正确的加锁、同步 接口中不能使用静态语句块，但仍有变量初始化的赋值操作，因此也生成&lt; client &gt;()方法，但不需先执行父接口的&lt; client &gt;()，只有用到父接口中定义的变量时，才初始化父接口。另外，接口的实现类在初始化时也不执行接口的&lt; client &gt;()方法 同一类加载器下，一个类型只会初始化一次 类加载器“通过一个类的全限定名称来获取描述此类的二进制字节流”就是类的“加载”阶段。 将这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块即“类加载器” 一个类是由它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性。两个相同限定名的类，经过不同的类加载器加载也是代表两个不同的类，而且Class对象的equals()，isAssignableFrom()，isInstance()等方法返回的结果也会不一致，使用instanceof关键字做对象所属关系判定的结果也会不同。 类加载器的种类 1. 从虚拟机的角度 ①启动类加载器(Bootstrap Classloader)：C++实现的，它是虚拟机的一部分； ②所有其他的类加载器：由Java实现的，独立于虚拟机外部，全部继承自抽象类java.lang.ClassLoader，且用户可以自定义 2. 从开发人员的角度 ① 启动类加载器：负责加载JAVA_HOME/lib目录中的被虚拟机识别的类，无法被Java直接引用，用户在编写自定义的类加载器的时候，如果需要把类加载请求委托给引导类加载器，直接给加载器赋值为null就行 ② 扩展类加载器：负责加载JAVA_HOME/lib/ext目录中的类 ③ 应用程序类加载器：由AppClassLoader实现，一般称为系统类加载器，负责加载用户的ClassPath上说的指定的类，开发者可以直接使用这个类加载器，也是程序中默认使用的类加载器 ④用户自定义的类加载器 优先级：启动类加载器 &gt; 扩展类加载器 &gt; 应用程序类加载器 &gt; 自定义类加载器 双亲委派模型 要求除了顶层启动类加载器外，其余的类加载器都应当有自己的父类加载器，父子关系一般不以继承方式来实现，而是以组合关系来复用父加载器的代码 过程： 如果一个类加载器收到了类加载的请求，它首先不会尝试加载这个类，而是把请求往上委派给父类加载器去完成，每一个层次的类加载器都是如此，直到当父加载器反馈无法加载的时候（它的搜索范围中没有找到所需的类），子加载器才会尝试加载 双亲委派机制的优点：Java类随着它的类加载器一起具备了一种优先级关系，对于那些公用的类来说，都可以委托优先级高的类统一加载（比如可以保证Object类在程序的各种类加载器环境中都是同一个类）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"深入理解Java虚拟机（三）","slug":"深入理解Java虚拟机（三）","date":"2018-05-25T10:40:11.000Z","updated":"2019-04-24T00:34:12.736Z","comments":false,"path":"2018/05/25/深入理解Java虚拟机（三）/","link":"","permalink":"http://yangliuxiao.top/2018/05/25/深入理解Java虚拟机（三）/","excerpt":"","text":"垃圾收集器与内存分配策略垃圾回收简单介绍 几种垃圾收集算法的思路 垃圾收集器 内存分配策略 垃圾回收简单介绍 1. 程序计数器、虚拟机栈、本地方法栈的垃圾回收 程序计数器、VM栈、本地方法栈3个区域随线程而生，随线程而灭，内存分配和回收都具备确定性，不需过多考虑回收的问题。因为方法结束或者线程结束，内存就跟着一起回收了。 2. 判断对象是否“已死”（即不可能再被任何途径使用）的方法 ① 引用计数法 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器值减一；任何时刻计数器为零的对象即为不可能再被使用的。 优点： 实现简单，判定效率高 缺点： 难以解决对象之间相互循环引用的问题 ② 可达性分析算法 通过一系列的称为“GC Roots”的对象作为起始点，以这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference chain）。当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。 可作为GC Roots的对象 虚拟机栈（栈帧中的本地变量表）中引用对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即Native方法，Java Native Interface）引用对象 在JDK1.2之后，Java对引用进行了扩充，分为以下4种 “强引用”：只要存在，则永远不会被回收 “软引用”：将要内存溢出时，列入回收范围进行二次回收 “弱引用”：当GC发生，则回收 “虚引用”：唯一存在目的是在这个对象被回收时返回一个系统通知 3. finalize()方法 即使在可达性分析中不可达的对象，也并非是“非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程。 ① 没有覆盖finalize()方法（Object.finalize()） 在进行可达性分析后发现没有与GC Roots相连的引用链，并被判断为“没有必要执行finalize()方法”，被直接回收。 ② 覆盖了Object.finalize() 在进行可达性分析后发现没有与GC Roots相连的引用链后，被判断有必要执行finalize()方法，那么该对象被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去执行finalize()方法。若执行后，该对象与引用链建立了关联，则第二次标记时会将该对象移出即将回收的集合，否则回收该对象。 缺点： 不鼓励使用这种方法来拯救对象。finalize()不是C/C++中的析构函数，其运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的，try-finally或者其他方式都能做得更好更及时。 4. 对方法区的回收 方法区（HotSpot虚拟机中的永久代）垃圾收集的“性价比”一般比较低，在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的效率远低于此。 方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。 ① 回收废弃常量：无任何对象引用该存在于常量池中的常量 ② 什么样的类是无用的类： 该类的所有实例都已经被回收，即Java堆中不存在该类任何实例 加载该类的ClassLoader已被回收 该类对应的java.lang.Class对象无引用，也无法在任何地方通过反射访问该类的任何方法 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成Jsp以及OSGi这类频繁自定义ClassLoader的场景都需要VM具备类卸载的功能，以保证永久代（方法区）不会溢出。 几种垃圾收集算法的思路 1. 标记-清除算法（最基础） 标记：通过①引用技术②可达性分析 标记出“已死”的对象 清除：回收被标记的对象 不足： ①效率问题：标记、清除两个过程的效率都不高 ②空间问题：会产生大量不连续的内存碎片 2. 复制算法（用以回收新生代） 为了解决效率问题，将可用内存划分为大小相等的两块（这样内存利用率太低，有更好的方法，下面介绍），每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。 优点： 实现简单、运行高效 缺点： 将内存缩小为原来的一半，代价高昂 改进后的复制算法 研究表明，新生代中的对象98%是“朝生夕死”的，所以可以把内存分为一块较大的Eden区（占80%），两块较小的survivor区（各占10%） 每次使用Eden和其中一块survivor区，即只有10%的内存没有被利用 当特殊情况，如GC后，10%的survivor区不够用时（存活下来的对象大于10%）时，由其他内存（老年代）进行分配担保。 3. 标记-整理算法（用以回收老年代） 标记：通过①引用技术②可达性分析 标记出“已死”的对象 整理：所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 4. 分代收集算法 当前商业虚拟机的GC都采用“分代收集”（Generational Collection），这种算法没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般将Java堆分为新生代和老年代，根据各个年代特点采用最适当的收集算法。 新生代：大批对象死去，少量存活——复制算法 老年代：对象存活率高，无额外空间进行分配担保——“标记-清理”算法；“标记-整理”算法 垃圾收集器 Young generation : ①Serial ; ②Parnew ; ③Parallel Scavenge Tenured generation : ①CMS ; ②Serial Old ; ③Parallel Old 没有最好的收集器，只有对具体应用最合适的收集器 1. Serial 收集器 单线程的收集器；Stop the world 优点：简单高效，由于没有线程交互的开销，专心做GC，自然可以获得最高的单线程收集效率 缺点：在它进行GC时，必须暂停其他所有工作线程 2. ParNew收集器 Serial的多线程版本 优点 ①随可用CPU的增加，有利于GC时系统资源的有效利用 ②除Serial之外，只有它能与CMS收集器配合工作 缺点：在单CPU下相较Serial要差，甚至由于线程交互的开销，在2个CPU下都不一定超越Serial。 3. Parallel Scavenge收集器 目的与其他收集器不同，在于达到一个可控制的吞吐量，关注点在于停顿时间短、高吞吐量 停顿时间短：适合需要与用户交互的程序，良好的响应速度能提升用户体验 高吞吐量：可以高效率地利用CPU时间，适合在后台运算而不需太多交互的任务（到底需不需要交互？？） 4. Serial Old收集器 是Serial的老年代版本 单线程收集器 使用“标记-整理”算法 5. Parallel Old收集器 Parallel Scavenge的老年代版本 多线程收集器 “标记-整理” 设计出用以和新生代的Parallel Scavenge配合，否则Parallel Scavenge只能和Serial Old配合（其不能和CMS合作使用），拖累性能 6. CMS收集器（Concurrent Mark Sweep）——“标记-清除” 是一种以获取最短回收停顿时间为目标的收集器 重视服务的响应速度 过程分为4个步骤： ①初始标记（Stop the World）：仅仅标记GC Roots能直接关联到的对象，速度很快 ②并发标记——GC Roots Tracing ③重新标记（Stop the World）：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，第三步的时间大于第一步，远远小于第二步。 ④并发清除 优点：并发收集、低停顿 缺点： ①对CPU资源敏感（需并发） ②无法处理浮动垃圾（在第四步并发清除时产生的垃圾，由于在标记步骤之后产生，无法在当此GC中处理） ③“标记-清除”会产生空间碎片 7. G1收集器（Garbage First） 面向服务端应用的垃圾收集器 特点： ①并行与并发：能充分利用多核、多CPU的硬件优势，缩短Stop-the-World的停顿时间 ②分代收集：虽然不需和其他收集器配合，而是独立管理整个GC堆，但仍采用不同方式处理新对象和大年龄的旧对象以获取更好的收集效果 ③空间整合：基于“标记-整理”和“复制”算法，不会产生空间碎片 ④可预测的停顿 4个步骤： 初始标记（Stop-the-World） 并发标记 最终标记（Stop-the-World） 筛选回收 内存分配策略对象的内存分配，大部分在堆上分配（也可能出现标量替换，栈上分配等编译优化技术） 对象主要分配在新生代的Eden区上，少数情况也可能直接分配在老年代 若启动了本地线程分配缓冲，则按线程优先在TLAB（Thread Local Allocation Buffer）上分配 1. 对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配 GC的种类： ①Minor GC：发生在新生代的GC，非常频繁，回收速度也较快 ②Major GC（一般同时伴随Minor GC）：发生在老年代的GC，会比Minor GC慢十倍以上 ③Full GC：清理整个堆 2. 大对象直接进入老年代 大对象：需要大量连续内存空间的Java对象 要避免“大对象”，经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间 3. 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄（Age）的计数器 对象经过一次Minor GC则“年龄”加一 “年龄”增加到一定程度（默认15），则晋升至老年代 4. 空间分配担保 在发生Minor GC之前，VM会先检查老年代最大可用连续空间是否大于新生代所有对象总空间。若是，则此次Minor GC安全；若否，则查看是否允许担保失败。若允许，则将老年代剩余空间与历次晋升到老年代对象大小平均值相比，若大于，则尝试进行一次有风险的Minor GC；若小于或VM不允许冒险，则Minor GC改为一次Full GC。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"深入理解Java虚拟机（二）","slug":"深入理解Java虚拟机（二）","date":"2018-05-25T10:36:15.000Z","updated":"2019-04-24T00:32:25.812Z","comments":false,"path":"2018/05/25/深入理解Java虚拟机（二）/","link":"","permalink":"http://yangliuxiao.top/2018/05/25/深入理解Java虚拟机（二）/","excerpt":"","text":"对象的创建 对象的内存分布 对象的访问定位 JVM堆栈溢出 对象的创建步骤： 类加载检查 —&gt; 分配内存 —&gt; 分配的内存空间初始化为零值 —&gt; 设置对象头 —&gt; 数据初始化 1. 类加载检查 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。若没有，那必须先执行相应的类加载过程。 2. 分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 内存分配方式 ① “指针碰撞” ：内存绝对规整，即用过的内存放在一边，空闲内存放在一边，分配内存即把作为分界点的指针向空闲方向挪动与对象大小相等的距离即可。 ② “空闲列表”： 内存不规整，已占用的内存和空闲内存交错，VM需维护一个列表，记录可用内存，分配时从内存列表找一块足够大的内存空间。 3. 分配的内存空间初始化为零值 内存分配完成后，虚拟机需将分配到的内存空间都初始化为零值（不包括对象头）——保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用 4. 设置对象头 VM对对象头中的信息进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等。 5. 数据初始化 执行new指令之后会接着执行&lt; init &gt;方法，把对象按照程序员的意愿进行初始化。 对象的内存分布对象在内存中的布局可以分为3块区域：①对象头（Head）②实例数据（Instance Data）③对齐填充（Padding） 1. 对象头：包括两个部分： ①对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程执有的锁、偏向线程ID、偏向时间戳等。 ②类型指针（不一定有）：即对象指向它的类元数据的指针。VM通过这个指针来确定这个对象是哪个类的实例。 2. 实例数据：对象真正存储的有效信息 HotSpot VM 默认的分配策略顺序为long/double、int、short/char、byte/boolean、OOPs（Ordinary Object Points） 父类中定义的变量在子类之前 若CompactField参数为true，则子类中的较短变量也可能插入到父类变量空隙中。 3. 对齐填充：不一定存在，起占位符作用 由于HotSpot VM的自动内存管理系统要求对象起始地址须是8字节的整数倍，所以需要对齐填充区域补全。 对象的访问定位Java程序通过栈上的reference数据来操作堆上的具体对象。 由于reference类型在Java VM规范中只规定了一个指向对象的引用，并没有定义这个引用定位、访问堆中对象的方式，所以具体的对象访问方式也取决于虚拟机实现而定。 1. 使用句柄访问 Java堆中将会划分出一块内存来作为句柄池。 reference数据中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的地址。 优点：reference中存储的是稳定的句柄地址，在对象被移动时，只改变句柄中的实例指针，不改变reference. 2. 使用直接指针访问（HotSopt采用） reference中存储的直接就是对象地址。 而Java堆对象的布局中必须考虑如何放置访问类型数据的相关信息。 优点：速度更快，节省了一次指针定位的时间开销。 JVM堆栈溢出 1. Java堆溢出——OutOfMemoryError 方法：不断创建对象，并保证GC Roots到对象之间有可达路径，以避免垃圾回收。 虚拟机参数： —Xms：堆的最小值 —Xmx：堆的最大值 2. 虚拟机栈和本地方法栈溢出 ①线程请求的栈深度大于虚拟机所允许的最大深度，抛StackOverFlowError. ②虚拟机扩展栈时无法申请到足够的内存空间，抛OutOfMemoryError. 方法： 减少栈容量 定义大量本地变量 建立多线程，为每个线程申请栈区 虚拟机参数： —Xss：栈的最小值 —Xsx：栈的最大值 3. 方法区和运行时常量池溢出 方法区：产生大量的类 运行时常量池：向常量池添加大量常量（String.intern()） 关于String.intern()方法：是一个Native方法，作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象。否则，将此对象包含的字符串添加到常量池中，并返回引用。 123456789101112public class RuntimeConstantPoolOOM&#123; public static void main(String[] args)&#123; public static void main(String[] args)&#123; String str1 = new StringBuilder(\"计算机\").append(\"软件\").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder(\"ja\").append(\"va\").toString(); Ststem.out.println(str2.intern() == str2); &#125; &#125;&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"深入理解Java虚拟机（一）","slug":"深入理解Java虚拟机（一）","date":"2018-05-25T10:35:22.000Z","updated":"2019-04-24T00:36:40.163Z","comments":false,"path":"2018/05/25/深入理解Java虚拟机（一）/","link":"","permalink":"http://yangliuxiao.top/2018/05/25/深入理解Java虚拟机（一）/","excerpt":"","text":"Java的优点 几款重要的JVM 运行时数据区域 Java的优点 摆脱了硬件平台的束缚，“Write once, compile anywhere”. 提供了一个相对安全的内存管理和访问机制。 热点代码检测和运行时编译及优化. 有一套完整的应用程序接口，以及无数的第三方库。 JDK（Java Development Kit）：支持Java程序开发的最小环境，包括Java程序设计语言、Java虚拟机、Java API类库 JRE（Java Runtime Environment）:支持Java程序运行的标准环境，包括Java API 类库中的JavaSE API子集、Java虚拟机 几款重要的JVM 1. Sun Classic(世界上第一款商用Java虚拟机) 只能使用纯解释器方式来执行Java代码（解释器和编译器不能配合工作） 也就是说若要使用编译器执行，则编译器要对每一个方法，每一行代码都进行编译，而无论它们执行的频率是否值得编译。导致无法使用编译优化技术，造成了Java语言很慢的最初印象 2. Exact VM 因使用准确式内存管理（Exact Memory Management）而得名（即VM中可以知道内存中某个位置的数据具体是什么类型） 已经具备现代高性能处理器的雏形，如两级即时编译器、编译器与解释器混合工作模式等。 3. Sun HotSpot VM（目前使用范围最广的Java虚拟机） 准确式内存管理 HotSpot—-热点代码检测技术（通过执行计数器找出具有编译价值的代码） 编译器和解释器恰当地协同工作 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 1. 程序计数器：当前线程所执行的字节码的行号指示器 线程私有（生命周期与线程相同） 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需执行的字节码指令 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 2. Java虚拟机栈 线程私有（生命周期与线程相同） 是Java方法执行的内存模型 每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程 局部变量表 存放基本数据类型（byte、boolean、char、short、int、float、long、double），对象引用（reference类型），returnAddress类型（指向一条字节码指令的地址） 在编译期间完成分配，方法运行期间不会改变大小 当线程请求栈深大于VM允许栈深，报stackOverFlowError错误；当VM栈扩展时无法申请到足够内存，报outOfMemoryError. 3. 本地方法栈. 与虚拟机栈非常相似，区别在于VM栈为VM执行Java方法（也就是字节码）服务，而本地方法栈则为VM使用到的Native方法服务 4. Java堆：对大多数应用来说，Java堆是Java VM所管理的内存中最大的一块。 所有线程共享，在虚拟机启动时创建 唯一的目的就是存放对象实例 是垃圾搜集器管理的主要区域 Java堆可以处于物理上不连续的内存空间中，逻辑是连续的即可 5. 方法区 线程共享 用于存储已被虚拟机加载的类信息（存放Class相关信息：类名、访问修饰符、常量池……）、常量、静态变量、即时编译器编译后的代码等。 不需连续内存，可固定大小也可扩展 对方法区的内存回收目标主要是针对常量池的回收和对类型的卸载 运行时常量池： 是方法区的一部分，Class文件中的常量池（Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。）将在类加载后进入方法区的运行时常量池中存放 相对于Class常量池的两个特征：①Class中的每一部分的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求，而对于运行时常量池，Java虚拟机规范没有做任何细节上的要求。②具备动态性，运行期间也可能将新的常量放入池中。（String.intern()将新的String字符串加入字符串常量池）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://yangliuxiao.top/tags/面试/"},{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/tags/JVM/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://yangliuxiao.top/categories/JVM/"}]},{"title":"Struts2配置文件及相关技术","slug":"Struts2配置文件及相关技术","date":"2017-11-18T05:44:38.000Z","updated":"2019-04-24T00:23:16.235Z","comments":false,"path":"2017/11/18/Struts2配置文件及相关技术/","link":"","permalink":"http://yangliuxiao.top/2017/11/18/Struts2配置文件及相关技术/","excerpt":"","text":"Struts配置文件之web.xml web.xml的主要作用web.xml是Struts 2框架中一个非常重要的配置文件，对Web应用中一些初始信息进行了配置。Struts 2框架要先依赖于过滤器FilterDispatcher来截获Web程序的HTTP请求，FilterDispatcher就在web.xml中进行配置。除了过滤器外，web.xml还可以用来配置&lt; session-config&gt;会话时间、欢迎页、错误页、监听器、控制器等。 web.xml文件中包含了大量的标签元素，这些元素都对应着各自不同的功能。 web.xml文件中可以包含哪些元素是由其对应的Schema文件来定义的。因此，必须在每个web.xml文件的根元素web-app中指定其Schema文件的版本。web.xml文件的Schema文件由Sun公司定义。 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:javaee=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2eehttp://java.sum.com/xml/ns/j2ee/web-app_2_4.xsd\" id=\"WebApp_9\" version=\"2.4\"&gt;/* ......其他需要添加的标签*/&lt;/web-app&gt; web.xml关键元素分析1. welcome-file-list 和welcome-file元素 在访问一个网站时，用户看到的第一个页面就是欢迎页面。通常，欢迎页面都在web.xml中指定。 在web.xml文件中，welcome-file-list 和welcome-file元素是用来指定欢迎页面的。welcome-file-list元素可以包含多个welcome-file元素，每个welcome-file元素指定一个欢迎页面。Tomcat会按顺序查找欢迎页面，a.jsp若不存在则找b.jsp。 12345&lt;welcome-file-list&gt; &lt;!--欢迎页面--&gt; &lt;welcome-file&gt;a.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;b.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 2. filter和filter-mapping元素 filter**元素用于声明一个过滤器，使用该元素可以同时拦截多个请求的URL。 12345678&lt;!--定义Filter--&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!--指定Filter的名字，不能为空--&gt; &lt;!--指定Filter的实现类，此处使用的是Struts2提供的过滤器类--&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt;&lt;/filter&gt; filter-mapping元素用来指定与过滤器关联的URL。上面代码中&lt; url-pattern&gt;&lt; /url-pattern&gt;标签中的“/*”表明该过滤器可以拦截所有的HTTP请求。 123456&lt;!--定义Filter所拦截的URL地址--&gt;&lt;filter-mapping&gt; &lt;!--Filter的名字，该名字必须是filter元素中已声明过的过滤器名字--&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--定义Filter负责拦截的URL地址--&gt;&lt;/filter-mapping&gt; 3. error-page元素error-page元素用来指定错误处理页面。可以通过配置错误码元素error-code以避免用户直接看到原始错误信息。 123456&lt;!--配置异常页--&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;!--指定错误代码--&gt;&lt;!--如果发生HTTP 404错误，则返回location子元素中指定的文件--&gt;&lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 4. listener元素 该元素用来注册监听器类，并使用子元素listener-class指定监听程序的完整限定类名，下面的代码设置了监听器，用于初始化Spring框架。 123456&lt;!--监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 5. session-config元素 该元素用来指定会话过期时间。下面代码表示会话时间超过30分钟，session对象里面存放的值会自动失效。 1234&lt;!--会话时间配置 --&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 6. init-param元素该元素用来定义参数，在web.xml中可以有多个init-param元素。下面的代码使用init-param元素设置了常量。 12345&lt;!--配置常量 --&gt;&lt;init-param&gt;&lt;param-name&gt; struts.i18n.encoding &lt;/param-name&gt;&lt;param-value&gt; UTF-8&lt;/param-value&gt;&lt;/init-param&gt; 200：服务器成功返回网页 404：请求网页不存在 503：服务不可用 403：Forbidden，服务器拒绝请求 408：Request Timeout（请求超时）服务器等候请求时发生超时 413：Request Entity Too Large（请求实体过大） 414：Request-URL Too Long（请求URL过长） 415：Unsupported Media Type（不支持的媒体类型） 416：Requested Range Not Satisfiable（请求范围不符合要求） 500：Internal Server Error（服务器内部错误） 501：Not Implemented（尚未实现）服务器不具备请求的功能。 502：Bad Gateway（错误网关） 503：Service Unavailable（服务不可用，由于超载或维护） 504：Gateway Timeout（网关超时） 505：HTTP Version Not Supported（HTTP版本不受支持） Struts配置文件之struts.properties struts.properties的主要作用struts.properties是Strus 2框架中一个重要的配置文件，程序员可以通过它来管理Struts 2 框架中定义的大量常量。struts.properties文件是一个标准的properties文件，其格式是key-value对，即每个key对应一个value，key表示的是Struts 2框架中的常量，而value则是其常量值。struts.properties文件必须放到Web应用下的类加载路径下才能使用，即WEB-INF/classes路径下。 struts.properties文件的代码片段（key-value对）： 1234### 设置默认编码集为UTF-8struts.i18n.encoding=UTF-8### 设置使用开发模式struts.devMode=true struts.properties关键元素① struts.i18n.encoding：该常量指定了Web应用中的默认编码集。通常，由于使用中文字符集，将其设置为UTF-8。 ② struts.devMode：该常量指定Struts 2是否使用开发模式。当值设为true时，表示使用开发模式，可以在应用程序出错时显示更详细的出错提示。其默认值为false。通常，在开发阶段，建议使用开发模式；当产品发布后，则可将该常量设置为false。 Struts配置文件之struts.xml struts.xml的主要作用struts.xml是Struts 2框架中一个重要的配置文件，其存放路径和struts.properties一样，位于WEB-INF/classes路径下。 struts.xml文件主要用来配置Action和HTTP请求的对应关系，以及配置逻辑视图和物理视图资源的对应关系。但除了这些功能之外，struts.xml文件还有一些额外的功能，如配置常量、导入其他配置文件等。 123456789101112131415&lt;!--必不可少的xml配置--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"\"http://struts.apache.org/dtds/struts-2.0.dtd\"&gt;&lt;!--struts根元素--&gt;&lt;struts&gt; &lt;!--配置包default，命名空间为“/”--&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--配置名为NN的Action，实现类为XXXAction--&gt; &lt;action name=\"NN\" class=\" XXXAction\"&gt; &lt;result&gt;/YY.jsp&lt;/result&gt; &lt;!--返回YY.jsp --&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts.xml关键元素 1. package元素 package元素用来配置包，在Struts 2框架中，包是一个独立的单位，通过name属性来唯一标识包。 属性 说明 name 这是一个必须属性，标识包的名字，以便在其他包中被引用 extends 可选属性，指定该包继承自其他包 namespace 可选属性，指定命名空间，标识此包下的Action的访问路径 abstract 可选属性，指定该包为抽象包 2. action元素 Struts 2框架通过Action对象来处理HTTP请求，该请求的URL地址对应的Action即配置在action元素中。 123&lt;action name=\"userAction\" class=\" com.action.UserAction\"&gt; &lt;result&gt;/user.jsp&lt;/result&gt; &lt;/action&gt; 属性 说明 name 这是一个必须属性，标识Action，指定了该Action所处理请求的URL class 可选属性，指定Action对象对应的实现类 method 可选属性，指定请求Action时调用的方法（默认execute方法） converter 可选属性，指定类型转换器的类 3. result元素 当调用Action方法处理结束返回后，下一步就是使用result元素来设置返回给浏览器的视图。 配置result元素时常需指定name和type两个属性。 name属性对应从Action方法返回的值，“success”为其默认值。type属性指定结果类型，默认的类型是dispatcher。 4. include元素 该元素用来在一个struts.xml配置文件中包含其他的配置文件。通过&lt; include../&gt;标签，可以将Action以模块的方式来加以管理，即将存在相关性的Action放到同一个xml文件中，然后通过在struts.xml文件中配置&lt; include../&gt;标签来将它们组合在一起。使用include元素的struts.xml文件片段如下所示。 1234&lt;struts&gt; &lt;include file=”a.xml”/&gt; &lt;include file=”b.xml”/&gt;&lt;/struts&gt; 需要注意的是，这些模块化的xml文件也必须是标准的Struts 2配置文件，即必须包含头信息以及根元素等。 5. global-results元素 该元素配置包中的全局结果。全局结果的作用范围为包下面所有Action。当一个Action处理用户请求后返回时，会首先在该Action本身的局部结果中进行搜索，如果局部结果中没有对应的结果，则会查找全局结果 Action的动态调用（DMI） Struts 2中提供了包含多个处理逻辑的Action处理方式，即DMI（Dynamic Method Invocation，动态方法调用）。通过动态请求Action对象中的方法，可以实现对某一业务逻辑的处理。DMI处理方式是通过请求Action对象中的一个具体的方法来实现动态的操作。具体说就是，在请求Action的URL地址后加上请求方法字符串，与Action对象中的方法进行匹配。其中，Action对象名称和方法之间用“!”隔开。即如果在struts.xml文件中配置了名为user的Action，为了请求change（）方法，请求方式应表示为“/user!change.action”。 12&lt;a href=\"user\"&gt;hello&lt;/a&gt;&lt;br&gt; /*请求名为user的Action的execute方法*/ &lt;a href=\"user!update.action\"&gt;update&lt;/a&gt;/*请求名为user的Action的update方法*/ Struts之Action类文件 Action类文件是真正实现业务逻辑的文件。 一般的，每个Action类都定义在一个单独的文件中，实现不同的业务逻辑处理可以通过向该Action类中添加不同的方法来实现。因此，Action类文件是Struts 2框架中非常重要的文件。 Action接口和ActionSupport基类Struts 2框架提供了一个Action接口，该接口定义了Struts 2的Action类的实现规范。 在Action接口中定义了5个字符串常量和一个execute()方法。每个Action类都必须包含一个execute()方法，该方法返回一个字符串。而Action接口中定义的5个常量用来统一execute()方法返回的值。 12345678public interface Action&#123;public static final String ERROR=”error”;public static final String SUCCESS=”success”;public static final String INPUT=”input”;public static final String LOGIN=”login”;public static final String NONE=”now”;public String execute() throws Exception; &#125; ActionSupport类实现了Action接口，它是一个默认的Aciton实现类，提供了很多默认方法，包括数据校验方法﹑获取国际化信息方法等。实际应用中，程序员定义的Action类都会继承ActionSupport类而不是实现Action接口，这可以大大简化程序员的编码过程。 Action与Servlet APIStruts 2框架中的Action与Servlet是完全松耦合的，这使得Action类更加方便进行测试。但对于Web应用来说，Servlet API是不可忽略的。 在Struts 2框架中访问Servlet API有如下几种方法。 1．通过ActionContext类访问2．通过特定接口访问3．通过ServletActionContext访问 1．通过ActionContext类访问 1234567ActionContext context = ActionContext.getContext();/*在request域放入键值对*/context.put(\"name\",\"tom\");/*在application域放入键值对*/context.getApplication().put(\"name\",\"tom\");/*在session域放入键值对*/context.getSession().put(\"name\",\"tom\"); 2．通过特定接口访问 ActionContext类虽然可以访问Servlet API，但是无法直接访问到其实例。为了在Action中直接访问Servlet API，可以通过下面几个接口来实现： ServletRequestAware：实现该接口后，可以直接访问HttpServletRequest实例 ServletResponseAware：实现该接口后，可以直接访问HttpServletResponse实例 ServletContextAware：实现该接口后，可以直接访问ServletContext实例 12345678910111213/*使用ServletContextAware在Action中访问ServletContext实例*/public class LoginAction implements Action, ServletContextAware&#123; private ServletContext context; public void setServletContext(ServletContext ctx)&#123; this.context = ctx; &#125; public String execute() throws Exception&#123; /*将(\"user\",\"tom\")放入ActionContext中*/ context.setAttribute(\"user\",\"tom\"); return SUCCESS; &#125;&#125; 3．通过ServletActionContext访问 Struts 2提供了org.apache.struts2.ServletActionContext类，常用方法如下： ① getResponse()：获得HttpServletResponse对象 ② getRequest()：获得HttpServletRequest对象 ③ getServletContext()：获得ServletContext对象 ModelDriven接口 用户在提交HTTP请求时，一般有两种方式，即Get和Post。Get用来获取查询相关信息，即向服务器索取数据，而Post则用来更新信息，即向服务器提交数据。 当使用Post提交数据量较大的时候如果使用Servlet API的方式一一获取，代码就会过于臃肿。Struts 2 提供了ModelDriven接口，对于实现了该接口的Action来说，只需定义相应的Model，Struts 2框架就会自动将用户提交的HTTP信息赋给相应的Model。 12345678910111213141516public class XxxAction extends ActionSupport implements ModelDriven&lt;XXModel&gt;&#123; private static final long serialVersionUID = 1L; private XXModel x = new XXModel(); /*创建要使用的Model对象实例*/ /*getter方法，必须实现*/ public XXmodel getModel()&#123; return x; &#125; public String execute() throws Exception&#123; ActionContext ctx = ActionContext.getContext(); /*得到ActionContext实例*/ ctx.put(\"x\",x);/*将（\"x\",x)放入ActionContext中，就可以在返回页面使用jsp得到x实例*/ return SUCCESS; &#125;&#125; 异常处理 在struts.xml文件中配置异常通常有两种方式：全局异常配置&lt; global-exception-mapping../&gt;和局部异常配置&lt; exception-mapping../&gt;。 12345678910111213141516171819202122&lt;struts&gt; &lt;package name=\"default\"&gt; &lt;!-- 全局结果 --&gt; &lt;global-results&gt; &lt;result name=\"Exception\"&gt;/Exception.jsp&lt;/result&gt; &lt;!-- 返回结果页面Exception.jsp --&gt; &lt;result name=\"SQLException\"&gt;/SQLException.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;!-- 全局异常映射--&gt; &lt;global-exception-mappings&gt; &lt;!-- SQL异常--&gt; &lt;exception-mapping exception=\"java.sql,SQLException\" result=\"SQLException\" /&gt; &lt;!-- 一般异常 --&gt; &lt;exception-mapping exception=\"java.lang.Exception\" result=\"Exception\" /&gt; &lt;/global-exception-mappings&gt; ... &lt;action ...&gt; &lt;exception-mapping exception=\"com.action.SecurityException\" result=\"login\" /&gt; &lt;result name=\"login\"&gt;/loginException.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;/struts&gt; 上面文件配置了三个异常java.sql,SQLException、java.lang.Exception、com.action.SecurityException，其中com.action.SecurityException是局部异常，另外两个是全局异常。","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"MVC基本概念与Struts2概述","slug":"MVC基本概念与Struts2概述","date":"2017-11-18T02:49:22.000Z","updated":"2019-04-24T00:20:58.488Z","comments":false,"path":"2017/11/18/MVC基本概念与Struts2概述/","link":"","permalink":"http://yangliuxiao.top/2017/11/18/MVC基本概念与Struts2概述/","excerpt":"","text":"MVC基本概念MVC将一个应用的输入、处理和输出流程按照Model（模型）、View（视图）和Controller（控制器）三部分进行分离，这样一个应用就可以划分成模型层、视图层和控制层3个层。这三层之间以最少的耦合来协同工作，从而提高了应用系统的可扩展性和可维护性。对于程序员来说，可以更加高效和灵活的完成代码编写。 1．模型层模型层代表的是企业数据和其对应的业务逻辑，它控制着对数据的处理和更新。通常，模型和现实世界对数据的处理非常相似，这就要求程序开发人员对模型的设计与现实世界应基本相近。模型层接受视图层（通过控制层传送到）的请求数据，并返回最终的处理结果，以更新视图层。2．视图层视图层实际上是模型层中的各个模型的具体表现形式。它通过模型得到企业数据，然后再根据需要来显示它们。虽然视图层对数据不做处理，而是将数据直接传送给控制层，但它必须保持着与模型层的数据模型的一致性，即当模型层的数据发生变化时，视图层必须随之变化。3．控制层控制层在MVC结构中连接模型层和视图层，起到了纽带的作用。它将视图层的交互信息进行过滤等处理后，再传送到模型层相应的业务逻辑处理程序进行处理。 MVC特点： 低耦合性。架构分三层，降低了层与层之间的耦合，提高了程序的可扩展性。 一个模型可对应多个视图。可提高代码的可维护性，一旦模型发生变化，方便维护。 模型返回的数据与显示逻辑分离。各层只需负责自己的任务，不用去管其他层的任务。 有利于工程化管理。代码可复用，降低了软件开发周期。 Struts2概述 到目前为止，Struts框架拥有两个主要的版本，分别是Struts 1.x和Struts 2.x版本，它们都是遵循MVC思想的开源框架。 Struts 1是真正意义上的MVC模式，发布后受到了广大程序开发人员的认可。性能高效、松耦合、低侵入永远是开发人员追求的理想状态，而Struts1在这些方面又恰恰存在着不足之处。在这种情况下，全新的Struts2框架应运而生，它弥补了Struts 1框架中存在的缺陷和不足，并且还提供了更加灵活与强大的功能。 要注意的是，Struts 2框架并不是Struts 1的升级版，而是一个全新的框架，在体系结构上与Struts 1也存在着较大的差距。它将Struts技术与WebWork技术完美的结合起来，拥有非常广泛的使用前景。 Struts2工作流程 ① 用户发出一个HttpServletRequest请求 ② 这个请求经过一系列的过滤器Filter来传送。 ③ 调用FilterDispatcher。FilterDispatcher是控制器的核心，它通过询问ActionMapper来确定该请求是否需要调用某个Action。如果需要调用某个Action，则FilterDispatcher就把请求转交给ActionProxy处理。 ④ ActionProxy通过配置管理器Configuration Manager询问框架的配置文件struts.xml，从而找到需要调用的Action类。 ⑤ ActionProxy创建一个ActionInvocation的实例，该实例使用命名模式调用。在Action执行的前后，ActionInvocation实例根据配置文件加载与Action相关的所有拦截器Interceptor。 ⑥ 一旦Action执行完毕，ActionInvocation实例根据struts.xml文件中的配置找到相对应的返回结果，通常是一个JSP或者FreeMarker的模板。 ⑦ 最后，HttpServletResponse响应通过web.xml文件中配置的过滤器返回。 从Struts 2的角度理解MVC 在Struts 2中，模型层对应业务逻辑组件，它通常用于实现业务逻辑及与底层数据库的交互等。视图层对应视图组件，通常是指JSP页面，但也适用于其他视图显示技术，如Velocity或者Excel文档。控制层对应系统核心控制器和业务逻辑控制器。系统核心控制器为Struts 2框架提供的FilterDispatcher，它是一个起过滤作用的类，能根据请求自动调用相应的Action。而业务逻辑控制器是指开发人员自行定义的一系列Action，在Action中负责调用相应的业务逻辑组件来完成处理。 FilterDispatcher——控制层 Action——模型层 Result——视图层 Struts2的开发优势 通过简单、集中的配置来调度动作类，使得配置和修改都非常容易 通过简单统一的表达式语言来访问所有可供访问的数据 提供标准的、强大的验证框架和国际化框架，而且与Strusts的其他特性紧密结合。 强大的标签，可以有效地减少页面代码 良好的Ajax支持。 增加插件简单。 明确的错误报告。 智能的默认设置。很多框架对象都有一个默认的值，无需再设置。 Struts2开发实例 1. 开发准备① Eclipse中部署Tomcat：Window|Preferences ——&gt; Server|Runtime Environments ——&gt; Add ——&gt; 选择已安装的Tomcat版本 ——&gt; Next ——&gt; Browse ——&gt; 选择Tomcat安装目录(…\\apache-tomcat-9.0.14) ——&gt; Finish ② 为Eclipse指定浏览器：Window|Preferences ——&gt; General | Web Browser ——&gt; Use external web browser ——&gt; Default system web browser ——&gt; OK ③ 指定JSP页面的编码方式：Window|Preferences ——&gt; Web|JSP Files ——&gt; Encoding ——&gt; ISO 10646(UTF-8) ——&gt; OK ④ 下载Struts 2开发包：https://struts.apache.org/ 下载最新版本Struts 2 lib（可以只下载Essential Dependencies Only，也可以把All Dependencies都下载下来） （按照教程，最好使用struts2.3版本的，使用Struts2.5会有各种错误） 2. 创建Struts2工程① 创建Dynamic Web Project ② 在项目中部署Struts2开发包：将下载的Struts jar包复制到项目WEB-INF目录下的lib文件夹中（可以将所有jar包都导入，也可以只导入官网给出的最少jar包Essential Dependencies Only） ③ 编写工程配置文件web.xml：在WEB-INF目录下创建web.xml文件。输入以下信息。 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:javaee=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2eehttp://java.sum.com/xml/ns/j2ee/web-app_2_4.xsd\" id=\"WebApp_9\" version=\"2.4\"&gt;&lt;filter&gt;&lt;!-- Filter名称 --&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!--Filter入口 --&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;!-- Filter名称 --&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;!-- 截获的所有URL--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;welcome-file-list&gt; &lt;!-- 开始页面 --&gt;&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;/web-app&gt; ④ 添加struts.properties文件：在项目Java Resources下的src目录下创建struts.properties。输入以下信息。 12&lt;struts.i18n.encoding value=\"UTF-8\"/&gt;/*指定Web应用的默认编码集，相当于调用 HttpServletRequest的setCharacterEncoding方法。*/ ⑤ 编写struts.xml控制器文件：在项目Java Resources下的src目录下创建struts.xml，输入如下信息。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\"&gt;&lt;!--指定struts.xml文件的根元素--&gt;&lt;struts&gt; &lt;!-- 配置包，包名为default，该包继承了Struts 2框架的默认包struts-default--&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--定义名为hello的Action，该Action的处理类为com.action.TestAction，并映射到success.jsp页面 --&gt; &lt;action name=\"hello\" class=\"com.action.TestAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; ⑥ 前端页面index.jsp和success.jsp index.jsp关键语句 1234567&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;body&gt; &lt;!--a标签--&gt; &lt;s:a action=\"hello\"&gt;hello&lt;/s:a&gt;&lt;/body&gt; success.jsp关键语句 12345&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;body&gt; &lt;!--输出helo值--&gt; &lt;s:property value=\"helo\"/&gt;&lt;/body&gt; ⑦ 后台Struts处理程序TestAction.java 12345678910111213141516171819202122package com.action;import com.opensymphony.xwork2.ActionSupport;public class TestAction extends ActionSupport&#123;private static final long serialVersionUID=1L;private String helo; //Action属性//getter方法public String getHelo() &#123; return helo;&#125;//setter方法public void setHelo(String helo) &#123; this.helo = helo;&#125;//重载execute（）方法public String execute() throws Exception &#123; helo=\"hello,world\"; return SUCCESS; &#125;&#125; 3. 运行结果 用户单击index.jsp链接，发送HTTP请求，服务器接收到HTTP请求后，调用web.xml文件中配置的过滤器的具体方法，通过一系列的内部处理机制，它判断出这个HTTP请求和TestAction类所对应的Action对象相匹配，最后调用TestAction对象中的execute()方法，处理后返回相应的值SUCCESS，然后Struts 2通过这个值可查找到对应的页面即success.jsp，最后返回给浏览器。","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"Web的工作机制","slug":"Web的工作机制","date":"2017-11-16T07:40:31.000Z","updated":"2019-04-24T00:25:15.324Z","comments":false,"path":"2017/11/16/Web的工作机制/","link":"","permalink":"http://yangliuxiao.top/2017/11/16/Web的工作机制/","excerpt":"","text":"Web概述万维网是WWW（World Wide Web）的中译名，简称为Web 万维网是一个由许多超文本文档链接起来而形成的系统。系统中有用的事物称为“资源”，资源通过“统一资源标识符”来标识，并通过超文本传输协议（Hypertext Transfer Protocol，HTTP）传送给用户。 万维网的核心标准有三个：URL、HTTP和HTML 1. URL（统一资源定位符）我们在浏览器地址栏输入的网站地址就是URL。统一资源定位符URL用来标识万维网上的各种资源，如文档、图像、声音等，它使用抽象的方法来识别资源的位置，并定位资源。 URL由协议，主机名，路径和文件名三部分组成 HTTP的URL的一般格式为：http: // + host:port + pathURL http: //192.168.0225:8080/abc/index.jsp则表示访问IP地址192.168.0.25的主机中/abc/目录下的index.jsp文件，端口号为8080。 2. HTTP（超文本传输协议）HTTP是一种通信协议，它规定了客户端（浏览器）与服务器之间信息交互的方式。 特点： ① 支持客户端/服务器模式 ② 简单快速 ③ HTTP允许传输任意类型的数据对象 ④ 无连接。每次连接时只处理一个请求，完成后就断开，这样可以节省传输时间 ⑤ 无状态协议。对于事务处理没有记忆功能。如果后面的处理需要使用前面的信息，则需要重传。 3. HTML（超文本标记语言）HTML是一种制作Web网页的标准语言，是一种标记语言。标记也常称为标签，指的就是对浏览器中各元素进行标识的意思。 C/S与B/S软件体系结构 硬件环境方面：C/S结构建立在局域网基础上，B/S建立在广域网基础上。 软件重用性方面：C/S程序的软件重用性往往没有B/S程序好。 系统维护性方面：B/S程序的系统维护性较好。 用户接口方面：B/S表现形式更丰富。 处理问题方面：B/S与操作系统平台的关系较小。 HTTP协议超文本传输协议（HyperText Transfer Protocol）简称HTTP，是互联网应用最广泛的一种网络协议。 在Web浏览器和Web服务器之间的通信，必须按照一定的格式并遵循一定的规则，这些格式和规则就构成了HTTP。 HTTP是通用的、无状态的、面向对象的协议。到目前为止，HTTP的版本有三个，分别是HTTP1.0，HTTP1.1和HTTP-NG。 HTTP消息分为请求消息和响应消息两种。 1. 请求消息HTTP协议的请求主要由三部分组成：请求行，请求报头，请求体。 其中请求报头和请求体的内容是可选的，请求报头和请求体之间需要用空行隔开 请求行 请求报头（内容可选） 请求体（内容可选） ① 请求行 请求行只包含三个内容，方法（Method），请求资源的URI（Request-URI）和HTTP版本（HTTP-Version）。 请求行的格式可以表示为： Method Request-URI HTTP-Version CRLF 其中，CRLF表示回车和换行。 所谓的“Method”可以理解为操作或命令。 HTTP 1.1中规定了14种请求方法(Method)：GET 、POST、HEAD 、PUT、DELETE 、OPTIONS、TRACE 、PATCH、MOVE、COPY、LINK、UNLINK、WRAPPED、Extension-method。 GET：请求读取Request-URI标识的资源。此方法的URL参数传递的数量有限，一般在1KB以下。 POST：请求服务器接受在URI标识资源后附加新数据。传递的参数的数量比GET大得多，一般没有限制。 HEAD：请求获取由Request-URI标识资源的响应消息报头。 PUT：请求服务器保存URI标识的资源。 DELETE：请求服务器删除URI标识的资源。 …… ② 请求报头 请求报头包含客户端传递请求的附加信息及客户端的自身信息。常用的请求报头有Accept和User-Agent。 Accept用于指定客户端所接受的信息类型。常有多个Accept行，例如： Accept : text/html Accept : image/gif 表明客户端可接收图像和HTML文件或文本文件。 User-Agent 用于将发送请求的客户端信息，如客户端的操作系统名称和版本信息、浏览器的名称和版本信息等告知服务器。 HTTP请求举例： 12345GET /index.html HTTP/1.1Accept: text/plain /*纯ASCII码文本文件*/Accept: text/html /*HTML文本文件*/User-Agent:Mozilla/4.5(WinNT) /*指定用户代理*/ /*空行*/ 需要注意的是，使用GET方法的HTTP请求中不能包含实体内容，而使用POST、PUT和DELETE方法的HTTP请求中可以包含实体内容。 GET方法与POST方法 HTTP协议中包含了多种方法，但最常用的是GET和POST方法。注意使用GET方法和POST方法来传递参数时的不同。 使用GET方法时在URL地址后面常常可以附加一些参数，下面是一个使用GET方法的请求行： GET http: //www.java123.org/servlet?param1=abc&amp;param2=def HTTP/1.1 GET方法中对总的字符数是有限制的 用GET发送的数据会追加到URL的后面，而且会在浏览器地址栏显示，所以不适合敏感或者隐私的数据。 在GET方法中，参数会追加到请求URL后面，且以“?”开头。各个参数之间使用“&amp;”分隔。 POST方法将参数放到消息体中，因此不再像GET方法一样受到地址栏中文本太长的限制，而且这些参数并不会直接显示在地址栏上。 使用POST方法发送数据的示例如下： 12345678POST /index.html HTTP/1.1 /*请求行*/HOST:www.javait.com /*存放所请求对象的主机*/User-Agent：Mozilla/4.5（WinNT） /*指定用户代理*/Accept: text/plain /*纯ASCII码文本文件*/Accept-language: zh-cn /*指定可接受语言*/Content-Length: 22Connection : keep-aliveparam1=abc&amp; param2=def /*提交的参数*/ 2.响应消息在接受到一个请求后，服务器会返回一个HTTP响应。HTTP响应由三部分构成，即状态行、响应报头和响应正文。 ① 状态行 状态行由HTTP版本（HTTP-Version）、状态码（Status-Code）以及解释状态码的简单短语（Reason-phrase）三部分构成，其格式如下： HTTP-Version Status-Code Reason-phrase CRLF 状态码由三位数字组成，共有5大类33种，其第一个数字指定了响应类别，取值为1-5，后面两位没有具体的规定。 1xx：指示信息，如请求收到了或正在处理。 2xx：成功 3xx：重定向 4xx：客户端错误，如请求中含有错误的语法或不能正常完成 5xx：服务器端错误，如服务器失效而无法完成请求 举例如下： 200 OK 表示请求成功，成功返回了请求的资源 304 Not Modified 未修改 400 Bad Request 错误请求 404 Not Found 未找到 表示找不到资源，即服务器上不存在浏览器请求的资源。 302/307 表示临时重定向，此时请求的文档已经临时移动到其他位置，该文档新的URL将在Location响应报头中给出。 401 表示浏览器访问的是一个受到密码保护的页面 403 表示服务器受到请求，但拒绝提供服务 500 表示内部服务器错误，即服务器端的CGI、ASP、JSP等程序发生了错误。 503 表示服务器暂时性超载，不能处理当前请求 状态行举例： HTTP 1.0 200 OK HTTP-Version Status-Code Reason-phrase ② 响应报头 有了响应报头服务器就可以传递不能放在状态行中的附加响应信息，以及服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 Allow：指出服务器所支持的请求方法，如GET、POST等方法。 Content-Encoding：指定文档的编码方法 Date：指定发送HTTP消息的日期 …… ③ 响应正文 响应正文是指服务器所返回的资源内容，如HTML页面。响应报头和响应正文之间必须使用空行来分隔。 一个典型的HTTP响应示例如下： 123456789101112HTTP/1.1 200 OK /*状态行*/Connection: close /*连接状态*/Date :Wed, 19 Nov 2011 02:20:45 GMT /*日期*/Server: Apache/2.0.54(Unix) /*服务器*/Content-Length: 397 /*指定数据包含的字节长度*/Content-Type: text/html /*指定返回数据的MIME类型*//*空行*/&lt;html&gt;&lt;body&gt;/*数据*/&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"JavaBean与Servlet","slug":"JavaBean与Servlet","date":"2017-11-14T01:38:57.000Z","updated":"2019-05-28T02:00:10.761Z","comments":false,"path":"2017/11/14/JavaBean与Servlet/","link":"","permalink":"http://yangliuxiao.top/2017/11/14/JavaBean与Servlet/","excerpt":"","text":"JavaBean JavaBean概述JavaBean是用Java语言描述的软件组件模型，类似于Microsoft中COM组件的概念。 使用JavaBean可以实现代码的重复利用，因此极大地简化了程序的设计过程。 JavaBean是一种特殊的Java类，它具有如下的几个语法特征。 JavaBean是一个public类，即JavaBean的类访问权限必须是public的。 JavaBean应该包含一个无参的构造方法。 JavaBean中属性的获取和设置需要使用标准格式定义的getXxx()方法和setXxx()方法。对于boolean类型的成员变量，即布尔类型的属性，可以使用isXxx()方法来代替getXxx()和setXxx()方法。 需要被序列化并且实现了Serializable接口。 在JSP中设置JavaBean属性使用&lt; jsp:useBean&gt;、&lt; jsp:setProperty&gt;以及&lt; jsp:getProperty&gt;来调用JavaBean 着重强调以下&lt; jsp:setProperty&gt;设置属性的几种形式： ① &lt; jsp:setProperty name=”myBean” property=”*” /&gt; property=”“表示*从request对象中将所有与JavaBean属性名字相同的请求参数传递给相应属性的setter方法。 ② &lt; jsp:setProperty name=”myBean” property=”id” /&gt; 表示将request对象中的参数id传入到JavaBean实例myBean的参数id中。 ③ &lt; jsp:setProperty name=”myBean” property=”id” param=”personid”/&gt; 表示将request对象中的参数personid传入到JavaBean实例myBean的参数id中。 ④ &lt; jsp:setProperty name=”myBean” property=”id” value=”123”/&gt; 表示向JavaBean实例myBean的属性id中传入指定的值。 JavaBean实例JavaBean文件（public类、包含无参构造函数、实现Serializable接口、有属性的get、set方法） 12345678910111213141516171819 /* JavaBean实例*/package count;public class counter implements java.io.Serializable&#123; /*count属性，记录请求次数*/ int count = 0; /*无参构造方法 */ public counter()&#123;&#125; /* count属性的get和set方法 */ public int getCount()&#123; count ++; return count; &#125; public void setCount(int count)&#123; this.count = count; &#125;&#125; JSP中使用JavaBean 1234567&lt;body&gt; &lt;!-- 指定JavaBean实例，其相应的生存范围及全限定名 --&gt; &lt;jsp:useBean id=\"countBean\" class=\"count.counter\" scope=\"application\"/&gt; &lt;!-- 使用jsp:getProperty动作指令获得count属性值 --&gt; the number of request is: &lt;jsp:getProperty name=\"countBean\" property=\"count\"/&gt;&lt;br&gt;&lt;/body&gt; Servlet Servlet概述Servlet是在JSP之前推出的，它是一种应用于服务器端的Java程序，可以生成动态的Web页面。事实上，JSP在运行前还需要被编译成Servlet。Servlet运行在服务器端，是由Web服务器负责加载的，是独立于平台和协议的Java应用程序。JSP改变了Servlet提供HTTP服务时候的编程方式。但是内部机制上，每一个JSP都被处理成一个Servlet。Servlet并不限制所使用的协议，但使用最多的协议是HTTP协议。HTTP协议的特点是每次连接只完成一个请求，其处理过程为：建立连接、发送请求、提供服务、发送响应，最后关闭连接。 Servlet的生命周期Servlet运行在Servlet容器中，由容器来管理其生命周期。Servlet的生命周期主要包含4个过程：（1）加载和实例化。（加载Servlet之后，Servlet容器通过Java反射创建Servlet实例）（2）初始化。（实例创建后，容器调用Servlet的init()方法来初始化该Servlet对象)）（3）执行。（4）清理。（destroy()方法） 在Servlet的整个生命周期，其初始化和销毁都只发生一次，service()方法的执行次数取决于Servlet被客户端所访问的次数。","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"JSP相关概念","slug":"JSP相关概念","date":"2017-11-13T09:25:39.000Z","updated":"2019-04-24T00:20:29.993Z","comments":false,"path":"2017/11/13/JSP相关概念/","link":"","permalink":"http://yangliuxiao.top/2017/11/13/JSP相关概念/","excerpt":"","text":"JSP概述1. JSP简介JSP指的是Java Server Pages，它是由SUN公司在1996年6月发布的用于开发动态Web应用的一项技术。 JSP是基于Java Servlet的Web开发技术，由于其所具有的简单易学和跨平台等的特性，使其在各种动态Web程序设计语言中脱颖而出，它具有一套完整的语法规范，目前已经成为了Web开发中的主流选择，广泛应用于各个领域中。 2. JSP的技术特点JSP通过在使用HTML编写的静态网页中添加一些专有标签以及脚本程序来实现网页中动态内容的显示。它具有如下特点： 能够在任何Web或应用程序服务器上运行。（JSP无需重新编译，因为Java字节码是平台无关） 将程序逻辑和页面显示相分离。 采用标签简化页面开发。 组件可重用。 3. JSP的运行机制 当一个JSP文件第一次被请求时，JSP容器会先把该JSP文件转换成一个Servlet。 4. 编写JSP文件12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; My JSP &lt;/body&gt;&lt;/html&gt; 如上内容保存为html文件则双击可直接打开； 若保存为JSP文件，则必须通过发布到JSP容器，如Tomcat中的某个Web应用才能查看显示效果。 例如将jsp复制到&lt; TOMCAT_HOME&gt;\\webapps\\jsptest目录下，打开链接http ://localhost:8080/jsptest/myjsp.jsp 从这个例子可以看出，HTML语言中的元素都可以被JSP容器所解析。实际上，JSP只是在原有HTML文件中加入了一些具有Java特点的代码，称为JSP的语法元素。 JSP基本语法在传统的HTML页面文件中嵌入脚本语言和JSP标签就构成了一个JSP页面文件。一个JSP页面可由5种元素组合而成： ① HTML页面内容② JSP注释③ JSP指令④ JSP脚本元素⑤ JSP动作元素 ①JSP注释JSP中的注释有两种，一种是可以在客户端显示的注释，称为HTML注释，一种是发送到服务器端，在客户端不能显示的注释，称为JSP注释。 HTML注释以&lt; !—开始，以—&gt;结束，中间包含的内容即为注释部分。其形式为： &lt; !—注释内容—&gt; JSP注释以&lt; %—开始，以—%&gt;结束，中间包含的内容即为注释部分。其形式为： &lt;%—注释内容—%&gt; 由于在JSP标签&lt;% %&gt;中包含的是符合Java语法规则的Java代码，所以其中可以出现Java形式的注释。同样不会在浏览器端HTML源代码中显示。 &lt;% // 注释 %&gt; ②JSP指令JSP指令用来向JSP引擎提供编译信息。可以设置全局变量，如声明类、要实现的方法和输出内容的类型等。一般的，JSP指令在整个页面范围内有效，且并不向客户端产生任何输出。所有的JSP指令都只在当前的整个页面中有效。 JSP指令语法格式为： &lt;%@指令标记 [ 属性=”值” 属性=”值” ]%&gt; JSP指令有3类，分别为： page指令 include指令 taglib指令 1. page指令 page指令称为页面指令，用来定义JSP页面的全局属性，该配置会作用于整个JSP页面。page指令用来指定所使用的脚本语言、导入指定的类及软件包等。 page指令的语法格式为： &lt;%@ page 属性1=“属性值1” 属性2=“属性值2”……%&gt; 例如： &lt;%@ page contentType=“text/html;charset=GB2312” import=“java.util.*” %&gt; 也可以是以下这样多条page指令（page指令中只能给import属性指定多个值，而其他属性只能指定一个值） &lt;%@ page contentType=“text/html;charset=GB2312” %&gt; &lt;%@ page import=“java.util. ” , “java.awt.“ %&gt; 2. include指令 include指令是文件加载指令，用于在JSP文件中插入一个包含文本或代码的文件。它把文件插入后与原来的JSP文件合并成一个新的JSP页面。需要注意的是，如果被插入的文件发生了变化，则包含这个文件的JSP文件需要被重新编译。include指令的语法格式为： &lt;%@ include file=”被包含文件的地址”%&gt;include指令只有一个file属性，该属性用来指定插入到JSP页面目前位置的文件资源。被插入的文件可以是一个文本文件、一个HTML文件或一个JSP文件，但要保证被插入的文件必须是可访问的 例如： &lt;%@ include file=”a.txt”%&gt; &lt;%@ include file=”a.html”%&gt; &lt;%@ include file=”a.jsp”%&gt; 3. taglib指令 taglib指令用来引用标签库并设置标签库的前缀。这个指令允许JSP页面使用用户自定义的标签，它也可以为标签库命名，标签在这个库中定义。 taglib指令的语法格式为： &lt;%@ taglib uri=”tagLibraryURI” prefix=”tagPrefix”%&gt;taglib指令包含了两个属性，一个是uri，一个是prefix。其中，uri属性用来指定标签文件或标签库的存放位置，prefix属性则用来指定该标签库所使用的前缀。 比如： 12345678910111213&gt; &lt;%@ page contentType=\"text/html;charset=GB2312\"%&gt;&gt; &lt;%-- 声明要引用的标签库 --%&gt;&gt; &lt;%@ taglib prefix=\"c\" uri=http://java.sun.com/jsp/jstl/core %&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;JSP&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;%-- 使用JSTL标签输出 --%&gt;&gt; &lt;c:out value=\"taglib example! \"&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; ③JSP脚本元素脚本元素是JSP中使用最频繁的元素，通过JSP脚本可以将Java代码嵌入到HTML页面中。所有可执行的Java代码，都可以通过JSP脚本来执行。 JSP脚本元素主要包含如下3种类型： JSP声明语句 JSP表达式 JSP Scriptlet 1. JSP声明语句 JSP声明语句用于声明变量和方法。JSP声明语句的语法格式为： &lt;%! 变量或方法定义 %&gt;注意：变量的类型可以是Java语言中所提供的任意数据类型。使用JSP声明语句声明的变量将来会转换成Servlet类中的成员变量，这些变量在整个JSP页面内都有效，因此也被称为JSP页面的成员变量。下面代码中使用声明语句声明了不同类型的变量： &lt;%! int a=1, b; String str1=null, str2=”JSP”; Date date;%&gt; 声明方法时只需将方法定义放置在”&lt;%! “和” %&gt;”之间即可。使用JSP声明语言声明的方法将来会转换成Servlet类中的成员方法。当方法被调用时，方法内定义的变量被分配内存，调用完毕即释放。 123456789101112131415161718192021222324252627&gt; &lt;%@ page contentType=\"text/html;charset=GB2312\"%&gt;&gt; &gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;title&gt;JSP&lt;/title&gt;&gt; &lt;/head&gt;&gt; &lt;%!&gt; /* 声明整型变量a */&gt; public int a;&gt; /* 声明方法printStr */&gt; public String printStr()&gt; &#123;&gt; return \"JSP Method\";&gt; &#125;&gt; %&gt;&gt; &lt;body&gt;&gt; &lt;%&gt; out.println(\"a=\" + a); /* 输出a值 */&gt; a++ /* a自增 */&gt; %&gt;&gt; &lt;br&gt;&gt; &lt;%&gt; out.println(printString()); /* 调用printStr()方法，输出其返回值&gt; %&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; JSP页面会被编译成Servlet类，而在容器中只会存在一个Servlet类的实例。在JSP中声明的变量是成员变量，它只在创建Servlet实例时被初始化一次，此后，该变量的值将一直被保存，直到该Servlet实例被销毁。 2. JSP表达式 在JSP中可以在“&lt;%=”和“%&gt;”标记之间插入一个表达式，这个表达式必须能够求值，并且计算结果会以字符串形式发送到客户端显示出来。JSP表达式的值会作为HTML页面的内容。（”&lt;%=”是一个符号。=前面不能有空格）如果表达式的值是一个字符串，则该表达式的值会直接在页面上显示处理，否则会先将表达式的值转换为字符串，再在页面上显示。JSP表达式的语法格式为： &lt;%= 表达式 %&gt; 例子： 12345678&gt; &lt;body&gt;&gt; &lt;%! &gt; String str = \"JSP expression\"; /*声明变量*/&gt; %&gt;&gt; &lt;!-- JSP表达式 --&gt;&gt; &lt;%=str%&gt;&gt; &lt;/body&gt;&gt; JSP Scriptlet JSP Scriptlet是一段Java代码段。当需要使用Java实现一些复杂操作或控制时，JSP表达式往往不能满足要求，此时需要用到JSP Scriptlet。在JSP Scriptlet中声明的变量是JSP页面的局部变量，调用JSP Scriptlet时，会为局部变量分配内存空间，调用结束后，释放局部变量占有的内存空间。JSP Scriptlet的语法格式为： &lt;% Java代码%&gt;JSP Scriptlet中可以包含变量、方法、表达式等内容 例子： 1234567&gt; &lt;body&gt;&gt; &lt;%&gt; String str = \"JSP scriptlet\"; /*声明字符串*/&gt; out.println(str); /*输出字符串的值*/&gt; %&gt;&gt; &lt;/body&gt;&gt; ④JSP 动作元素JSP动作元素用来控制JSP的行为，执行一些常用的JSP页面动作。通过动作元素可以使用实现多行Java代码能够实现的效果，如动态插入文件、重用JavaBean组件、自定义标签等。JSP中的动作元素主要包含下面7个： &lt; jsp:include&gt;&lt; jsp:forward&gt;&lt; jsp:param&gt;&lt; jsp:plugin&gt;&lt; jsp:useBean&gt;&lt; jsp:setProperty&gt;&lt; jsp:getProperty&gt; 4.1 &lt; jsp:include&gt; &lt; jsp:include&gt;动作元素提供了一种在JSP中包含页面的方式，既可以包含静态文件，也可以包含动态文件。 所谓的JSP页面动态包含某个文件，指的是当JSP页面运行时才会载入该文件，并不是简单的将被包含文件与JSP页面合并成一个新的JSP页面，JSP与它包含的文件在逻辑上和语法上都是独立的，当被包含的文件变化时，JSP页面运行时可以看到所包含文件变化后的显示结果，无需刷新。（与前文的JSP指令Include的区别，include指令包含的是静态文件） &lt; jsp:include page=”URL” flush=”true|false” /&gt; page：被包含文件的URL，是相对路径 flush：当缓冲区满时，是否将其清空。默认为false 12345678910&gt; /* 例一：包含静态文件 */&gt; &lt;jsp:include page=\"hello.txt\"&gt; &lt;/jsp:include&gt;&gt; &gt; /* 例二：包含动态jsp文件 */&gt; &lt; jsp:include page=\"hello.jsp\"&gt; &lt;/jsp:include&gt;&gt; /* hello.jsp 文件如下 */&gt; &lt;%@ page contentType=\"text/html;charset=GB2312\"%&gt;&gt; &lt;%@ page import=\"java.util.*\" %&gt;&gt; &lt;%= (new Date()).toString() %&gt; /*jsp表达式 */&gt; 4.2 &lt; jsp:forward&gt; &lt; jsp:forward&gt;是一种用于页面重定向的动作元素，它的作用是停止当前JSP页面的执行，而将客户端请求转交给另一个JSP页面。要注意转发与重定向的区别，转发是在服务器端进行的，不会引起客户端的二次请求，因此浏览器的地址栏不会发生任何变化，效率也比重定向要高。 &lt; jsp:forward&gt;的语法格式为： &lt; jsp:forward page=”转向页面的URL地址”/&gt; 在包含&lt; jsp:forward&gt;动作元素的JSP文件中，在&lt; jsp:forward&gt;之前的代码能够被执行，当执行到&lt; jsp:forward&gt;时转向新页面，浏览器中显示的是新页面的执行效果，原jsp文件中位于&lt; jsp:forward&gt;之后的代码不再执行。 4.3 &lt; jsp:param&gt; &lt; jsp:param&gt;是一种提供参数的附属动作元素，它以 “名-值”对的形式为其它动作元素提供附加信息，一般与 &lt; jsp:include &gt;、&lt; jsp:forward&gt;以及&lt; jsp:plugin&gt;联合使用。 &lt; jsp:param&gt;的语法格式为： &lt; jsp:param name= “参数名字” value= “指定给param的参数值”&gt; 123456789101112131415161718192021&gt; /* 与&lt;jsp:include&gt;动作元素一起使用 */&gt; &lt;body&gt;&gt; &lt;jsp:include page=\"sum.jsp\"&gt;&gt; &lt;jsp:param name=\"number\" value=\"200\" /&gt;&gt; &lt;/jsp:include&gt;&gt; &lt;/body&gt;&gt; &gt; /* sum.jsp */&gt; &lt;body&gt;&gt; &lt;%&gt; String str = request.getParameter(\"number\");&gt; int n = Integer.parseInt(str);&gt; int sum = 0;&gt; for(int i=1;i&lt;=n;i++)&#123;&gt; sum +=i;&gt; &#125;&gt; %&gt;&gt; &lt;br&gt;&gt; &lt;%=sum%&gt;&gt; &lt;/body&gt;&gt; 与&lt; jsp:forward&gt;和&lt; jsp:plugin&gt;一起合用也是这样，可以将&lt; jsp:param&gt;包含在&lt; jsp:forward&gt;和&lt; /jsp:forward&gt; 之间，将参数传递给重定向之后的页面，在重定向页面可以通过request.getParameter(“paramName”);获取参数。 4.4 &lt; jsp:plugin&gt; &lt; jsp:plugin&gt;动作元素可以将服务器端的JavaBean或Applet下载到客户端执行。其常用属性的说明如下： type：指定插件类型，是Bean还是Applet。 code：指定执行的Java类名，必须以扩展名.class结尾。 codebase：指定被执行的Java类所在的目录。 name：指定Bean或Applet的名称。 archive：指定在Bean或Applet执行前要预先加载的类的 表。 align：指定Bean或Applet在显示时的对齐方式。 height：指定Bean或Applet显示时的高度。 4.5 &lt; jsp:useBean&gt;、&lt; jsp:setProperty&gt;、&lt; jsp:getProperty&gt;动作元素 这三个动作元素都是与JavaBean相关的。 1. &lt; jsp:useBean&gt;动作元素 用来装载一个将在JSP页面中使用的JavaBean。这个功能非常有用，它充分发挥了Java组件重用的优势，同时也提高了JSP使用的方便性。 &lt; jsp:useBean id=”beanInstanceName” class=”classname” scope=”page | request | session | application” /&gt; page：表示该JavaBean实例在当前页面有效 request：表示该JavaBean实例在本次请求有效 session：在本次session有效 application：在本应用内一直有效 &lt; jsp:useBean&gt;动作元素中常常包含有&lt; jsp:setProperty&gt;，通过&lt; jsp:setProperty&gt;动作元素来设置Bean的属性值。 2. &lt; jsp:setProperty&gt;动作元素 获取到Bean实例之后，便可以利用&lt; jsp:setProperty&gt;动作元素来设置或修改Bean中的属性值。 &lt; jsp:setProperty name=”beanInstanceName“ property=”propertyName“ value=”value“ /&gt; 在使用&lt; jsp:setProperty&gt;之前，必须要使用&lt; jsp:useBean&gt;先声明Bean。 3. &lt; jsp:getProperty&gt;动作元素 用来提取指定Bean属性的值，并将其转换成字符串，然后输出。 &lt; jsp:getProperty name=”beanInstanceName“ property=”propertyName“ /&gt; 在使用&lt; jsp:getProperty&gt;之前，必须要使用&lt; jsp:useBean&gt;创建它。 &lt; jsp:useBean&gt;、&lt; jsp:setProperty&gt;、&lt; jsp:getProperty&gt;一起使用实例： 12345678910111213141516&gt; &lt;body&gt;&gt; &lt;p&gt;输出用户信息：&gt; &lt;br&gt;&gt; &lt;!-- 创建jsp.User的实例，实例名为user --&gt;&gt; &lt;jsp:useBean id=\"user\" class=\"jsp.User\" scope=\"page\" /&gt;&gt; &lt;!-- 设置user的username属性 --&gt;&gt; &lt;jsp:setProperty name=\"user\" property=\"username\" value=\"jack\" /&gt;&gt; &lt;!-- 设置user的age属性 --&gt;&gt; &lt;jsp:setProperty name=\"user\" property=\"age\" value=\"27\" /&gt;&gt; &gt; &lt;!-- 输出 --&gt;&gt; 用户名：&lt;jsp:getProperty name=\"user\" property=\"username\" /&gt;&gt; &lt;br&gt;&gt; 年龄：&lt;jsp:getProperty name=\"user\" property=\"age\" /&gt;&gt; &lt;/body&gt;&gt; JSP内置对象为了简化Web应用程序的开发，在JSP中定义了一些由JSP容器实现和管理的内置对象，这些对象可以直接在JSP页面中使用，而不需要JSP页面编写者对它们进行实例化。JSP 2.0规范中定义了9种内置对象，这9个内置对象都是Servlet API接口的实例，由JSP规范对它们进行了默认初始化，因此，在JSP中它们已经是对象了，可以直接拿来使用。 内置对象名称 相对应的类 作用域 request javax.servelet.ServletRequest request response javax.servelet.ServletResponse page pageContext javax.servelet.jsp.pageContext session session javax.servelet.http.HttpSession page application javax.servelet.ServletContext application out javax.servelet.jsp.JspWriter page config javax.servlet.ServletConfig page page java.lang.Object page exception java.langThrowable page ① request对象 用于获取客户端信息，例如我们在表单中填写的信息等。实际上，JSP容器会将客户端的请求信息封装在request对象中。在客户端发出请求时会创建request对象，在请求结束后，则会销毁request对象。通常在应用中用的最多的就是客户端请求的参数名称和参数值。在request对象中提供了一系列的方法用来获取客户端的请求参数，这些方法包括getParameter、getParameterNames、getParameterValues和getParameterMap。 ② response对象 包含了从JSP页面返回客户端的所有信息，其作用域是它所在的页面page。 response对象是javax.servlet.ServletResponse类的一个实例，它封装由JSP产生的响应，并返回客户端以响应请求。 ③ out对象 out内置对象是一个缓冲的输出流，用来向客户端返回信息。它是javax.servlet.jsp.JspWriter的一个实例。由于向客户端输出时要先进行连接，所以总是采用缓冲输出的方式，因此out是缓冲输出流 ④ session对象 session对象是会话对象，用来记录每个客户端的访问状态。所谓会话指的是从一个客户打开浏览器与服务器建立连接，到这个客户关闭浏览器与服务器断开连接的过程。当一个客户访问服务器时，可能会在这个服务器的多个页面之间反复连接、不断刷新一个页面或向一个页面提交信息等，有了session对象，服务器就可以知道这是同一个客户完成的动作。session对象有session.isNew()、session.getAttribute()、session.getId()等方法。 ⑤ application对象 application对象用于获取和设置Servlet的相关信息，它的生命周期是从服务器启动直到服务器关闭为止，即一旦创建一个application对象，该对象将会一直存在，直到服务器关闭。application中封装了JSP所在的Web应用中的信息。application.getAttribute()、application.setAttribute() ⑥ pageContext对象 pageContext对象是一个比较特殊的对象，使用它不仅可以设置page范围内的属性，还可以设置其它范围内的属性。通过pageContext还可以访问本页面中的所有其他对象，如前面介绍的request、response、out等对象。由于request、response等对象本身已经提供给我们一些方法，可以直接调用这些方法来完成特定的操作，因此在实际JSP开发过程中pageContext对象使用的并不多。 1234/* 设置page范围内的属性 */pageContext.setAttribute(\"attributeName\",\"page_scope\");/* 获得page范围内的属性 */String str = (String)pageContext.getAttribute(\"attributeName\",pageContext.PAGE_SCOPE); ⑦ page对象 page对象指的是当前的JSP页面本身，它是java.lang.Object类的对象，通过page对象可以方便的调用Servlet类中定义的方法。page对象在实际开发过程中并不经常使用。 ⑧ config对象 config对象是ServletConfig类的一个实例，在Servlet初始化时，可以通过config向Servlet传递信息。所传递的信息可以是属性名和属性值构成的名值对，也可以是通过ServletContext对象传递的服务器的相关信息。在JSP开发中config对象用的不多，只有在编写Servlet时当需要重载Servlet的init()方法时才会用到config对象。 ⑨ exception对象 exception对象是java.lang.Throwable类的对象，用来处理页面的错误和异常。在使用JSP进行开发时，习惯的做法是在一个页面中使用page指令的errorPage属性，让该属性指向一个专门用于异常处理的页面。如果在JSP页面中有未捕获的异常，则会生成exception对象，然后将该exception对象传送到page指令中设置的异常处理页面中，在异常处理页面中对exception对象进行处理。在异常处理页面中需要将其page指令的isErrorPage属性设置为true才可以使用exception对象。 123456/* 设置页面的errorPage属性 ，指向一个异常处理页面 */&lt;%@ page contentType=\"text/html;charset=GB2312\" errorPage=\"exceptionObject.jsp\"%&gt;/* 异常处理页面应在page指令中将isErrorPage属性设置为true */&lt;%@ page contentType=\"text/html;charset=GB2312\" isErrorPage=\"true\"%&gt;","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]},{"title":"使用JDBC连接MySQL","slug":"使用JDBC连接MySQL","date":"2017-11-13T08:37:25.000Z","updated":"2019-04-24T00:36:53.292Z","comments":false,"path":"2017/11/13/使用JDBC连接MySQL/","link":"","permalink":"http://yangliuxiao.top/2017/11/13/使用JDBC连接MySQL/","excerpt":"","text":"JDBC简述 Java数据库连接（Java Database connectivity）简称为JDBC，是Java程序与数据库系统通信的标准API，它包含一组用Java语言编写的类和接口。 通过JDBC可以方便的向各种关系数据库发送SQL语句。也就是说，开发人员不需要为访问不同的数据库而编写不同的应用程序，而只需使用JDBC编写一个通用程序就可以向不同的数据库发送SQL调用。 由于Java的平台无关性，使用Java编写的应用程序可以运行在任何支持Java语言的平台上，而无须针对不同平台编写不同的应用程序。将Java和JDBC结合起来操作数据库可以真正实现“一次编写，处处运行”。 使用JDBC连接MySQL数据库步骤 假设MySQL中有book表，有bookid和name两个属性，类型都为String。 ① 调用Class.forName()方法加载相应的数据库驱动程序 1Class.forName(\"com.mysql.jdbc.Driver\"); ② 定义要连接数据库的地址URL，格式为：jdbc：&lt;子协议&gt;：&lt;子名称&gt;。 1String mysqlURL = \"jdbc:mysql://host:port/dbname\"; /*dbName是数据库名*/ ③ 使用驱动程序类建立与数据库的连接。调用DriverManager对象的getConnection()方法，获得一个Connection对象，它表示一个打开的连接。 1Connection conn = DriverManager.getConnection(URL,\"数据库用户名\",\"密码\"); ④ 创建语句对象 12/* Statement用于传递简单的不带参数的SQL语句给数据库管理系统执行 */Statement stmt = conn.createStatement(); 12/* PreparedStatement用于传送带有一个或多个参数的SQL语句 */PreparedStatement psm = conn.prepareStatement(\"INSERT INTO book(bookid, name)VALUES(?,?)\"); 12/* CallableStatement对象用于调用存储过程 validate是存储过程名*/CallableStatement csm = conn.prepareCall(\"&#123;call validate(?,?)&#125;\"); ⑤ 执行语句 Statement接口提供了3个方法执行SQL语句，分别是executeQuery、executeUpdate和execute。 executeQuery：用于执行SQL查询语句，并返回单个结果集，保存在ResultSet对象中。 12String sql = \"SELECT * FROM book\";ResultSel rs = stmt.executeQuery(sql); executeUpdate：可用于执行SQL DML（数据库操纵语句）语句，即INSERT、UPDATE和DELETE语句。此时返回受影响的行数，返回值为一个整数。 也可用于执行SQL DDL（数据库定义语句）语句，如CREATE TABLE、DROP TABLE等，此时返回值为0. execute：既可以执行查询语句，也可以执行更新语句，常用于动态处理类型未知的SQL语句。 ⑥ 对返回的结果集ResultSet对象进行处理 ResultSet对象包含了SQL语句的执行结果，它使用一组get方法实现对结果行中每列数据的访问。使用next方法移动到下一行，使其成为当前行。 12345678String sql = \"SELECT * FROM book\";ResultSel rs = stmt.executeQuery(sql);/* 对结果集进行迭代 显示所有记录的前两列 */while(re.next())&#123; bookid = rs.getString(1); name = rs.getString(2); System.out.println(bookid + \",\" + name);&#125; ⑦ 关闭连接。 操作完成后要关闭所有JDBC对象，以释放资源。包括：关闭结果集、关闭语句对象和连接对象。 123rs.close();stmt.close();conn.close();","categories":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://yangliuxiao.top/tags/代码/"},{"name":"Java","slug":"Java","permalink":"http://yangliuxiao.top/tags/Java/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yangliuxiao.top/tags/Java-Web/"}],"keywords":[{"name":"Java Web开发","slug":"Java-Web开发","permalink":"http://yangliuxiao.top/categories/Java-Web开发/"}]}]}