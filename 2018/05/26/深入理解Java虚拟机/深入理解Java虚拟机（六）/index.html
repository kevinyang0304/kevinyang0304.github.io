<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mute">
  <!-- Open Graph Data -->
  <meta property="og:title" content="深入理解Java虚拟机（六）">
  <meta property="og:description" content="杨柳潇个人主页">
  <meta property="og:site_name" content="杨柳潇的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yangliuxiao.top">
  
    <link rel="alternate" href="/atom.xml" title="杨柳潇的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Site Title -->
  <title>杨柳潇的博客</title>
  
  <!-- 为了增加TOP按钮，新增的CSS文件 -->
  <link rel="stylesheet" href="/css/TOPButtonStyle.css">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/background.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">深入理解Java虚拟机（六）</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kevinyang0304">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/About/index.html">
                  
                  About
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Mute</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-05-26</span>
           <!-- <span class="time">23:09:41</span> -->
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/笔记/">笔记</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Java/">#Java</a> <a class="tag" href="/tags/笔记/">#笔记</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p><a href="#早期（编译期）优化">早期（编译期）优化</a></p>
<p><a href="#晚期（运行期）优化">晚期（运行期）优化</a></p>
<hr>
<h3 id="早期（编译器）优化"><a href="#早期（编译器）优化" class="headerlink" title="早期（编译器）优化"></a>早期（编译器）优化</h3><hr>
<p>Java的“编译器”其实是一段“不确定”的过程，因为它可能指以下三种情况：</p>
<ul>
<li><p><strong>前端编译器</strong>：把<em>.java转变成 </em>.class字节码文件的过程（包括Javac编译器、Eclipse JDT中的增量式编译器（ECJ）</p>
</li>
<li><p><strong>后端运行期编译器</strong>（JIT）：将字节码编译为机器码（包括HotSpot VM的C1、C2编译器）</p>
</li>
<li><p><strong>静态提前编译器</strong>（AOT，Ahead Of Time Compiler）：直接把*.java编译为机器码（包括GCJ、Excelsior JET）</p>
</li>
</ul>
<p><strong>在这里提到的“编译器”和“编译期”都指第一类编译过程。</strong></p>
<p>Javac这类编译器对代码的运行效率几乎没有任何优化措施，<strong>对性能的优化集中到了后端的即时编译器中</strong>。这样可以让不是由Javac产生的class文件也享受到编译器优化带来的好处（与上一章末尾MethodHandle的优点一的理由相同）。</p>
<p><strong>Javac编译器对于Java语言的优化在于编码过程，来改善程序员的编码风格和提高编码效率。——“语法糖”</strong></p>
<hr>
<h4 id="Java中的语法糖"><a href="#Java中的语法糖" class="headerlink" title="Java中的语法糖"></a>Java中的语法糖</h4><ul>
<li><p><strong>语法糖</strong>：指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但更方便程序员使用。</p>
</li>
<li><p><strong>解语法糖</strong>：VM运行时不支持这些语法，他们在<strong>编译阶段</strong>还原回简单的基础语法结构。</p>
<p><strong>①泛型与类型擦除</strong></p>
</li>
</ul>
<blockquote>
<p>泛型是JDK1.5的一项新增特性，它的本质是参数化类型的应用，也就是说所操作的数据类型被指定为一个参数（泛型类、泛型接口、泛型方法）。Java中的泛型只是一种伪泛型。</p>
<ul>
<li><p><strong>真实泛型</strong>：泛型无论在源码、编译后的中间语言还是运行期的CLR中都是切实存在的，List  &lt; int&gt;和List &lt; String&gt; 就是两个不同的类型，它们在运行期生成，有自己的虚方法表和类型数据。这种实现称为<strong>类型膨胀</strong>，如C#中的泛型。</p>
</li>
<li><p><strong>伪泛型：</strong>只在源码中存在，在编译后的字节码文件中就已经替换为原来的原生类型（Row Type裸类型）了，并且在相应的地方插入了<strong>强制转型代码</strong>，对运行期的Java来说，List &lt; int&gt;和List &lt; String&gt;就是同一个类，所以泛型就是Java中的一颗语法糖。这种实现称为<strong>类型擦除</strong>。如Java中的泛型。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//当泛型遇到重载1</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span></span>&#123;</span><br><span class="line">&gt;      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">&gt;          System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">&gt;          System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p><strong>由于List &lt; String&gt;和List &lt; Integer&gt;在经过Java编译后都被擦除了，变成了一样的原生类型List &lt; E&gt;，两个方法的签名变得一摸一样，所以无法编译执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//当泛型遇到重载2</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span></span>&#123;</span><br><span class="line">&gt;      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">&gt;          System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">&gt;          <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">&gt;          System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">&gt;          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&gt;          method(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">&gt;          method(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function">invoke <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function">&gt; invoke <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span></span><br><span class="line"><span class="function">&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>方法重载</strong>要求方法具备不同的特征签名，返回值不包含在方法的特征签名中，<strong>故返回值不参与重载选择。</strong></p>
</li>
<li><p><strong>但在Class文件格式中，只要描述符不同的两个方法就可以共存</strong>，所以名称和特征签名相同，但返回值不同的两个方法可以合法共存于一个Class中。</p>
</li>
<li><p>所以只能添加2个本不需要的返回值才能完成重载，这样不优雅且存在语义上的混乱。</p>
</li>
</ul>
</blockquote>
<p> <strong>② 自动装箱、拆箱与遍历循环</strong></p>
<blockquote>
<p>直接看代码。</p>
<p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&gt;       List&lt;Integer&gt; list = Array.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&gt; <span class="comment">/*如果在JDK1.7中，还有另一颗语法糖，可以简写成List&lt;Integer&gt; list = [1,2,3,4]。*/</span></span><br><span class="line">&gt;       <span class="keyword">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">&gt;       <span class="keyword">for</span> (<span class="keyword">int</span> i:list)&#123;</span><br><span class="line">&gt;           sum += <span class="number">1</span>;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;       System.out.println(sum);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>编译之后再反编译出的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&gt;     List list = Array.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">&gt;         Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">&gt;         Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">&gt;         Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">&gt;         Integer.valueOf(<span class="number">4</span>),    &#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext();)&#123;</span><br><span class="line">&gt;         <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">&gt;         sum += <span class="number">1</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     System.out.println(sum);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>以上代码一共包含了<strong>泛型、自动装箱、自动拆箱、遍历循环与变长参数</strong>5种语法糖。</p>
<ul>
<li><p>自动装箱、拆箱在编译之后被转换成了对应的<strong>包装和还原方法</strong>（Integer.valueOf()和Integer.intValue()）</p>
</li>
<li><p>遍历循环则还原成了迭代器的实现<strong>（遍历循环需要被遍历的类实现Iterable接口）</strong></p>
</li>
<li><p>变长参数变成了一个数组类型的参数 </p>
</li>
</ul>
</blockquote>
<p> <strong>③ 条件编译</strong></p>
<blockquote>
<p>Java中的条件编译方法是<strong>使用条件为一个常量的if语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&gt;     &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"2"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>编译之后再反编译出的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">&gt;     System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>只能使用条件为常量的if语句才能达到上述效果。</p>
<p>如果使用常量与其他带条件判断能力的语句搭配（如while(true)），则可能编译错误（编译报错：Unreachable code）</p>
</blockquote>
<p><strong>其他语法糖还有内部类、枚举类、断言语句、对枚举和字符串的switch支持（JDK1.7）、try语句中定义和关闭资源（JDK1.7）等</strong>。</p>
<hr>
<h3 id="晚期（运行期）优化"><a href="#晚期（运行期）优化" class="headerlink" title="晚期（运行期）优化"></a>晚期（运行期）优化</h3><p><strong>即时编译器：</strong>在部分商业Java VM中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码“（Hot Spot Code），<strong>为了提高热点代码的执行效率，在运行时，VM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化</strong>，完成这个任务的编译器称为即时编译器（Just In Time Compiler）</p>
<p> <strong>① 解释器与编译器</strong></p>
<blockquote>
<p>许多主流的商业VM，都同时包含解释器和编译器。</p>
<p>解释器和编译器各有各的优势。</p>
<p>解释器：</p>
<ol>
<li><p>当程序需要迅速启动和执行时，解释器可以立即执行，省去编译的时间</p>
</li>
<li><p>当程序运行环境中内存资源限制较大时，可以节约内存</p>
</li>
<li><p>可作为编译器激进优化时的一个”逃生门“（当激进优化不成立时，可以通过逆优化退回到解释状态继续执行）</p>
</li>
</ol>
<p>编译器：</p>
<ol>
<li><p>在程序运行后，把代码编译成本地代码，可以获取更高的执行效率。</p>
</li>
<li><p>内存限制不大时，可编译执行来提升效率。</p>
</li>
</ol>
<ul>
<li><p>HotSpot虚拟机内置了两个即时编译器：<strong>Client 编译器和Server编译器，简称C1和C2编译器</strong>，使用哪个编译器决定于JVM是运行client还是server模式，但是无论使用C1还是C2，都可使用 java -Xmixed命令切换混合模式（默认）、java -Xint切换interpreted解释器模式、java -Xcomp切换compiled编译器模式</p>
</li>
<li><p>解释器可以为编译器收集性能监控信息</p>
</li>
<li><p><strong>HotSpot虚拟机采用分层编译的策略，层数越高，编译程度越高</strong></p>
</li>
<li><p><strong>C1编译速度更快，C2编译质量越高</strong></p>
</li>
</ul>
</blockquote>
<p> <strong>②编译对象和触发条件</strong></p>
<blockquote>
<p>在运行过程中会被即时编译器编译的<strong>“热点代码”</strong>有两类：</p>
<blockquote>
<p> <strong>1 . 被多次调用的方法</strong></p>
<p> <strong>2. 被多次执行的程序体</strong>（仍以整个方法作为编译对象，这种编译方式因为编译发生在方法执行过程中，因此形象地被称为<strong>栈上替换（On Stack Replacement OSR编译）</strong>，即方法栈帧还在栈上，方法就被替换了）</p>
</blockquote>
<p>判断是否是热点代码，是否需要即时编译，这样的行为叫做<strong>“热点探测”(Hot Spot Detection)</strong>：</p>
<blockquote>
<ol>
<li><p><strong>基于采样的热点探测</strong>：周期性检查方法栈顶，经常出现的即“热点方法”。</p>
<p><strong>▶优点：</strong>实现简单，高效，容易获取方法调用关系（将调用堆栈展开即可）。</p>
<p><strong>▶缺点：</strong>热度确认不精确，容易受到线程阻塞或别的外界因素影响。</p>
</li>
<li><p><strong>基于计数器的热点探测</strong>：为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，次数超过一定阈值就认为它是“热点方法”。</p>
<p><strong>▶优点：</strong>精确、严谨</p>
<p><strong>▶缺点：</strong>实现麻烦、不能直接获取到方法的调用关系</p>
</li>
</ol>
</blockquote>
<p>HotSpot虚拟机使用的是第二种——<strong>基于计数器的热点探测</strong>，因此它为每个方法准备了两类计数器：<strong>方法调用计数器（统计多次调用的方法）</strong>和<strong>回边计数器（统计被多次执行的程序体）</strong>，两个计数器都会设置一个阈值，当计数器超过该阈值就会触发编译，对于第一类热点代码采用的是普通的JIT编译，对于循环体采用的是OSR编译</p>
<ul>
<li><p>如果不做任何设置，方法调用统计器统计的并不是方法调用的绝对次数，而是一个<strong>相对的执行频率</strong>，也就是超过一段时间限度后，若方法调用器仍未达到规定的阈值，则该数量会减半，这个过程称为<strong>方法调用计数器热度的衰减</strong>。</p>
</li>
<li><p><strong>回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”</strong>。回边计数器的阈值是通过计算公式计算出来的。对于循环体的场景，如果计数器的和超过阈值后，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。回边计数器没有热点衰减过程，因此统计的是绝对次数</p>
</li>
</ul>
<p><img src="图片1.png" alt="图片1"></p>
</blockquote>
<hr>
<p> <strong>③ 编译优化技术</strong></p>
<p>见<a href="/2018/05/26/深入理解Java虚拟机/Java编译优化技术/">《Java编译优化技术》</a>篇</p>

        </div>
      </div>
    </div>
	
	  <span id="back-to-top">
	  <a href="#top"><img src="/img/top3.png"></a>
	</span>
	
  </div>

</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <!-- 
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
		-->
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

