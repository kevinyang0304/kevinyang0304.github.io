<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mute">
  <!-- Open Graph Data -->
  <meta property="og:title" content="设计模式（二）">
  <meta property="og:description" content="杨柳潇个人主页">
  <meta property="og:site_name" content="杨柳潇的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yangliuxiao.top">
  
    <link rel="alternate" href="/atom.xml" title="杨柳潇的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Site Title -->
  <title>杨柳潇的博客</title>
  
  <!-- 为了增加TOP按钮，新增的CSS文件 -->
  <link rel="stylesheet" href="/css/TOPButtonStyle.css">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/background.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">设计模式（二）</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kevinyang0304">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kevinyang0304">
                  
                  Whoami
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Mute</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-06-02</span>
           <!-- <span class="time">15:06:01</span> -->
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/笔记/">笔记</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/笔记/">#笔记</a> <a class="tag" href="/tags/设计模式/">#设计模式</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p><a href="#建造者模式">建造者模式</a></p>
<p><a href="#原型模式">原型模式</a></p>
<p><a href="#单例模式">单例模式</a></p>
<hr>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><hr>
<ul>
<li><strong>模式定义</strong></li>
</ul>
<p><strong>建造者模式</strong>(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于<strong>对象创建型</strong>模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p>
<ul>
<li><strong>模式结构</strong></li>
</ul>
<p><img src="images\图片1.png" alt="images\图片1"></p>
<p>建造者模式包含如下角色：Builder（抽象建造者）、ConcreteBuilder（具体建造者）、Director（指挥者）、Product（产品角色）</p>
<p>建造者模式的结构中还引入了一个<strong>指挥者类Director</strong>，该类的<strong>作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。</strong>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*客户端代码*/</span></span><br><span class="line">Builder builder = <span class="keyword">new</span> ConcreteBuilder();Director director = <span class="keyword">new</span> Director(builder);Product product = director.construct();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>模式优缺点</strong></li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<p>① 在建造者模式中，客户端不必知道产品内部组成的细节，<strong>将产品本身与产品的创建过程解耦</strong>，使得相同的创建过程可以创建不同的产品对象。<br>② 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。<br>③ 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，<strong>使得创建过程更加清晰</strong>，也更方便使用程序来控制创建过程。<br>④ 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，<strong>系统扩展方便，符合“开闭原则”</strong>。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>① 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。<br>② 如果产品的<strong>内部变化复杂</strong>，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
</blockquote>
<ul>
<li><strong>模式适用环境</strong></li>
</ul>
<p>① 需要生成的产品对象有<strong>复杂的内部结构</strong>，这些产品对象通常包含多个成员属性。<br>② 需要生成的产品对象的属性相互依赖，<strong>需要指定其生成顺序</strong>。<br>③ 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。<br>④ 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>
<ul>
<li><strong>模式应用</strong></li>
</ul>
<p>① <strong>JavaMail</strong>（一步一步构造一个完整的邮件对象，然后发送）</p>
<p>②  在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，<strong>通过不同的具体建造者创建不同类型的地图或人物</strong>。 </p>
<hr>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><hr>
<ul>
<li><strong>模式定义</strong></li>
</ul>
<p><strong>原型模式</strong>(Prototype Pattern)：原型模式是一种<strong>对象创建型</strong>模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。</p>
<p>原型模式的<strong>基本工作原理</strong>是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程。</p>
<ul>
<li><strong>模式结构</strong></li>
</ul>
<p><img src="images\图片2.png" alt="images\图片2"></p>
<p>原型模式包含如下角色：Prototype（抽象原型类）、ConcretePrototype（具体原型类）、Client（客户类）</p>
<p>通常情况下，一个类包含一些成员对象，<strong>在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆和浅克隆。</strong></p>
<p><img src="images\图片3.png" alt="images\图片3"></p>
<p>Java语言提供的clone()方法将对象复制了一份并返回给调用者。一般而言，clone()方法满足： </p>
<blockquote>
<p>(1) 对任何的对象x，都有<strong>x.clone() !=x</strong>，即克隆对象与原对象不是同一个对象。<br>(2) 对任何的对象x，都有<strong>x.clone().getClass()==x.getClass()</strong>，即克隆对象与原对象的类型一样。<br>(3) 如果对象x的equals()方法定义恰当，那么<strong>x.clone().equals(x)</strong>应该成立。</p>
</blockquote>
<ul>
<li><strong>模式优缺点</strong></li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<p>① 当创建新的对象实例较为复杂时，使用原型模式可以<strong>简化对象的创建过程</strong>，通过一个已有实例可以提高新实例的创建效率。<br>② 可以动态增加或减少产品类。<br>③ 原型模式提供了简化的创建结构。<br>④ 可以使用深克隆的方式保存对象的状态。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>① 需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但<strong>对已有的类进行改造时</strong>，不一定是件容易的事，必须修改其源代码，<strong>违背了“开闭原则”</strong>。<br>② 在实现<strong>深克隆</strong>时需要编写较为复杂的代码。</p>
</blockquote>
<ul>
<li><strong>模式适用环境</strong></li>
</ul>
<p>① <strong>创建新对象成本较大</strong>，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改。<br>② 如果<strong>系统要保存对象的状态</strong>，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。<br>③ 需要<strong>避免使用分层次的工厂类来创建分层次的对象</strong>，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>
<ul>
<li><strong>模式应用</strong></li>
</ul>
<p>① 复制(Ctrl + C)和粘贴(Ctrl + V)操作</p>
<p>② 在<strong>Struts2</strong>中为了保证线程的安全性，<strong>Action对象的创建使用了原型模式</strong>，访问一个已经存在的Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。<br>③ 在<strong>Spring</strong>中，用户也可以<strong>采用原型模式来创建新的bean实例</strong>，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</p>
<hr>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><hr>
<ul>
<li><strong>模式定义</strong></li>
</ul>
<p><strong>单例模式</strong>(Singleton Pattern)：单例模式<strong>确保某一个类只有一个实例</strong>，而且<strong>自行实例化</strong>并<strong>向整个系统提供这个实例</strong>，这个类称为单例类，它<strong>提供全局访问的方法</strong>。<br>单例模式的<strong>要点有三个</strong>：<strong>一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例</strong>。单例模式是一种<strong>对象创建型</strong>模式。单例模式又名单件模式或单态模式。</p>
<ul>
<li><strong>模式结构</strong></li>
</ul>
<p><img src="images\图片4.png" alt="images\图片4"></p>
<p>单例模式包含如下角色：Singleton（单例）</p>
<p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。<strong>单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。</strong>除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，<strong>该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">null</span>;  <span class="comment">/*静态私有成员变量*/</span></span><br><span class="line">	<span class="comment">/*私有构造函数*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">/*静态公有工厂方法，返回唯一实例*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">		    instance=<span class="keyword">new</span> Singleton();	</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在单例模式的实现过程中，需要注意如下三点：</em><br><strong>① 单例类的构造函数为私有；</strong><br><strong>② 提供一个自身的静态私有成员变量；</strong><br><strong>③ 提供一个公有的静态工厂方法。</strong></p>
<ul>
<li><strong>模式优缺点</strong></li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<p>① <strong>提供了对唯一实例的受控访问</strong>。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。<br>② 由于在系统内存中只存在一个对象，因此<strong>可以节约系统资源</strong>，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。<br>③ 允许可变数目的实例。我们<strong>可以基于单例模式进行扩展</strong>，使用与单例控制相似的方法来获得指定个数的对象实例。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>① 由于单例模式中没有抽象层，因此单例类的<strong>扩展有很大的困难</strong>。<br>② <strong>单例类的职责过重</strong>，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。<br>③ <strong>滥用单例将带来一些负面问题</strong>，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</p>
</blockquote>
<ul>
<li><strong>模式适用环境</strong></li>
</ul>
<p>① <strong>系统只需要一个实例对象</strong>，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。<br>② 客户调用类的单个实例<strong>只允许使用一个公共访问点</strong>，除了该公共访问点，不能通过其他途径访问该实例。<br>③ <strong>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</strong></p>
<ul>
<li><strong>模式应用</strong></li>
</ul>
<p>① <strong>java.lang.Runtime类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/*......*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 数据库中<strong>只能有一个地方分配下一个主键编号</strong>，否则会出现主键重复。因此该<strong>主键编号生成器</strong>必须具备唯一性，可以通过单例模式来实现。</p>
<p>③ 默认情况下，<strong>Spring会通过单例模式创建bean实例</strong></p>
<blockquote>
<p> &lt; bean id=”date” class=”java.util.Date” scope=”singleton” /&gt;</p>
</blockquote>
<ul>
<li><strong>模式扩展</strong></li>
</ul>
<p>饿汉式单例类：</p>
<p><img src="images\图片5.png" alt="images\图片5"></p>
<p>懒汉式单例类：</p>
<p><img src="images\图片6.png" alt="images\图片6"></p>
<ul>
<li><p>饿汉式单例类在自己被加载时就将自己实例化。<strong>单从资源利用效率角度来讲，这个比懒汉式单例类稍差些。从速度和反应时间角度来讲，则比懒汉式单例类稍好些</strong>。</p>
</li>
<li><p>懒汉式单例类在实例化时，<strong>必须处理好在多个线程同时首次引用此类时的访问限制问题</strong>，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过<strong>同步化机制</strong>进行控制。</p>
</li>
</ul>
<blockquote>
<p>懒汉式单例类 ——&gt; 加锁（synchronized）——&gt; 双重检测锁（<em>Double Checked locking</em>） ——&gt;  使用volatile修饰静态变量（防止指令重排序）</p>
</blockquote>

        </div>
      </div>
    </div>
	
	  <span id="back-to-top">
	  <a href="#top"><img src="/img/top3.png"></a>
	</span>
	
  </div>

</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <!-- 
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
		-->
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

