<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mute">
  <!-- Open Graph Data -->
  <meta property="og:title" content="设计模式（三）">
  <meta property="og:description" content="杨柳潇个人主页">
  <meta property="og:site_name" content="杨柳潇的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yangliuxiao.top">
  
    <link rel="alternate" href="/atom.xml" title="杨柳潇的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Site Title -->
  <title>杨柳潇的博客</title>
  
  <!-- 为了增加TOP按钮，新增的CSS文件 -->
  <link rel="stylesheet" href="/css/TOPButtonStyle.css">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/background.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">设计模式（三）</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kevinyang0304">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/About/index.html">
                  
                  About
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Mute</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-06-02</span>
           <!-- <span class="time">02:44:07</span> -->
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/笔记/">笔记</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/笔记/">#笔记</a> <a class="tag" href="/tags/设计模式/">#设计模式</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p><a href="#策略模式">策略模式</a></p>
<p><a href="#观察者模式">观察者模式</a></p>
<p><a href="#装饰模式">装饰模式</a></p>
<hr>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><hr>
<ul>
<li><strong>模式定义</strong></li>
</ul>
<p><strong>策略模式</strong>(Strategy Pattern)：定义<strong>一系列算法</strong>，将每一个算法<strong>封装</strong>起来，并让它们可以<strong>相互替换</strong>。策略模式<strong>让算法独立于使用它的客户而变化</strong>，也称为政策模式(Policy)。策略模式是一种<strong>对象行为型模式</strong>。</p>
<ul>
<li><strong>模式结构</strong></li>
</ul>
<p><img src="images\图片1.png" alt="images\图片1"></p>
<p>策略模式包含如下角色：</p>
<blockquote>
<p>Context: 环境类</p>
<p>Strategy: 抽象策略类</p>
<p>ConcreteStrategy: 具体策略类</p>
</blockquote>
<p>策略模式是一个比较容易理解和使用的设计模式，<strong>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。</strong>策略模式通常<strong>把一个系列的算法封装到一系列的策略类</strong>里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</p>
<ul>
<li><strong>模式优缺点</strong></li>
</ul>
<p><strong>优点：</strong></p>
<blockquote>
<p>① 策略模式提供了<strong>对“开闭原则”的完美支持</strong>，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。<br>② 策略模式提供了管理相关的<strong>算法族</strong>的办法。<br>③ 策略模式提供了可以替换继承关系的办法。<br>④ 使用策略模式可以避免使用多重条件转移语句。</p>
</blockquote>
<p><strong>缺点</strong>：</p>
<blockquote>
<p>① 客户端<strong>必须知道所有的策略类</strong>，并自行决定使用哪一个策略类。<br>② 策略模式<strong>将造成产生很多策略类</strong>，可以通过使用享元模式在一定程度上减少对象的数量。</p>
</blockquote>
<ul>
<li><strong>模式适用环境</strong></li>
</ul>
<p>① 如果在一个系统里面有许多类，<strong>它们之间的区别仅在于它们的行为</strong>，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>② 一个系统<strong>需要动态地在几种算法中选择一种。</strong><br>③ 如果<strong>一个对象有很多的行为</strong>，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br>④ 不希望客户端知道复杂的、与算法相关的数据结构，<strong>在具体策略类中封装算法和相关的数据结构</strong>，提高算法的保密性与安全性。</p>
<ul>
<li><strong>模式应用</strong></li>
</ul>
<p><strong>Java SE的容器布局管理就是策略模式应用的一个经典实例</strong></p>
<p><code>jframe.setLayout(FlowLayout)</code></p>
<p><img src="images\图片2.png" alt="images\图片2"></p>
<ul>
<li><strong>策略模式与状态模式区别</strong></li>
</ul>
<blockquote>
<p>可以通过<strong>环境类状态的个数</strong>来决定是使用策略模式还是状态模式。<br>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。<br>使用策略模式时，<strong>客户端需要知道所选的具体策略是哪一个</strong>，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。<br>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</p>
</blockquote>
<hr>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><hr>
<ul>
<li><strong>模式定义</strong></li>
</ul>
<p><strong>观察者模式</strong>(Observer Pattern)：定义对象间的一种<strong>一对多依赖关系</strong>，使得<strong>每当一个对象状态发生改变</strong>时，<strong>其相关依赖对象皆得到通知并被自动更新</strong>。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种<strong>对象行为型模式</strong>。</p>
<ul>
<li><strong>模式结构</strong></li>
</ul>
<p><img src="images\图片3.png" alt="images\图片3"></p>
<p>观察者模式包含如下角色：</p>
<blockquote>
<p>Subject: 目标<br>ConcreteSubject: 具体目标<br>Observer: 观察者<br>ConcreteObserver: 具体观察者</p>
</blockquote>
<p>观察者模式描述了如何<strong>建立对象与对象之间的依赖关系</strong>，如何构造满足这种需求的系统。<br>这一模式中的关键对象是观察目标和观察者，<strong>一个目标可以有任意数目的与之相依赖的观察者</strong>，一旦目标的状态发生改变，所有的观察者都将得到通知。<strong>（是由目标主动向观察者通知，所以严格意义上并不是观察者在“监视”，而是被观察者主动“自首”）</strong><br>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅(publish-subscribe)</strong>。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</p>
<ul>
<li><strong>观察者模式优缺点</strong></li>
</ul>
<p><strong>优点:</strong></p>
<blockquote>
<p>① 观察者模式<strong>可以实现表示层和数据逻辑层的分离</strong>，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。<br>② 观察者模式在观察目标和观察者之间<strong>建立一个抽象的耦合</strong>。<br>③ 观察者模式支持<strong>广播通信</strong>。<br>④ 观察者模式<strong>符合“开闭原则”的要求</strong>。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>① 如果一个观察目标对象有很多直接和间接的观察者的话，<strong>将所有的观察者都通知到会花费很多时间</strong>。<br>② 如果在观察者和观察目标之间有<strong>循环依赖</strong>的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。<br>③ 观察者模式<strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而仅仅只是知道观察目标发生了变化。</p>
</blockquote>
<ul>
<li><strong>模式适用环境</strong></li>
</ul>
<p>① 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。<br>② 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，<strong>可以降低对象之间的耦合度。</strong><br>③ 一个对象必须通知其他对象，而并不知道这些对象是谁。<br>④ 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p>
<ul>
<li><strong>模式应用</strong></li>
</ul>
<p>(1) JDK1.1版本及以后的各个版本中，事件处理模型采用<strong>基于观察者模式的委派事件模型</strong>(Delegation Event Model, DEM)。在DEM中，事件的发布者称为事件源(Event Source)，而订阅者叫做事件监听器(Event Listener)，在这个过程中还可以通过事件对象(Event Object)来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。事件源对象、事件监听对象（事件处理对象）和事件对象构成了Java事件处理模型的三要素。</p>
<p>(2)除了AWT中的事件处理之外，<strong>Java语言解析XML的技术SAX2</strong>以及<strong>Servlet技术的事件处理机制</strong>都基于DEM，它们都是观察者模式的应用。<br>(3) 观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 </p>
<ul>
<li><strong>模式扩展</strong></li>
</ul>
<p>在<strong>JDK的java.util包</strong>中，提供了<strong>Observable类以及Observer接口</strong>，它们构成了Java语言对观察者模式的支持。 </p>
<p><img src="images\图片4.png" alt="images\图片4"></p>
<p><strong>MVC模式</strong>：</p>
<blockquote>
<p>MVC模式是一种架构模式，它包含三个角色：<strong>模型(Model)，视图(View)和控制器(Controller)</strong>。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。<strong>当模型层的数据发生改变时，视图层将自动改变其显示内容。</strong></p>
</blockquote>
<hr>
<h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><hr>
<ul>
<li><strong>模式定义</strong></li>
</ul>
<p><strong>装饰模式</strong>(Decorator Pattern) ：<strong>动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为<strong>包装器(Wrapper)</strong>，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种<strong>对象结构型</strong>模式。</p>
<ul>
<li><strong>模式结构</strong></li>
</ul>
<p><img src="images\图片5.png" alt="images\图片5"></p>
<p>装饰模式包含如下角色：</p>
<blockquote>
<p>Component: 抽象构件<br>ConcreteComponent: 具体构件<br>Decorator: 抽象装饰类<br>ConcreteDecorator: 具体装饰类</p>
</blockquote>
<p>与继承关系相比，关联关系的主要优势在于<strong>不会破坏类的封装性</strong>，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于<strong>关联关系使系统具有较好的松耦合性</strong>，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。</p>
<p>使用装饰模式来实现扩展<strong>比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</strong></p>
<ul>
<li><strong>模式优缺点</strong></li>
</ul>
<p>优点</p>
<blockquote>
<p>① 装饰模式与继承关系的目的都是要扩展对象的功能，但是<strong>装饰模式可以提供比继承更多的灵活性。</strong><br>② 可以通过一种<strong>动态的方式</strong>来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。<br>③ 通过<strong>使用不同的具体装饰类以及这些装饰类的排列组合</strong>，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。<br>④ <strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。    </p>
</blockquote>
<p>缺点</p>
<blockquote>
<p>① 使用装饰模式进行系统设计时将产生<strong>很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将<strong>产生很多具体装饰类</strong>。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。<br>② 这种比继承更加灵活机动的特性，也同时意味着<strong>装饰模式比继承更加易于出错</strong>，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</p>
</blockquote>
<ul>
<li><strong>模式适用环境</strong></li>
</ul>
<p>① 在不影响其他对象的情况下，<strong>以动态、透明的方式给单个对象添加职责</strong>。<br>② 需要<strong>动态</strong>地给一个对象增加功能，这些功能也可以<strong>动态地被撤销</strong>。<br>③ 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，<strong>为支持每一种组合将产生大量的子类</strong>，使得子类数目呈爆炸性增长；第二类是因为<strong>类定义不能继承（如final类）</strong>。</p>
<ul>
<li><strong>模式应用</strong></li>
</ul>
<p>(1) 在javax.swing包中，可以通过装饰模式动态给一些构件增加新的行为或改善其外观显示。 如JList构件本身并不支持直接滚动，即没有滚动条，要创建可以滚动的列表，可以使用如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JList list = <span class="keyword">new</span> JList();JScrollPane sp = <span class="keyword">new</span> JScrollPane(list);</span><br></pre></td></tr></table></figure>
<p>(2) 装饰模式在JDK中最经典的实例是Java IO。<br>以InputStream为例： </p>
<p><strong>角色分配：</strong></p>
<blockquote>
<p>抽象构件类：InputStream<br>具体构件类：FileInputStream、ByteArrayInputStream等<br>抽象装饰类：FilterInputStream<br>具体装饰类：BufferedInputStream、DataInputStream等</p>
</blockquote>
<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*……*/</span></span><br><span class="line">FileInputStream inFS=<span class="keyword">new</span> FileInputStream(<span class="string">"temp/fileSrc.txt"</span>);		</span><br><span class="line">BufferedInputStream inBS=<span class="keyword">new</span> BufferedInputStream(inFS);</span><br><span class="line"><span class="comment">/*定义一个字节数组，用于存放缓冲数据*/</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">inBS.read(data);</span><br><span class="line"><span class="comment">/*…… */</span></span><br></pre></td></tr></table></figure>

        </div>
      </div>
    </div>
	
	  <span id="back-to-top">
	  <a href="#top"><img src="/img/top3.png"></a>
	</span>
	
  </div>

</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <!-- 
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
		-->
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

