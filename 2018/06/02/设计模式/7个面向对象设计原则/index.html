<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mute">
  <!-- Open Graph Data -->
  <meta property="og:title" content="7个面向对象设计原则">
  <meta property="og:description" content="杨柳潇个人主页">
  <meta property="og:site_name" content="杨柳潇的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yangliuxiao.top">
  
    <link rel="alternate" href="/atom.xml" title="杨柳潇的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Site Title -->
  <title>杨柳潇的博客</title>
  
  <!-- 为了增加TOP按钮，新增的CSS文件 -->
  <link rel="stylesheet" href="/css/TOPButtonStyle.css">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/background.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">7个面向对象设计原则</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kevinyang0304">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/About/index.html">
                  
                  About
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Mute</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-06-02</span>
           <!-- <span class="time">14:51:39</span> -->
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/笔记/">笔记</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Java/">#Java</a> <a class="tag" href="/tags/笔记/">#笔记</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p><a href="#面向对象设计原则概述">面向对象设计原则概述</a><br><a href="#单一职责原则">单一职责原则</a><br><a href="#开闭原则">开闭原则</a><br><a href="#里氏代换原则">里氏代换原则</a><br><a href="#依赖倒转原则">依赖倒转原则</a><br><a href="#接口隔离原则">接口隔离原则</a><br><a href="#合成复用原则">合成复用原则</a><br><a href="#迪米特法则">迪米特法则</a></p>
<hr>
<h4 id="面向对象设计原则概述"><a href="#面向对象设计原则概述" class="headerlink" title="面向对象设计原则概述"></a>面向对象设计原则概述</h4><p><strong>软件的复用(Reuse)或重用</strong>拥有众多优点，比如可以提高软件的开发效率，提高软件质量，节约开发成本，<strong>恰当的复用还可以改善系统的可维护性。</strong>面向对象设计复用的目标在于<strong>实现支持可维护性的复用。</strong><br>在面向对象的设计里面，<strong>可维护性复用都是以面向对象设计原则为基础的</strong>，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</p>
<p>面向对象设计原则和设计模式也是对系统进行合理重构的指南针，<strong><em>重构(Refactoring)</em></strong>是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。 </p>
<p>常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们<strong>相互依赖，相互补充。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>设计原则名称</th>
<th>设计原则简介</th>
<th>重要性</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则(Single Responsibility Principle, SRP)</td>
<td>类的职责要单一，不能将太多的职责放在一个类中</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>开闭原则(Open-Closed Principle, OCP)</td>
<td>软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能</td>
<td>★★★★★</td>
</tr>
<tr>
<td>里氏代换原则(Liskov Substitution Principle, LSP)</td>
<td>在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>依赖倒转原则(Dependency Inversion Principle, DIP)</td>
<td>要针对抽象层编程，而不要针对具体类编程</td>
<td>★★★★★</td>
</tr>
<tr>
<td>接口隔离原则(Interface Segregation Principle, ISP)</td>
<td>使用多个专门的接口来取代一个统一的接口</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>合成复用原则(Composite Reuse Principle, CRP)</td>
<td>在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>迪米特法则(Law of Demeter, LoD)</td>
<td>一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
</div>
<p>下面详细地介绍这7个原则。</p>
<hr>
<h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><ul>
<li><p><strong>定义</strong>：一个对象应该只包含<strong>单一的职责</strong>，并且该职责被完整地封装在一个类中。（就一个类而言，应该<strong>仅有一个引起它变化的原因</strong>。 ）</p>
</li>
<li><p><strong>分析</strong>：一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 </p>
</li>
</ul>
<p>类的职责主要包括两个方面：<strong>数据职责和行为职责</strong>，数据职责通过其属性来体现，而行为职责通过其方法来体现。</p>
<p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<hr>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><ul>
<li><p><strong>定义</strong>：一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</p>
</li>
<li><p><strong>分析</strong>：<strong>抽象化</strong>是开闭原则的关键（设立抽象层）。 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，<strong>对可变性封装原则</strong>(Principle of Encapsulation of Variation, EVP)要求找到系统的<strong>可变因素</strong>并将其封装起来。 </p>
</li>
</ul>
<p>一般可以通过<strong>建立抽象层（里氏代换原则）、从配置文件中读取具体参数、反射机制</strong>来达成开闭原则。</p>
<hr>
<h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><ul>
<li><p><strong>定义</strong>：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。（<strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</strong>）</p>
</li>
<li><p><strong>分析</strong>：里氏代换原则可以通俗表述为：<strong>在软件中如果能够使用基类对象，那么一定能够使用其子类对象</strong>。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</strong></p>
</li>
</ul>
<hr>
<h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><ul>
<li><p><strong>定义</strong>：高层模块不应该依赖低层模块，它们<strong>都应该依赖抽象</strong>。<strong>抽象不应该依赖于细节，细节应该依赖于抽象。</strong>（要针对<strong>接口</strong>编程，不要针对<strong>实现</strong>编程。）</p>
</li>
<li><p><strong>分析</strong>：简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说<strong>开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</strong></p>
</li>
</ul>
<p>依赖倒转原则的常用实现方式之一是<strong>在代码中使用抽象类，而将具体类放在配置文件中。</strong></p>
<blockquote>
<p> “Put Abstractions in Code, Details in Metadata”（将抽象放进代码，将细节放进<strong>元数据</strong>）—— 《程序员修炼之道：从小工到专家》                                                                                                               </p>
</blockquote>
<p><strong>依赖注入（如何将具体子类注入到使用抽象基类的方法或类中去）：</strong></p>
<p> ① <strong>构造注入</strong>(Constructor Injection)：通过构造函数注入实例变量。</p>
<p> ② <strong>设值注入</strong>(Setter Injection)：通过Setter方法注入实例变量。</p>
<p> ③ <strong>接口注入</strong>(Interface Injection)：通过接口方法注入实例变量。 </p>
<hr>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><ul>
<li><p><strong>定义</strong>：客户端<strong>不应该依赖那些它不需要的接口</strong>。（一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。）</p>
</li>
<li><p><strong>分析</strong>：接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。使用接口隔离原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，<strong>只提供用户需要的行为，而隐藏用户不需要的行为。</strong></p>
</li>
</ul>
<hr>
<h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h4><ul>
<li><p><strong>定义</strong>：尽量使用<strong>对象组合</strong>，而<strong>不是继承</strong>来达到复用的目的。</p>
</li>
<li><p><strong>分析</strong>：合成复用原则就是指在一个新的对象里通过<strong>关联关系（包括组合关系和聚合关系）</strong>来使用一些已有的对象，使之成为新对象的一部分；新对象<strong>通过委派调用已有对象</strong>的方法达到复用其已有功能的目的。简言之：<strong>要尽量使用组合/聚合关系，少用继承。</strong></p>
</li>
</ul>
<p><strong>继承复用和组合复用的比较：</strong></p>
<blockquote>
<ul>
<li><p>继承复用：实现简单，易于扩展。但会破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。（“白箱”复用 ）</p>
</li>
<li><p>组合/聚合复用：可以使系统更加灵活，类与类之间的耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ）</p>
</li>
</ul>
</blockquote>
<hr>
<h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><ul>
<li><p><strong>定义</strong>：不要和“陌生人”说话（只与你的直接朋友通信）（每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位）</p>
</li>
<li><p><strong>分析</strong>：简单地说，迪米特法则就是指一个软件实体应当尽可能少的与其他实体发生相互作用。这样，<strong>当一个模块修改时，就会尽量少的影响其他的模块</strong>，扩展会相对容易，这是对软件实体之间<strong>通信</strong>的限制，它要求限制软件实体之间通信的宽度和深度。</p>
<p>① 狭义的迪米特法则：可以<strong>降低类之间的耦合</strong>，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是<strong>也会造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</p>
<p>② 广义的迪米特法则：指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</p>
</li>
</ul>
<p>迪米特法则的主要用途在于<strong>控制信息的过载</strong>：</p>
<blockquote>
<ul>
<li><p>在类的划分上，应当<strong>尽量创建松耦合的类</strong>，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</p>
</li>
<li><p>在类的结构设计上，每一个类都应当<strong>尽量降低其成员变量和成员函数的访问权限</strong>；</p>
</li>
<li><p>在类的设计上，只要有可能，一个类型应当设计成<strong>不变类</strong>；</p>
</li>
<li><p>在对其他类的引用上，一个对象对其他对象的<strong>引用应当降到最低</strong>。</p>
</li>
</ul>
</blockquote>
<p><img src="图片1.png" alt="图片1"></p>

        </div>
      </div>
    </div>
	
	  <span id="back-to-top">
	  <a href="#top"><img src="/img/top3.png"></a>
	</span>
	
  </div>

</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <!-- 
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
		-->
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

