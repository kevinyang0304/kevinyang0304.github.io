<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mute">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Java多线程二三事">
  <meta property="og:description" content="杨柳潇个人主页">
  <meta property="og:site_name" content="杨柳潇的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yangliuxiao.top">
  
    <link rel="alternate" href="/atom.xml" title="杨柳潇的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Site Title -->
  <title>杨柳潇的博客</title>
  
  <!-- 为了增加TOP按钮，新增的CSS文件 -->
  <link rel="stylesheet" href="/css/TOPButtonStyle.css">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/background.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Java多线程二三事</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kevinyang0304">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/About/index.html">
                  
                  About
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Mute</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-03-20</span>
           <!-- <span class="time">09:51:24</span> -->
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Java技术/">Java技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Java/">#Java</a> <a class="tag" href="/tags/面试/">#面试</a> <a class="tag" href="/tags/多线程/">#多线程</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p><a href="#（1）Java线程创建方式">（1）Java线程创建方式</a></p>
<p><a href="#（2）线程状态说明">（2）线程状态说明</a></p>
<p><a href="#（3）Thread中的方法">（3）Thread中的方法</a></p>
<blockquote>
<p><a href="#（1）start方法">① start方法</a></p>
<p><a href="#（2）run方法">② run方法</a></p>
<p><a href="#（3）join方法">③ join方法</a></p>
<p><a href="#（4）yield方法">④ yield方法</a></p>
<p><a href="#（5）sleep方法">⑤ sleep方法</a></p>
<p><a href="#（6）interrupt方法和线程中断方式">⑥ interrupt方法和线程中断方式</a></p>
</blockquote>
<p><a href="#（4）Object类中的wait、notify、notifyAll方法">（4）Object类中的wait、notify、notifyAll方法</a></p>
<hr>
<h4 id="（1）Java线程创建方式"><a href="#（1）Java线程创建方式" class="headerlink" title="（1）Java线程创建方式"></a>（1）Java线程创建方式</h4><hr>
<p><strong>方法一：继承<code>Thread</code>类，作为线程对象存在（继承Thread对象）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThreadDemo1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法： 继承父类方法的Thread(String name)；方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreatThreadDemo1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Thread类的interrupted方法，是来判断该线程是否被中断*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!interrupted())&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"线程执行了..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CreatThreadDemo1 d1 = <span class="keyword">new</span> CreatThreadDemo1(<span class="string">"first"</span>);</span><br><span class="line">        CreatThreadDemo1 d2 = <span class="keyword">new</span> CreatThreadDemo1(<span class="string">"second"</span>);</span><br><span class="line"></span><br><span class="line">        d1.start();</span><br><span class="line">        d2.start();</span><br><span class="line"></span><br><span class="line">        d1.interrupt();  <span class="comment">/*中断第一个线程*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样。</strong></p>
<p><strong>方法二：实现runnable接口，作为线程任务存在</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThreadDemo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程执行了..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*将线程任务传给线程对象*/</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CreatThreadDemo2());</span><br><span class="line">        <span class="comment">/*启动线程*/</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里（<code>new Thread(实现了Runnable接口的类)</code>）</p>
<p><strong>方法三：匿名内部类创建线程对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThreadDemo3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*创建无参线程对象*/</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程执行了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">       <span class="comment">/*创建带线程任务的线程对象*/</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程执行了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">/*创建带线程任务并且重写run方法的线程对象*/</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"runnable run 线程执行了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"override run 线程执行了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程执行了...</span><br><span class="line">线程执行了...</span><br><span class="line">override run 线程执行了...</span><br></pre></td></tr></table></figure>
<p><strong>方法四：创建带返回值的线程（FutureTask）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThreadDemo4</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CreatThreadDemo4 demo4 = <span class="keyword">new</span> CreatThreadDemo4();</span><br><span class="line"></span><br><span class="line">        FutureTask task = <span class="keyword">new</span> FutureTask(demo4); <span class="comment">/*FutureTask最终实现的是runnable接口*/</span></span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务"</span>);</span><br><span class="line">        <span class="comment">/*拿出线程执行的返回值*/</span></span><br><span class="line">        Integer result = task.get();</span><br><span class="line">        System.out.println(<span class="string">"线程中运算的结果为:"</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*重写Callable接口的call方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"业务逻辑计算中..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Callable接口介绍：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回<strong>指定泛型的call方法</strong>。然后调用<code>FutureTask</code>对象的get方法得道call方法的返回值。</p>
<p><strong>方法五：定时器(Timer、TimerTask)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThreadDemo5</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"定时器线程执行了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">1000</span>);   <span class="comment">/*延迟0，周期1s*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法六：线程池创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThreadDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*创建一个具有10个线程的线程池*/</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">long</span> threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"线程执行了..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> threadpoolUseTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"多线程用时"</span>+(threadpoolUseTime1-threadpoolUseTime));</span><br><span class="line">        <span class="comment">/*销毁线程池*/</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="（2）线程状态说明"><a href="#（2）线程状态说明" class="headerlink" title="（2）线程状态说明"></a>（2）线程状态说明</h4><hr>
<ul>
<li><strong>Java源码中Thread类中的内部枚举类型State一共声明了六种状态：</strong></li>
</ul>
<p><strong>1. NEW</strong>： 新建状态，线程对象已经创建，但尚未启动。实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p>
<p><strong>2. RUNNABLE：</strong>就绪状态，可运行状态，调用了线程的start方法，已经在java虚拟机中执行，等待获取操作系统资源如CPU，操作系统调度运行。</p>
<blockquote>
<ul>
<li><strong>2.1 就绪状态</strong></li>
</ul>
<p>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。<br>调用线程的<code>start()</code>方法，此线程进入就绪状态。<br>当前线程<code>sleep()</code>方法结束，其他线程<code>join()</code>结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。<br>当前线程时间片用完了，调用当前线程的<code>yield()</code>方法，当前线程进入就绪状态。<br>锁池里的线程拿到对象锁后，进入就绪状态。</p>
<ul>
<li><strong>2.2 运行中状态</strong></li>
</ul>
<p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
</blockquote>
<p><strong>3. BLOCKED</strong>:堵塞状态。线程等待锁的状态，等待获取锁进入同步块/方法或调用wait后重新进入需要竞争锁</p>
<p><strong>4. WAITING</strong>：等待状态。等待另一个线程以执行特定的操作。调用以下方法进入等待状态。 <code>Object.wait()</code>, <code>Thread.join()</code>,<code>LockSupport.park</code>,处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p>
<p><strong>5. TIMED_WAITING:</strong> 线程等待一段时间。调用带参数的<code>Thread.sleep()</code>, <code>objct.wait()</code>,<code>Thread.join()</code>，<code>LockSupport.parkNanos</code>,<code>LockSupport.parkUntil</code>会进入这种状态,处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p>
<p><strong>6. TERMINATED</strong>:进程结束状态。当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
<hr>
<h4 id="（3）Thread中的方法"><a href="#（3）Thread中的方法" class="headerlink" title="（3）Thread中的方法"></a>（3）Thread中的方法</h4><hr>
<h5 id="（1）start方法"><a href="#（1）start方法" class="headerlink" title="（1）start方法"></a>（1）start方法</h5><p>API中对于该方法的介绍：</p>
<blockquote>
<p>调用start()方法会使该线程开始执行，<strong>Java 虚拟机</strong>调用该线程的<code>run</code>方法。<br>结果是两个线程并发地运行；当前线程（从<code>start</code>方法调用返回）和另一个线程（执行其<code>run</code>方法）。<br>多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</p>
</blockquote>
<p>用start方法来启动线程，真正实现了多线程运行，这时<strong>无需等待run方法体代码执行完毕而直接继续执行下面的代码</strong>。通过调用Thread类的 start()方法来启动一个线程，这时此线程处于<strong>就绪（可运行）状态</strong>，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</p>
<h5 id="（2）run方法"><a href="#（2）run方法" class="headerlink" title="（2）run方法"></a>（2）run方法</h5><p>API中对该方法的介绍：</p>
<p>如果该线程是使用独立的<code>Runnable</code>运行对象构造的，则调用该<code>Runnable</code>对象的<code>run</code>方法；否则，该方法不执行任何操作并返回。<code>Thread</code>的子类应该重写该方法。</p>
<p><strong>run()方法只是类的一个普通方法而已</strong>，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<ul>
<li><strong>调用start方法方可启动线程，而直接调用run方法只是Thread的一个普通方法调用，还是在主线程里执行。</strong></li>
</ul>
<h5 id="（3）join方法"><a href="#（3）join方法" class="headerlink" title="（3）join方法"></a>（3）join方法</h5><p>Thread类中的<code>join()</code>方法的主要作用就是<strong>同步</strong>，它可以使得线程之间的<strong>并行执行变为串行执行</strong>。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</p>
<p>join方法也可以传递一个参数给它，<code>t1.join(10)</code>表示主线程线程会等待t1线程10毫秒，10毫秒过去后，主线程和t1线程之间执行顺序<strong>由串行执行变为普通的并行执行</strong>，join(0)等价于join()。</p>
<p>join方法必须在线程start方法调用之后调用才有意义，join方法在start方法前调用时，并不能起到同步的作用，即join没有作用，等到start方法执行完后，两个线程依旧交替执行。</p>
<ul>
<li><strong>join()方法实现原理</strong></li>
</ul>
<p><strong>join()源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>join方法是<strong>通过调用线程的<code>wait方法</code>来达到同步的目的的</strong>。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态,当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>
<h5 id="（4）yield方法"><a href="#（4）yield方法" class="headerlink" title="（4）yield方法"></a>（4）yield方法</h5><p><code>yield()</code>的作用是<strong>让步</strong>。它能<strong>让当前线程由“运行状态”进入到“就绪状态”</strong>，从而让其它具有相同优先级的等待线程获取执行权；但是，<strong>并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</strong></p>
<ul>
<li><strong>yield()和wait()方法的比较</strong></li>
</ul>
<blockquote>
<p>① wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。  </p>
<p>② wait()是会线程释放它所持有对象的同步锁，而<strong>yield()方法不会释放锁（即只让出cpu时间片）。</strong></p>
</blockquote>
<h5 id="（5）sleep方法"><a href="#（5）sleep方法" class="headerlink" title="（5）sleep方法"></a>（5）sleep方法</h5><p><code>sleep()</code> 的作用是让当前线程休眠，即<strong>当前线程会从“运行状态”进入到“休眠(阻塞)状态”</strong>。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行</p>
<ul>
<li><strong>sleep() 与 wait()的比较</strong></li>
</ul>
<blockquote>
<p>wait()的作用是让当前线程由“运行状态”进入“等待(WAITING)状态”的同时，而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(TIMED_WAITING)状态”。  但是，<strong>wait()会释放对象的同步锁，而sleep()则不会释放锁。</strong></p>
</blockquote>
<h5 id="（6）interrupt方法和线程中断方式"><a href="#（6）interrupt方法和线程中断方式" class="headerlink" title="（6）interrupt方法和线程中断方式"></a>（6）interrupt方法和线程中断方式</h5><p><code>interrupt()</code>的<strong>作用是中断本线程（不会终止处于“运行状态”的线程，而是通过将线程的中断标记设为true来终止线程）。</strong><br>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过<code>checkAccess()</code>检查权限。这有可能抛出<code>SecurityException</code>异常。<br>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。<strong>若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个<code>InterruptedException</code>异常</strong>。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。<br>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。<br>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。</p>
<p><strong>中断一个“已终止的线程”不会产生任何操作。</strong></p>
<ul>
<li><strong>中断线程的方式</strong></li>
</ul>
<p><strong>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！</strong><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html" target="_blank" rel="noopener">Why is <code>Thread.stop</code> deprecated?</a></p>
<p>使用interrupt()终止线程：</p>
<ul>
<li><strong>interrupt()：</strong>在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。<strong>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</strong></li>
<li><strong>isInterrupted()</strong>：用来返回当前线程的中断状态(true or false)。</li>
<li><strong>interrupted()</strong>：是一个Thread的static方法，用来恢复中断状态，<strong>即将中断标记重新设为false</strong></li>
</ul>
<p>（1）终止处于“阻塞状态”的线程</p>
<p>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个<code>InterruptedException</code>异常。将InterruptedException放在适当的位置就能终止线程，形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/* 执行任务...*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">/* 由于产生InterruptedException异常，退出while(true)循环，线程终止！*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理(添加break语句)。</p>
<p>（2）终止处于“运行状态”的线程</p>
<p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“<strong>中断标记</strong>”和“<strong>额外添加标记</strong>”。</p>
<p><strong>① 通过“中断标记”终止线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">/*执行任务...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isInterrupted()</code>是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的<code>interrupt()</code>方法，使用线程的中断标记为true，即<code>isInterrupted()</code>会返回true。此时，就会退出while循环。</p>
<p><strong>② 通过“额外添加标记”</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag= <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stopTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="comment">/* 执行任务...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。  </p>
<p><strong>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</strong></p>
<ul>
<li><strong>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 1. isInterrupted()保证，只要中断标记为true就终止线程。*/</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">/* 执行任务...*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">/* 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="（4）Object类中的wait、notify、notifyAll方法"><a href="#（4）Object类中的wait、notify、notifyAll方法" class="headerlink" title="（4）Object类中的wait、notify、notifyAll方法"></a>（4）Object类中的wait、notify、notifyAll方法</h4><hr>
<p>首先看以下示例代码：</p>
<p>代码定义了一个3秒后唤醒等待线程的<strong>NotifyThread</strong>线程类，定义了一个用以等待的<strong>WaitThread</strong>类，定义了一个<strong>flag</strong>数组对象用来充当等待的对象（<strong>flag需要进行修改判断</strong>的原因是防止notifyAll方法执行完后还有线程执行wait方法，比如线程1、2运行至wait方法，而线程3因未知原因阻塞了一会，这时NotifyThread线程执行完了notifyAll方法，则线程3无法被唤醒）。在main方法中同时启动一个Notify线程和三个wait线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String flag[] = &#123;<span class="string">"true"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NotifyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">3000</span>);<span class="comment">/* 推迟3秒钟通知*/</span></span><br><span class="line">                System.out.println(<span class="string">"3s later"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (flag) &#123;</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="string">"false"</span>;</span><br><span class="line">                flag.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaitThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag[<span class="number">0</span>] != <span class="string">"false"</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(getName() + <span class="string">" begin waiting!"</span>);</span><br><span class="line">                    <span class="keyword">long</span> waitTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        flag.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    waitTime = System.currentTimeMillis() - waitTime;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">                        System.out.println(getName() + <span class="string">" wait time :"</span> + waitTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(getName() + <span class="string">" end waiting!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Main Thread Run!"</span>);</span><br><span class="line">        NotifyTest test = <span class="keyword">new</span> NotifyTest();</span><br><span class="line">        NotifyThread notifyThread = test.new NotifyThread(<span class="string">"notify01"</span>);</span><br><span class="line">        WaitThread waitThread01 = test.new WaitThread(<span class="string">"waiter01"</span>);</span><br><span class="line">        WaitThread waitThread02 = test.new WaitThread(<span class="string">"waiter02"</span>);</span><br><span class="line">        WaitThread waitThread03 = test.new WaitThread(<span class="string">"waiter03"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">        waitThread01.start();</span><br><span class="line">        waitThread02.start();</span><br><span class="line">        waitThread03.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行流程讲解</strong>：4个线程开始并行执行，3个等待线程中的某一个（比如waiter01）先获取到flag对象的锁，输出waiter01  begin waiting!，执行到wait方法，释放flag锁，开始等待，3个等待线程中的另外两个中某一个（比如waiter03）获取到flag锁，输出<code>waiter03 begin waiting!</code>，然后执行到wait方法，释放flag锁，开始等待，余下的一个等待线程也一样。唤醒线程等待3秒之后，获取flag锁，调用notifyAll方法唤醒所有等待flag对象的线程，3个等待线程都被唤醒，依次竞争flag对象锁，依次输出结果。</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Main Thread Run!</span><br><span class="line">waiter01 begin waiting!</span><br><span class="line">waiter03 begin waiting!</span><br><span class="line">waiter02 begin waiting!</span><br><span class="line"><span class="number">3</span>s later</span><br><span class="line">waiter02 wait time :<span class="number">3000</span></span><br><span class="line">waiter02 wait time :<span class="number">3000</span></span><br><span class="line">waiter02 wait time :<span class="number">3000</span></span><br><span class="line">waiter02 end waiting!</span><br><span class="line">waiter03 wait time :<span class="number">3000</span></span><br><span class="line">waiter03 wait time :<span class="number">3000</span></span><br><span class="line">waiter03 wait time :<span class="number">3000</span></span><br><span class="line">waiter03 end waiting!</span><br><span class="line">waiter01 wait time :<span class="number">3000</span></span><br><span class="line">waiter01 wait time :<span class="number">3000</span></span><br><span class="line">waiter01 wait time :<span class="number">3000</span></span><br><span class="line">waiter01 end waiting!</span><br></pre></td></tr></table></figure>
<p>在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，<strong>wait()也会让当前线程释放它所持有的锁</strong>。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>
<p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        — 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   — 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>         — 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong> — 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<p><strong>wait(long timeout, int nanos)</strong> — 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<h5 id="1-wait-方法"><a href="#1-wait-方法" class="headerlink" title="1. wait()方法"></a>1. wait()方法</h5><p>让当前线程进入等待状态，同时，<strong>wait()会让当前线程释放它所持有的锁</strong>。</p>
<h5 id="2-notify-方法"><a href="#2-notify-方法" class="headerlink" title="2. notify()方法"></a>2. notify()方法</h5><p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现（不确定）。</p>
<h5 id="3-notifyAll-方法"><a href="#3-notifyAll-方法" class="headerlink" title="3. notifyAll()方法"></a>3. notifyAll()方法</h5><p>唤醒在此对象监视器上等待的所有线程。</p>
<ul>
<li><strong>为什么wait，notify，notifyAll定义在Object中？</strong></li>
</ul>
<blockquote>
<p>一个很明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得</strong>。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
</blockquote>

        </div>
      </div>
    </div>
	
	  <span id="back-to-top">
	  <a href="#top"><img src="/img/top3.png"></a>
	</span>
	
  </div>

</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
	  <!-- 
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
		-->
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

